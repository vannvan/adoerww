[javascript的垃圾回收机制]([https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/682114/](https://codertw.com/程式語言/682114/))

### 几点基本的认知

> 使用不当的闭包将会在IE(`IE9`之前)中造成内存泄漏

为什么在`IE9`之前会有这个问题？

> `IE9`的JavaScript引擎使用的垃圾回收算法是**引用计数法**，对于循环引用将会导致`GC`无法回收“应该被回收”的内存。造成了无意义的内存占用，也就是内存泄漏。

什么是内存泄漏？

> `Memory Leak`是指程序在已动态分配的`堆内存`由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢或程序崩溃等严重后果。

什么是`GC`

> Garbage Collection的缩写，意为垃圾回收,高级语言一般都有`GC`，ja+++++++++++++va，python，JavaScript都有，C语言没有

###  常用的几种`GC`算法

####  **引用计数法**

简单理解就是让所有对象实现记录下有多少“程序”在引用自己，让各对象都知道自己的“人气指数”。举一个简单的例子：

```js
var a = new Object(); // 此時'這個對象'的引用計數為1（a在引用）
var b = a; // ‘這個對象’的引用計數是2（a,b）
a = null; // reference_count = 1
b = null; // reference_count = 0 
// 下一步 GC來回收‘這個對象’了
```

**优势**

1.  可即可回收垃圾，当引用数值为0时，对象立马会把自己作为空闲空间连到空闲链表上，即变成垃圾就会立刻被回收
2. 因为是即时回收，程序不会暂时使用很长一段时间`GC`，**最大暂停时间**很短
3. 不会遍历堆里面的所有活动对象和非活动对象

**劣势**

1. 计数器需要占用很大的位置，因为不能预估引用的上限
2. 无法解决循环引用无法回收的问题

一个简单的例子：

```js
function f(){
    var o = {};
    var o2 = {};
    o.a = o2; // o 引用 o2,o2的引用次數是1
    o2.a = o; // o2 引用 o,o的引用此時是1
    return "azerty";
}
f();
```

fn在执行完成之后理应回收fn作用域里面的内存空间，但是因为`o`里面有一个属性引用`o2`,导致`o2`的引用次数始终为1，`o2`也是如此，而又非专门当做`閉包`来使用，所以这里就应该使`o`和`o2`被销毁。

因为算法是将`引用次數為0`的对象销毁，此处都不为0，导致`GC`不会回收他们，那么这就是`內存洩漏`问题。

#### **标记清除算法**  `V8`引擎使用的最多的算法

该算法主要将`GC`的垃圾回收分为标记阶段和清除阶段————`标记阶段`会将所有活动对象进行标记，`清除阶段`会将没有标记（非活动对象）进行销毁

**标记阶段**

![](https://codertw.com/wp-content/uploads/img/dyJ9w9d1eW.jpg)

`根`可以理解为全局作用域，`GC`从全局作用域的变量沿作用域逐步往里层遍历（深度遍历）,当遍历到堆中对象时，说明该对象被引用着，就打上一个标记，继续递归遍历（因为还存在堆中对象引用另一个对象），直到遍历到最后一个节点。

![](https://codertw.com/wp-content/uploads/img/UdxyXN2bg0.jpg)

标记完成后，

![](https://codertw.com/wp-content/uploads/img/trYb92Np9S.jpg)

**清除阶段**

继续遍历，遍历整个堆，回收没有打上标记的对象

**优势**

- 实现简单，打标记也就打或不打两种可能，所以一位二进位就可以表示
- 解决了循环引用的问题

**缺点**

- 造成`碎片化`
- 再分配时遍历次数多，如果一直没有找到合适的内存块大小，那么会遍历空闲链表一直遍历到末尾

#### 复制算法

把某个空间里的活动对象复制到其他空间，把原空间里的所有对象都回收掉。在此，我们将复制活动对象的原空间称为 From 空间，将粘贴活动对象的新空间称为 To 空间。需要牺牲半个堆

#### 压缩算法

压缩算法由标记阶段和压缩阶段构成。不用牺牲半个堆。

#### 分代垃圾回收

#### 增量式垃圾回收

