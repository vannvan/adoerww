# 算法:字符串 
## 例题
### 反转字符串-简单
> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
> 不要给另外的数组分配额外的空间，你必须**原地修改**输入数组、使用 O(1) 的额外空间解决这一问题。
> 输入：s = ["h","e","l","l","o"] 输出：["o","l","l","e","h"]
> 来源：[https://leetcode.cn/problems/reverse-string/](https://leetcode.cn/problems/reverse-string/)

#### 代码实现
```javascript
function reverseString(s: string[]): string[] {
  let left = 0
  let right = s.length - 1
  while (left < right) {
    // ;[s[left], s[right]] = [s[right], s[left]]
    let tmp = s[left]
    s[left] = s[right]
    s[right] = tmp
    left++
    right--
  }

  return s
}
```
利用双指针，从两端往中间调换，退出条件是left==right
### 反转字符串 II-中等
> 给定一个字符串 s 和一个整数 k，从字符串开头算起，每**计数至 2k **个字符，就反转这 2k 字符中的前 k 个字符。
> 如果剩余字符少于 k 个，则将**剩余字符全部反转。**
> 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
> 输入：s = "abcdefg", k = 2 输出："bacdfeg"
> 来源：[https://leetcode.cn/problems/reverse-string-ii/](https://leetcode.cn/problems/reverse-string-ii/)

#### 代码实现
```javascript
function reverseStr(s: string, k: number): string {
  let strArr = Array.from(s)

  const reverse = (left, right) => {
    while (left < right) {
      const temp = strArr[left]
      strArr[left] = strArr[right]
      strArr[right] = temp
      left++
      right--
    }
  }

  let n = strArr.length
  // 版本1 反转每个下标从2k的倍数开始的，长度为k的子串，若该子串不足k，则反转整个子串
  // for (let i = 0; i < n; i += 2 * k) {
  //   if (i + k < n) {
  //     console.log('i+k', i + k)
  //     reverse(i, i + k - 1)
  //   } else {
  //     reverse(i, n - 1)
  //   }

  //   // reverse(i, Math.min(i + k, n) - 1)
  // }

  // 版本2
  // for (let i = 0; i < n; i += 2 * k) {
  //   // 每隔 2k 个字符的前 k 个字符进行反转
  //   let l = i - 1,
  //     r = i + k > n ? n : i + k
  //   while (++l < --r) {
  //     ;[strArr[l], strArr[r]] = [strArr[r], strArr[l]]
  //   }
  // }

  // 版本3 更好理解的
  for (let i = 0; i < n; ) {
    //如果剩下的长度大于2倍K，说明需要反转前k个字符（包括当前字符）
    if (n - i >= 2 * k) {
      reverse(i, i + k - 1)
      i += 2 * k
      continue
    }
    // 如果剩下的字符小于k个，则把剩下的全部反转（包括当前字符）
    if (n - i < k) {
      reverse(i, n - 1)
      break
    }
    // 否则就是剩下的字符长度大于等于k，却小于2倍k的，需要反转前k个字符,其余字符不变
    if (n - i < 2 * k && n - i > k) {
      reverse(i, i + k - 1)
      break
    }
  }
  console.log('strArr', strArr)

  return strArr.join('')
}
```
实现思路，将两个“如果”条件考虑，如果满足这两项条件，那么一定是到了2k的后半段了，循环就没必要继续了，剩余的情况就是满足子串长度大于2k，则将这个子串的起始位置到k区间的子子串翻转，即可满足条件
上面更短的实现方式采用“模拟”思想，还需要再琢磨一下！！

### 替换空格-简单
> 请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
> 输入：s = "We are happy." 输出："We%20are%20happy."
> 来源：[https://leetcode.cn/problems/ti-huan-kong-ge-lcof/](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

#### 代码实现
```javascript
function replaceSpace(s: string): string {
  let arr = Array.from(s)
  let emptyCount = 0
  // 计算空格数
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] == ' ') {
      emptyCount++
    }
  }
  let left = arr.length - 1
  let right = arr.length + emptyCount * 2 - 1 // 空格本身就占了一位所以只需要扩充两位
  while (left >= 0) {
    if (arr[left] == ' ') {
      arr[right--] = '0'
      arr[right--] = '2'
      arr[right--] = '%'
      left--
    } else {
      arr[right--] = arr[left--]
    }
  }

  return arr.join('')
}
```
重点是构建字符串组成的数组要计算出替换空格后需要的长度，采用快慢指针从尾部开始替换，遇到空格就依次填入0 2 % 当满指针走到头表示替换完毕，没遇到空格的时候快慢指针同步后退
### 翻转字符串里的单词
> 给你一个字符串 s ，请你反转字符串中 单词 的顺序。
> 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。
> 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。
> 注意：**输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。**
> 输入：s = "the sky is blue" 输出："blue is sky the"
> 来源：[https://leetcode.cn/problems/reverse-words-in-a-string/](https://leetcode.cn/problems/reverse-words-in-a-string/)

PS: [557：反转字符串中的单词 III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/)
#### 代码实现-简单
```javascript

function reverseWords(s: string): string {
  // 反转指定区间的字符
  const reverse = (start: number, end: number) => {
    while (start < end) {
      ;[strArr[start], strArr[end]] = [strArr[end], strArr[start]]
      end--
      start++
    }
  }

  let strArr = s.split('')
  // console.log('strArr', strArr)
  // 1.去除多余空格,不对
  // let n = strArr.length
  // for (let i = 0; i < n; i++) {
  //   if (strArr[i] == ' ' && strArr[i - 1] == ' ') {
  //     strArr.splice(i, 1)
  //   }
  // }

  // 1.去除多余空格，连续超过一个的
  let index = 0
  while (index < strArr.length) {
    if (strArr[index] === ' ' && strArr[index + 1] === ' ') {
      strArr.splice(index + 1, 1)
    } else {
      index++
    }
  }

  // 删除首位的空格
  if (strArr[0] == ' ') {
    strArr.splice(0, 1)
  }

  if (strArr[strArr.length - 1] == ' ') {
    strArr.splice(strArr.length - 1, 1)
  }
  console.log('strArr', strArr)
  // 2. 整体反转
  reverse(0, strArr.length - 1)
  // console.log('strArr', strArr)

  // 3.单词反转
  let start = 0
  for (let i = 0; i <= strArr.length; i++) {
    if (strArr[i] === ' ' || i === strArr.length) {
      // 翻转单词
      reverse(start, i - 1)
      start = i + 1
    }
  }
  // console.log('strArr', strArr.join(''))

  return strArr.join('')
}

// 用例
expect(reverseWords('the sky is blue')).toEqual('blue is sky the')
expect(reverseWords('  hello world  ')).toEqual('world hello')
expect(reverseWords('a good   example')).toEqual('example good a')
expect(reverseWords(' i am a  good boy   ')).toEqual('boy good a am i')
```
实现思路，考虑如下几种情况
> the sky is blue // 比较常规的
>   hello world   // 两端有超过一个空格的
> a good   example  // 中间有超过一个空格的
>  i am a  good boy   // 两端和中间都有超过一个空格的

根据“注意”中提到的要点，需要将字符串转换成常规的情况才是接近最终需求的，再就是依次调换单词的顺序，因此分三个步骤
step1: 将连续超过一个空格的情况处理为一个空格,将首位空格去除
step2: 整体反转字符串
step3: 按照由单词中间空格形成的间隔依次将单词的字符翻转正确
### 有效的括号-简单
> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
> 有效字符串需满足：
> 左括号必须用相同类型的右括号闭合。
> 左括号必须以正确的顺序闭合。
> 每个右括号都有一个对应的相同类型的左括号。
> 输入：s = "()" 输出：true
> 来源：[https://leetcode.cn/problems/valid-parentheses/](https://leetcode.cn/problems/valid-parentheses/)

#### 代码实现
```javascript
function isValid(s: string): boolean {
  if (s.length % 2 != 0) return false
  const map = new Map()
  map.set('}', '{')
  map.set(')', '(')
  map.set(']', '[')
  let arr: string[] = s.split('')
  let stack: string[] = []
  while (arr.length) {
    const cur: string = arr.shift() as string  
    if (['}', ')', ']'].includes(cur)) {
      const top = stack.pop()
      if (map.get(cur) != top) {
        return false
      }
    } else {
      stack.push(cur)
    }
  }
  return stack.length == 0
}

// 用例
expect(isValid('{[]}')).toEqual(true)
expect(isValid('([)]')).toEqual(false)
expect(isValid('()')).toEqual(true)
expect(isValid('()[]{}')).toEqual(true)
expect(isValid('(]')).toEqual(false)
```
实现思路
采用栈，当遇到前括号时，入栈，当下次(依次)遇到后括号的时候，再从栈依次取出前括号，看是否构成组成同一个括号的条件，不满足就false，满足就继续入栈push->出栈shift，所有括号都比配的情况下，最后栈一定是空的，即成立条件是length=0。
### ⭐️左旋字符串-简单
> 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。
> 输入: s = "abcdefg", k = 2 输出: "cdefgab"
> 来源：[https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof)

#### 代码实现
```javascript

function reverseLeftWords(s: string, n: number): string {
  let strArr = Array.from(s)

  const reverse = (left: number, right: number) => {
    while (left < right) {
      let tmp = strArr[right]
      strArr[right] = strArr[left]
      strArr[left] = tmp
      left++
      right--
    }
  }

  for (let i = 0; i <= strArr.length - 1; i++) {
    // 先翻转 0-n 区间的字符串
    if (i == n) {
      reverse(0, n - 1)
    }
    // 再翻转 n-结尾的字符串
    if (i == n) {
      reverse(n, strArr.length - 1)
    }
    // 最后反转整个字符串
    if (i == strArr.length - 1) {
      reverse(0, strArr.length - 1)
    }
  }

  console.log('strArr', strArr)

  return strArr.join('')
}
```
思路如图
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677840930762-6b9fd7a3-6683-4949-b7f3-246700ff4b68.png#averageHue=%23f6f5f5&clientId=u5fda37d9-3ab6-4&from=paste&height=383&id=u782e2e98&name=image.png&originHeight=868&originWidth=1360&originalType=binary&ratio=2&rotation=0&showTitle=false&size=77262&status=done&style=none&taskId=u44be51b4-4bee-44f4-93f0-83f3991578a&title=&width=600)
### ⭐️实现 strStr()-中等
> 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。
> 输入：haystack = "sadbutsad", needle = "sad"
> 输出：0
> 解释："sad" 在下标 0 和 6 处匹配。
> 第一个匹配项的下标是 0 ，所以返回 0 。
> 来源：[https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string)

#### 代码实现
```javascript
// 不减1的版本
function strStr2(haystack: string, needle: string): number {
  // step1 先找到needle的next数组
  // step2 遍历haystack,移动j指针不断缩小needle子串范围
  function getNext(str: string): number[] {
    let next: number[] = []
    let j: number = 0
    next[0] = j
    for (let i = 1, length = str.length; i < length; i++) {
      // 此处while的意义是基于当前位置一直往前找到最大前缀长度
      while (j > 0 && str[i] !== str[j]) {
        j = next[j - 1]
      }
      if (str[i] === str[j]) {
        j++
      }
      next[i] = j
    }
    return next
  }
  if (needle.length === 0) return 0
  let next: number[] = getNext(needle)
  let j: number = 0
  for (let i = 0, length = haystack.length; i < length; i++) {
    // 此处while的意义是基于当前位置一直往前找最大前缀的末尾，然后将j后移，缩小needle子串的匹配长度
    while (j > 0 && haystack[i] !== needle[j]) {
      j = next[j - 1]
    }
    if (haystack[i] === needle[j]) {
      // 这时候已经将needle找完了
      if (j === needle.length - 1) {
        return i - j
      }
      j++
    }
  }
  return -1
}
```
KMP算法
结合动画
以 haystack = aabaabaaf ，needle=aabaaf为例
获取needle的最长相等前后缀过程：
> 每次取相同长度的前后缀子串对比是否相同，存在就返回前后缀子串长度，不存在都是0.
a：前后缀都为0，长度为0；
aa：前后缀都为a，长度为1；
aab：前缀ab，后缀ab，不相同，再取前缀a，后缀b，不相同，长度为0；
aaba：前缀aab，后缀aba，不相同，再取前缀aa，后缀ba，不相同，再取前缀a，后缀a，相同，长度为1；
aabaa：前缀aaba，后缀abaa，不相同，再取前缀aab，后缀baa，不相同，再取前缀aa，后缀aa，相同，长度为2；
aabaaf：前缀aabaa，后缀abaaf，不相同，再取前缀aaba，后缀baaf，不相同，再取前缀aab，后缀aaf，不相同，再取前缀aa，后缀af，不相同，再取前缀a，后缀f，不相同，长度为0.

结合代码,不减1的版本
> while (j > 0 && str[i] !== str[j]) 的作用是，当j所处位置的元素与i位置不同时，一直往前找直到找到前缀，找不到就为0

```javascript
let next: number[] = []
let j: number = 0
next[0] = 0  // 第一个元素
for (let i = 1, length = str.length; i < length; i++) {
  // eg: aaba 的时候，依次取 aab&aba -> aa&ba -> a&a 此时a=a while循环结束 i=3,j=0 str[i] = str[j] 
  // 因此计算 next[3]=1
  while (j > 0 && str[i] !== str[j]) {
    j = next[j - 1] // j不断向前回退，直到j>0 && str[i] !== str[j] 不成立，while退出，得出j
  }
  if (str[i] === str[j]) {
    j++
  }
  next[i] = j
}
// next最后为 [0,1,0,1,2,0]
```
找到needle的最长相等前后缀next数组之后，遍历haystack，从0号元素开始
> 当i为0时，while不走，haystack[0] = needle[0]  j++  j变为1
> 当i为1时，while中!==条件不成立，不走，haystak[1]==needle[1]  j++ j变为2
> 当i为2时，while中!==条件不成立，不走，haystack[2] ==needle[2] j++ j变为3
> 当i为5时，while中!==条件成立，haystack[5]!==needle[5] j=next[5-1] 此时j回退， j变为2(红色的第一个b)，即此时只需要从红色的第一个b开始匹配haystack中的字符, haystack[5] = needle[2]  j++   j变为3 (关键转折点)
> 当i为6时，while中!==条件不成立，haystack[6]==needle[3]  j++ j变为4
> 当i为7时，while中!==条件不成立，haystack[7]==needle[4]  j++  j变为5
> 当i为8时，while中!==条件不成立，haystack[8]==needle[5] j++ j === needle.length - 1成立 return 3


```javascript
// haystack = aabaabaaf,needle=aabaaf
let j: number = 0 // j是needle的指针，最大值是needle.length-1 因此j==needle就应该返回计算的结果了
for (let i = 0, length = haystack.length; i < length; i++) {
  while (j > 0 && haystack[i] !== needle[j]) {
    j = next[j - 1]
  }
  if (haystack[i] === needle[j]) {
    // 这时候已经将needle找完了
    if (j === needle.length - 1) {
      return i - j
    }
    j++
  }
}
```
### 重复的子字符串
> 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。
> 输入: s = "abab" 输出: true 解释: 可由子串 "ab" 重复两次构成。
> 来源：[https://leetcode.cn/problems/repeated-substring-pattern/](https://leetcode.cn/problems/repeated-substring-pattern/)

#### 代码实现
```javascript
function repeatedSubstringPattern(s: string): boolean {
  // step1 先获取到前缀表
  // step2 经分析当满足s是有多个重复的子字符串构成的话，其满足 s长度 % (s长度 - next[最后一位]) === 0
  const getNext = (str: string): number[] => {
    let next: number[] = []
    let j: number = 0
    next[0] = 0
    for (let i = 1; i < str.length; i++) {
      while (j > 0 && str[i] !== str[j]) {
        j = next[j - 1]
      }
      if (str[i] === str[j]) {
        j++
      }
      next[i] = j
    }
    return next
  }

  const next = getNext(s)

  const n = s.length

  // console.log('next', getNext(s))
  if (next[n - 1] != 0 && n % (n - next[n - 1]) === 0) return true
  return false
}
```
如果一个字符串s是使用多个重复子串构成的，子串的长度为x，即s是由n个x构成的 s为n*x
因为字符s的最长相同前后缀的长度一定不包含s本身，因此相同前后缀长度必然是m*x，而且n-m=1,所以如果 nx % (n - m)x = 0，就可以判定有重复出现的子字符串。
以s=asdfasdfasdf为例,s.length为12，它的前缀表对应如下
next=[0,0,0,0,1,2,3,4,5,6,7,8]
数组长度为12，next[next.length-1] 为8
如果**s.length % (s.length-next[next.length-1])===0**，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。
### 删除字符串中的所有相邻重复项
> 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
> 在 S 上反复执行重复项删除操作，直到无法继续删除。
> 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
> 输入："abbaca"
> 输出："ca"
> 解释：
> 例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
> 来源：[https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string)

#### 代码实现
```javascript
function removeDuplicatesString(s: string): string {
  let stack: string[] = []
  let strArr: string[] = Array.from(s)

  let i = 0
  while (i < strArr.length) {
    let top = stack[stack.length - 1]
    if (strArr[i] == top) {
      stack.pop()
    } else {
      stack.push(strArr[i])
    }
    i++
  }
  console.log('stack', stack)

  return stack.join('')
}
```
### 同构字符串
> 给定两个字符串 s 和 t ，判断它们是否是同构的。
> 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
> 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。
> 输入：s = "egg", t = "add" 输出：true
> 输入：s = "foo", t = "bar" 输出：false
> 来源：[https://leetcode.cn/problems/isomorphic-strings](https://leetcode.cn/problems/isomorphic-strings)

```typescript

function isIsomorphic(s: string, t: string): boolean {
  // 对应字符串s、t的保存map
  let S = new Map()
  let T = new Map()
  for (let i = 0; i < s.length; i++) {
    // 当s、t出现了重复字符的话
    if (S.has(s[i]) || T.has(t[i])) {
      // 如果对于s和t在同一位置的字符，上一次出现的index不想等 就false
      if (S.get(s[i]) !== T.get(t[i])) return false
    }
    // 保存下当前位的字符和index
    S.set(s[i], i)
    T.set(t[i], i)
  }
  return true
}
```
### 查找公共字符
> 给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。
> 输入：words = ["bella","label","roller"] 输出：["e","l","l"]
> 输入：words = ["cool","lock","cook"] 输出：["c","o"]
> 来源：[https://leetcode.cn/problems/find-common-characters](https://leetcode.cn/problems/find-common-characters)

#### 代码实现 
```typescript

function commonChars(words: string[]): string[] {
  //q1. 以第一个字符串为基准 记录其每个字符出现的次数
  //q2. 再统计其他字符出现的次数  在这过程中取 出现次数的最小值
  //q3. 最后将字母表中出现次数大于0的字符输出
  const res: string[] = []
  const size = 26
  let firstHash = new Array(size)
  for (let i = 0; i < size; i++) {
    // 初始化 hash 数组
    firstHash[i] = 0
  }

  let a = 'a'.charCodeAt(0)
  let firstWord = words[0]
  for (let i = 0; i < firstWord.length; i++) {
    // 第 0 个单词的统计
    let idx = firstWord[i].charCodeAt(0)
    firstHash[idx - a] += 1
  }

  for (let i = 1; i < words.length; i++) {
    // 1-n 个单词统计
    let otherHash = new Array(size)
    for (let i = 0; i < size; i++) {
      // 初始化 hash 数组
      otherHash[i] = 0
    }

    for (let j = 0; j < words[i].length; j++) {
      let idx = words[i][j].charCodeAt(0)
      otherHash[idx - a] += 1
    }
    for (let i = 0; i < size; i++) {
      firstHash[i] = Math.min(firstHash[i], otherHash[i])
    }
  }

  //
  for (let i = 0; i < size; i++) {
    while (firstHash[i] > 0) {
      res.push(String.fromCharCode(i + a))
      firstHash[i]--
    }
  }
  return res
}
```
### ⭐️长按键入
> 你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。
> 你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。
> 输入：name = "alex", typed = "aaleex" 输出：true 解释：'alex' 中的 'a' 和 'e' 被长按。
> 输入：name = "saeed", typed = "ssaaedd"  输出：false  解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
> 来源：[https://leetcode.cn/problems/long-pressed-name](https://leetcode.cn/problems/long-pressed-name)

#### 代码实现1
```typescript
function isLongPressedName(name: string, typed: string): boolean {
  // Think for yourself for 5 minutes...
  // q1. 谁长谁短不确定，因此要处理name没处理完和typed没处理完的情况
  // q2. name没处理完肯定是false
  // q3. typed没处理完需要看后面的字符串是不是都是一样的，不一样就是false
  let slow = 0
  let fast = 0

  while (fast < typed.length && slow < name.length) {
    if (name[slow] === typed[fast]) {
      slow++
      fast++
    } else {
      if (fast === 0) return false
      // typed有重复项，往后移动
      while (fast < typed.length && typed[fast] === typed[fast - 1]) fast++
      if (name[slow] === typed[fast]) {
        slow++
        fast++
      } else {
        return false
      }
    }
  }

  // 说明name没有被匹配完,例如 name:"pyplrzzzzdsfa" type:"ppyypllr"
  if (slow < name.length) return false

  // 说明typed没有被匹配完,例如 name:"alex" type:"alexxrrrrssda"
  while (fast < typed.length) {
    if (typed[fast] === typed[fast - 1]) fast++
    else return false
  }

  return true
}

```
#### 代码实现2
```typescript
/**
 * 如果满足条件slow和fast都会走到头
 * @param name
 * @param typed
 * @returns
 */
function isLongPressedName(name: string, typed: string): boolean {
  let slow: number = 0
  let fast: number = 0

  while (slow < name.length && fast < typed.length) {
    if (name[slow] !== typed[fast]) return false
    slow++
    fast++

    // 当slow走到头，或者name的相邻两个字符不想等时(且name[slow]==typed[fast],因为上面不想等就false了)，
    // typed继续向前进
    if (slow === name.length || name[slow] !== name[slow - 1]) {
      while (fast < typed.length && typed[fast] === typed[fast - 1]) fast++
    }
  }

  return slow === name.length && fast === typed.length
}
```
### 重复的DNA序列
> DNA序列 由一系列核苷酸组成，缩写为 'A', 'C', 'G' 和 'T'.。
> 例如，"ACGAATTCCG" 是一个 DNA序列 。
> 在研究 DNA 时，识别 DNA 中的重复序列非常有用。
> 给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。
> 输入：s = "AAAAACCCCCCAAAAAGGGTTT" 输出：["AAAAACCCCC","CCCCCAAAAA"]
> 来源：[https://leetcode.cn/problems/repeated-dna-sequences](https://leetcode.cn/problems/repeated-dna-sequences)

#### 代码实现
```typescript
function findRepeatedDnaSequences(s: string): string[] {
  const L = 10
  const ans: string[] = []
  const hash = new Map()
  const n = s.length

  for (let i = 0; i <= n - L; i++) {
    // 记录以i开头i+L结尾的字符串出现的次数，当>=2说明出现不止一次，
    // 但为了不记录重复数据，只在===2时存储一次
    const sub = s.slice(i, i + L)
    hash.set(sub, (hash.get(sub) || 0) + 1)
    if (hash.get(sub) === 2) {
      ans.push(sub)
    }
  }

  return ans
}
```
思路分析,以上方法依次会记录
AAAAACCCCC
AAAACCCCCA
AAACCCCCAA
... 每个长度为10的子字符串出现的次数
### 最长回文字符串
> 给你一个字符串 s，找到 s 中最长的回文子串。
> 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。
> 输入：s = "babad" 输出："bab" 解释："aba" 同样是符合题意的答案。
> 来源：[https://leetcode.cn/problems/longest-palindromic-substring/](https://leetcode.cn/problems/longest-palindromic-substring/)

#### 代码实现
```typescript
/**
 * 动态规划法2
 * @param s
 */
function longestPalindrome(s: string): string {
  // q1. dp[i][j]表示i->j是否能构成回文
  // q2. 因为dp[i][j]依赖于i+1位置和j-1位置的状态值，因此考虑从下往上，从左往右遍历
  const n = s.length
  let maxStart = 0
  let maxLen = 0
  const dp = new Array(n).fill(false).map(() => new Array(n).fill(false))

  for (let i = n - 1; i >= 0; i--) {
    for (let j = i; j < n; j++) {
      // 当a或aa的时候 j - i <= 1
      // j-i==0 a
      // j-i==1 aa
      // 当s[i] === s[j]时，往中间收缩如果也想等那么i->j能构成回文
      if (s[i] === s[j] && (j - i <= 1 || dp[i + 1][j - 1])) {
        dp[i][j] = true
      }
      // 只要 dp[i][j] == true 成立，就表示子串 s[i..j] 是回文，此时记录回文长度和起始位置
      if (dp[i][j] && j - i + 1 > maxLen) {
        maxLen = j - i + 1 // 回文串长度
        maxStart = i // 起始位置
      }
    }
  }

  return s.substr(maxStart, maxLen)
}
```
#### 中心扩散法
```typescript
/**
 *  中心扩散法
 * @param s
 */
function longestPalindrome(s: string): string {
  // Think for yourself for 5 minutes...
  if (!s) return ''

  let left = 0
  let right = 0
  let len = 1 // 计数
  let maxStart = 0
  let maxLen = 0
  const n = s.length

  for (let i = 0; i < n; i++) {
    left = i - 1
    right = i + 1
    //向左扩散
    while (left >= 0 && s.charAt(left) === s.charAt(i)) {
      left-- // 还能继续往左
      len++
    }

    // 向右扩散
    while (right >= 0 && right < n && s.charAt(right) === s.charAt(i)) {
      right++ // 还能继续往右
      len++
    }

    // 向两边扩散
    while (left >= 0 && right < n && s.charAt(left) === s.charAt(right)) {
      len += 2
      left--
      right++
    }

    if (len > maxLen) {
      maxLen = len
      maxStart = left
    }
    // 每定位完一个位置重置一下计数
    len = 1
  }

  return s.substring(maxStart + 1, maxStart + maxLen + 1)
}
```
### 最长回文串-长度
> 给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。
> 在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。
> 输入:s = "abccccdd" 输出:7  解释: 我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
> 来源：[https://leetcode.cn/problems/longest-palindrome](https://leetcode.cn/problems/longest-palindrome)

#### 代码实现
```typescript

function longestPalindrome(s: string): number {
  // Think for yourself for 5 minutes...
  if (s.length == 0) return 0

  const hash = new Map()

  // 记录每个字符出现的次数
  for (let i = 0; i < s.length; i++) {
    let a = hash.get(s[i]) || 0
    hash.set(s[i], a + 1)
  }

  let count = 0

  let mark = 0 // 用来标记某个字母出现了奇数次情况
  for (let item of hash) {
    if (item[1] % 2 == 0) {
      count += item[1]
    } else {
      // 如果出现了奇数次，那也只能用n-1次
      count += item[1] > 1 ? item[1] - 1 : 0
      mark++
    }
  }
  // 如果出现了多个只出现奇数次的字符，对于回文而言只能用一个
  return mark ? count + 1 : count
}
```



## 👉总结归纳
### 梳理
字符串解题常用方法关键词：

1. 双指针：快慢指针，二分法
2. 反转法：局部反转，整体反转，确定反转区间
3. KMP：确定前缀表，指针位置由前缀表推出
4. 栈：记录已出现过的字符
5. 哈希表：记录字符出现的次数，出现的位置

解题要考虑的要点：

1. 时间复杂度，for循环是否能减少
2. 空间复杂度，是否可在原字符串上操作，或最少的建立新的空间

### 常用方法
#### charCodeAt
返回字符串中规定索引（下标）处字符的 Unicode。  
> 'a'.charCodeAt()  // 97
> 'A'.charCodeAt()  // 65

#### charAt()
方法返回字符串中指定索引（下标）处的字符。
> let text = "HELLO WORLD";
> let letter = text.charAt(0);   // H

#### String.fromCharCode()
将 Unicode 编码转为一个字符:
> String.fromCharCode(65)  // A
> String.fromCharCode(97)  // a

#### substr()
从起始索引号提取字符串中指定数目的字符。
> 'Hello World'.substr(0,4)   // 'Hell'
> 'Hello World'.substring(4)  //  'o World'

#### substring()
提取字符串中两个指定的索引号之间的字符。
> 'Hello World'.substring(4)  // 'o World'
> 'Hello World'.substring(0,4)  // 'Hell'


### 导图
![](https://cdn.nlark.com/yuque/0/2023/jpeg/1553840/1678510958700-1f37ff03-f6e8-4654-8166-6aa2f73aef0c.jpeg)
## 资料

- 
- 
- 

[点击查看【bilibili】](https://player.bilibili.com/player.html?bvid=BV1AY4y157yL)
