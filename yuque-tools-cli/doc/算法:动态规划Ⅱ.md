# 算法:动态规划Ⅱ 
## ⭐️动态规划五部曲
1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组
## 例题
### 爬楼梯
> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
> 输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶
来源：[https://leetcode.cn/problems/climbing-stairs/](https://leetcode.cn/problems/climbing-stairs/)

#### 代码实现 
```typescript
/**
* dp[i]的含义是：爬到i级楼梯可以有的方法数
* 那对于n级楼梯他要到达最后一级就是要确定n-1级楼梯的方法数
*/
function climbStairs(n: number): number {
  // Think for yourself for 5 minutes...
  // q1.一次可以爬1或2
  // 1 -> 1   种
  // 2 -> 1 1 , 2  2种
  // 3 -> 1 1 1, 1 2, 2 1 3种
  // 4 -> 1 1 1 1, 1 1 2 , 1 2 1, 2 1 1, 2 2  5种
  // 在到达第n层的上一步，我们只有两个选择，走一步，或者走两步。
  // 如果是走一步，我们需要先通过 f(n-1)种方式到达 n-1 层
  // 如果是走两步， 我们需要通过 f(n-2)种方式到达第 n - 2 层
  // 所以综上有 f(n) = f(n-2) + f(n-1)
  // dp[i] 表示爬上i级阶梯的方法数

  const dp: number[] = [1, 2]
  for (let i = 2; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }

  return dp[n - 1]
}
```
### 使用最小花费爬楼梯
> 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上**爬一个或者两个台阶。**
> 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。
> 输入：cost = [10,15,20]  输出：15
> 解释：你将从下标为 1 的台阶开始。
> - 支付 15 ，向上爬两个台阶，到达楼梯顶部。
> 总花费为 15 。
> 来源：[https://leetcode.cn/problems/min-cost-climbing-stairs](https://leetcode.cn/problems/min-cost-climbing-stairs)

#### 代码实现
```typescript
function minCostClimbingStairs(cost: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. 最低花费
  // q2. 爬一个或两个台阶
  // dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
  const dp: number[] = []
  dp[0] = 0
  dp[1] = 0

  for (let i = 2; i <= cost.length; i++) {
    const way1 = dp[i - 1] + cost[i - 1]
    const way2 = dp[i - 2] + cost[i - 2]
    dp[i] = Math.min(way1, way2)
  }
  return dp[cost.length]
}
```
思路分析，考虑既然一次可以爬1或2阶，dp[i] 既可以是di[i-1]爬一步，也可以是dp[i-1]爬两步，因此需要比较dp[i-1]和dp[i-2]哪一种更划算，因此有dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]) ，而dp[0]和dp[1]都是不需要有花费的，因此可以初始化为0。
因为需要求的dp[i]指的是从i位置**“爬过去”**所需要的花费，dp[0]认为假设前面有一位**-1，**for循环i的起始位是2，其实算的是从cost[1]**“爬过去”**的花费，对于结果而言就应该算的cost.length位置**“爬过去”**的花费，因此有i<-cost.length终止条件和dp[cost.length]
### 斐波那契数
> F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1
> 来源：[https://leetcode.cn/problems/fibonacci-number/](https://leetcode.cn/problems/fibonacci-number/)

#### 代码实现 
```typescript
/**
 * 动态规划版
 * @param n
 */
function fib(n: number): number {
  // Think for yourself for 5 minutes...
  if (n <= 1) return n

  const dp: number[] = [0, 1]

  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }

  return dp[n]
}

/**
 * 普通递归版
 * @param n
 */
function fib(n: number): number {
  return n <= 1 ? n : fib(n - 1) + fib(n - 2)
}
/**
 * 记忆法递归
 * @param n
 */
function fib(n: number): number {
  const memo = [0, 1]
  const dfs = (n: number) => {
    if (memo[n] != null) {
      return memo[n]
    }
    if (memo[n]) return memo[n]
    memo[n] = dfs(n - 1) + dfs(n - 2)
    return memo[n]
  }
  return dfs(n)
}

```
### 不同路径
> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
> 问总共有多少条不同的路径？
> 输入：m = 3, n = 2   输出：3
> 解释：
> 从左上角开始，总共有 3 条路径可以到达右下角。
> 1. 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向下
> 来源：[https://leetcode.cn/problems/unique-paths](https://leetcode.cn/problems/unique-paths)

#### 代码实现
```typescript
/**
* dp[i][j] 表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。
*/

function uniquePaths(m: number, n: number): number {
  // Think for yourself for 5 minutes...
  // q1. 只能向右和向下
  // q2. dp[i-1][j] 表示从[0,0] 到[i-1,j] 的路径条数
  // dp[i][j-1] 表示从[0,0] 到[i,j-1] 的路径条数
  // 因此 dp[i][j] = dp[i-1][j] + dp[i][j-1]
  // dp[i][j] 表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。
  const dp: number[][] = new Array(m).fill(0).map(() => new Array(n).fill(0))

  // 也可以在上面全部初始化为1可以省略下面两个步骤

  // 第一行的路径
  for (let i = 0; i < m; i++) {
    dp[i][0] = 1
  }

  // 第一列的路径
  for (let j = 0; j < n; j++) {
    dp[0][j] = 1
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    }
  }

  return dp[m - 1][n - 1]
}
```
### 不同路径 II
> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。
> 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
> 网格中的障碍物和空位置分别用 1 和 0 来表示
> 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]  输出：2
> 解释：3x3 网格的正中间有一个障碍物。
> 从左上角到右下角一共有 2 条不同的路径：
> 1. 向右 -> 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右 -> 向右
> 来源：[https://leetcode.cn/problems/unique-paths-ii](https://leetcode.cn/problems/unique-paths-ii)

#### 代码实现
```typescript
function uniquePathsWithObstacles(obstacleGrid: number[][]): number {
  // Think for yourself for 5 minutes...
  // q1. 有障碍物 1表示有障碍物
  // 当obstacleGrid[i][j] === 0的时候再执行dp[i][j]的计算

  const m: number = obstacleGrid.length
  const n: number = obstacleGrid[0].length

  if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) return 0

  const dp: number[][] = new Array(m).fill(0).map(() => new Array(n).fill(0))
  for (let i = 0; i < m && obstacleGrid[i][0] === 0; i++) {
    dp[i][0] = 1
  }

  for (let j = 0; j < n && obstacleGrid[0][j] === 0; j++) {
    dp[0][j] = 1
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      if (obstacleGrid[i][j] === 0) {
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
      }
    }
  }

  return dp[m - 1][n - 1]
}
```
### 整数拆分
> 给定一个正整数 n ，将其拆分为 k 个 **正整数** 的和（ k >= 2 ），并使这些整数的乘积最大化。
> 返回 _你可以获得的最大乘积_ 。
> 输入: n = 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。

PS:[算法:动态规划Ⅰ--切绳子](https://www.yuque.com/vannvan/tools/zz28ghdevp2n9y3v#ABygz)
#### 代码实现
```typescript
/**
* dp[i]的含义是：整数i可以拆分的正整数的最大乘积
*/
function integerBreak(n: number): number {
  // Think for yourself for 5 minutes...
  // 拆分成k个整数 k>=2
  // 2 =>  1*1 1
  // 3 =>  1*2  1*1*1  2
  // 4 =>  1*2*1 1*1*1*1   4
  // 5 =>  1*1*1*1*1 1*2*2 1*1*1*2 2*3  6
  // 6 =>  3*3 9
  // 考虑一个数i可以被拆分为 j * (i - j)
  // dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
  // j * (i - j) 的含义是把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。

  const dp: number[] = Array(n + 1).fill(0)

  dp[2] = 1

  for (let i = 3; i <= n; i++) {
    for (let j = 1; j <= i / 2; j++) {
      dp[i] = Math.max(dp[i], dp[i - j] * j, (i - j) * j)
    }
  }

  return dp[n]
}
```
### ⭐️分割等和子集
> 给你一个 **只包含正整数 **的 **非空 **数组 nums 。请你判断是否可以将这个数组分割成**两个子集，使得两个子集的元素和相等。**
> 输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。
> 来源：[https://leetcode.cn/problems/partition-equal-subset-sum/](https://leetcode.cn/problems/partition-equal-subset-sum/)

PS: [背包问题2](https://www.yuque.com/vannvan/tools/zz28ghdevp2n9y3v#AhtF8)
#### 代码实现
```typescript
function canPartition(nums: number[]): boolean {
  const sum: number = nums.reduce((prev, curr) => prev + curr)

  if (sum % 2 === 1) return false

  const bagSize: number = sum / 2
  const weightArr: number[] = nums
  const valueArr: number[] = nums

  const goodsNum: number = weightArr.length

  const dp: number[][] = new Array(goodsNum).fill(0).map((_) => new Array(bagSize + 1).fill(0))

  for (let i = weightArr[0]; i <= bagSize; i++) {
    dp[0][i] = valueArr[0]
  }


  for (let i = 1; i < goodsNum; i++) {
    for (let j = 0; j <= bagSize; j++) {
      // 当目前j背包容量不够
      if (j < weightArr[i]) {
        dp[i][j] = dp[i - 1][j]
      } else {
        const w = j - weightArr[i] // 容量为j - weightArr[i]的时候不放物品i的最大价值
        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][w] + valueArr[i])
      }
    }
  }
  return dp[goodsNum - 1][bagSize] === bagSize
}
```
思路分析
考虑既然需要氛围两个子集且子集的和相等，那么一定存在一个子集的和未总sum的一半，我们需要求解是否存在能构成满足和为sum/2的子数组。
问题可以转换为，又一个为sum/2容量的背包，有一组价值为num[i]的物品，我们需要把sum/2装满应该怎样使用nums[i]中的数。
#### 优化版
```javascript
function canPartition(nums: number[]): boolean {
  // Think for yourself for 5 minutes...
  // q1. 分割成两个数组，两个数组的和相等，那两个数组的各自的和肯定是原数组总和的一半
  // 那只需要确定原数组中存在能够构成sum/2的子集就可以
  // q2. 如果sum是奇数 不可能分为两个总和相等的数组
  // q3. nums的长度必须大于2
  // q4. 如果最大元素大于sum/2 也不可能划分为两个数组
  //
  const sum: number = nums.reduce((pre, cur) => pre + cur)
  if (sum % 2 === 1) return false
  
  const bagSize: number = sum / 2
  const goodsNum: number = nums.length
  
  const dp: number[] = new Array(bagSize + 1).fill(0)
  
  for (let i = 0; i < goodsNum; i++) {
    for (let j = bagSize; j >= nums[i]; j--) { // 倒序
      const w = j - nums[i] // 容量为j-nums[i]时，不放num[i]的最大值
      dp[j] = Math.max(dp[j], dp[w] + nums[i])
    }
  }
  return dp[bagSize] === bagSize
}
```
思路分析，因为在dp计算的过程中当前dp[i][j]只与上一行的dp值有关，且需要注意的是第二层的循环我们需**要从大到小计算**，因为如果我们从小到大更新 dp 值，那么在计算 dp[j] 值的时候，dp[j-num[i]] 已经是被更新过的状态，不再是上一行的 dp值。

### ⭐️最后一块石头的重量II
> 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。
> 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
> 如果 x == y，那么两块石头都会被完全粉碎；
> 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
> 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。
> 来源：[https://leetcode.cn/problems/last-stone-weight-ii](https://leetcode.cn/problems/last-stone-weight-ii)

#### 代码实现
```javascript

function lastStoneWeightII(stones: number[]): number {
  // Think for yourself for 5 minutes...
  // q1.重量stones[i] 价值stones[i]
  // dp[j] 就是重量为j时的最多可以装的重量

  const n: number = stones.length

  // 套用背包
  const weights: number[] = stones
  const values: number[] = stones

  const sum: number = stones.reduce((prev, curr) => prev + curr)

  const target: number = Math.floor(sum / 2)
  const dp: number[] = Array(target + 1).fill(0)

  for (let i = 0; i < n; i++) {
    for (let j = target; j >= stones[i]; j--) {
      const w = j - stones[i]
      dp[j] = Math.max(dp[j], dp[w] + stones[i])
    }
  }

  // console.log(dp)
  // sum - dp[target] 是一堆 dp[target]是另一堆
  // 剩下的最小石头重量就是 (sum - dp[target]) - dp[target]
  return sum - dp[target] - dp[target]
}
```
### 打家劫舍
> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻**的房屋在同一晚上被小偷闯入，系统会自动报警。
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
> 输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。
> 来源：[https://leetcode.cn/problems/house-robber](https://leetcode.cn/problems/house-robber)

#### 代码实现
```javascript
/**
* dp[i]的含义是：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。
*/
function rob(nums: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. 不能偷相邻的
  // q2. dp[i] 表示包括第i间房子 可以偷到的最大金额
  // 考虑要么偷要么不偷
  // 偷的话 dp[i] = dp[i-2] + nums[i]
  // 不偷的话 d[i] = dp[i-1]
  // 因此 dp[i] = max(dp[i-1],dp[i-2]+nums[i])

  const dp: number[] = Array(nums.length + 1).fill(0)

  dp[0] = nums[0]
  dp[1] = Math.max(nums[0], nums[1])

  for (let i = 2; i < nums.length; i++) {
    dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])
  }

  return dp[nums.length - 1]
}
```
### 打家劫舍 II
> 基于上一题条件，这个地方所有的房屋都 **围成一圈** 
> 输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
> 来源：[https://leetcode.cn/problems/house-robber-ii/](https://leetcode.cn/problems/house-robber-ii/)

#### 代码实现
```javascript
function rob(nums: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. 因为房屋是一圈，对于首尾可能存在影响常规的按顺序递推结果的情况，
  // 因此需要把去头和去尾的情况分别算出来，比较两者的大小
  if (nums.length === 1) return nums[0]
  if (nums.length === 0) return 0

  const robRange = (nums: number[], start: number, end: number) => {
    if (end == start) return nums[start]
    const dp: number[] = Array(nums.length).fill(0)

    dp[start] = nums[start]
    dp[start + 1] = Math.max(nums[start], nums[start + 1])

    for (let i = start + 2; i <= end; i++) {
      dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])
    }

    return dp[end]
  }

  const result1 = robRange(nums, 0, nums.length - 2) // 去尾
  const result2 = robRange(nums, 1, nums.length - 1) // 去头

  return Math.max(result1, result2)
}
```
### 买卖股票最佳时机
> 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
> 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
> 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
> 输入：[7,1,5,3,6,4]  输出：5
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
> 来源：[https://leetcode.cn/problems/best-time-to-buy-and-sell-stock](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock)

#### 动态规划版
```javascript
function maxProfit(prices: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. 考虑有需要有两个动作  买入和卖出，因此对于i位置的需要维护两个“记录”
  // dp[i][0] 表示第i天 持有的股票现金
  // dp[i][1] 表示第i天 不持有股票现金所得最多的现金
  // 那么对于dp[i][0] 两种情况可以选择 他前i-1天就持有的dp[i-1][0]  和 他第i天买入当天的股票剩余的现金，-prices[i]
  // 因此dp[i][0] = max(dp[i-1][0],-prices[i])
  // 对于dp[i][1] 也有两种情况 保持现状,即前一天不持有股票所得的现金 dp[i-1][1] 和 卖出股票 +prices[i] + dp[i-1][0]
  // 因此dp[i][1] = max(dp[i-1][1],prices[i]+dp[i-1][0])

  const n: number = prices.length
  if (n === 0) return 0

  const dp = Array(prices.length).fill([0, 0])
  dp[0] = [-prices[0], 0]

  for (let i = 1; i < n; i++) {
    dp[i][0] = Math.max(dp[i - 1][0], -prices[i])
    dp[i][1] = Math.max(dp[i - 1][1], prices[i] + dp[i - 1][0])
  }

  return dp[n - 1][1]
}
```
#### 贪心版
```javascript
function maxProfit(prices: number[]): number {
// let max = 0
//   let n: number = prices.length
//   for (let i = 0; i < n; i++) {
//     for (let k = i + 1; k < n; k++) {
//       let inc = prices[k] - prices[i]
//       if (inc > 0 && inc > max) {
//         max = inc
//       }
//     }
//   }
//   return max
let minprice = Number.MAX_SAFE_INTEGER
  let maxprofit = 0
  for (let i = 0; i < prices.length; i++) {
    if (prices[i] < minprice) {
      minprice = prices[i] // 假设这一天就是最低值
    } else if (prices[i] - minprice > maxprofit) {
      maxprofit = prices[i] - minprice
    }
  }

  return maxprofit
};
```
### ⭐️买卖股票最佳时机II
> 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
> 返回 你能获得的 最大 利润 。
> 输入：prices = [7,1,5,3,6,4] 输出：7
> 来源：[https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii)

PS:[贪心版本](https://www.yuque.com/vannvan/tools/xo27q1qxwlvh34q1#TvDa0)
#### 代码实现
```javascript
/**
 * 动态规划版本
 * @param prices
 */
function maxProfit(prices: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. 能获得的最大利润
  // q2. 可以买卖多次
  // dp[1][0] 表示i天持有股票所得现金
  // dp[i][1] 表示i天不持有股票所得最多现金
  // 对于dp[i][0] 有两种情况 a.i-1天就持有，保持现状dp[i-1][0] b. i天买入股票，dp[i-1][1] - prices[i]
  // 对于dp[i][1] 有两种情况 b. i-1天不持有，保持现状dp[i-1][1] b. i天卖出股票，dp[i-1][0] + prices[i]
  const n: number = prices.length
  if (n === 0) return 0

  const dp: number[][] = Array(n).fill([0, 0])
  dp[0] = [-prices[0], 0]

  for (let i = 1; i < n; i++) {
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i])
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i])
  }

  return dp[n - 1][1]
}
```
### 买卖股票的最佳时机III
> 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
> 设计一个算法来计算你所能获取的最大利润。你最多可以完成** 两笔 交易。**
> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
> 输入：prices = [3,3,5,0,0,3,1,4]   输出：6
> 来源：[https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii)

#### 代码实现
```javascript
function maxProfit(prices: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. 考虑最多可以完成两笔交易
  // q2. 一天一共有五种状态
  // 0.没有操作 （其实我们也可以不设置这个状态）
  // 1.第一次持有股票
  // 2.第一次不持有股票
  // 3.第二次持有股票
  // 4.第二次不持有股票
  // 对于dp[i][1] 有两种情况 a. 买入 dp[i][1] = dp[i-1][0] - prices[i]  b. 无操作，就是前一天的状态 dp[i-1][1] = dp[i-1][1]
  // 对于dp[i][2] 有两种情况 a. 卖出 dp[i][2] = dp[i-1][1] + prices[1] b. 无操作，沿用前一天 dp[i][2] = dp[i-1][2]
  // dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
  // dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);

  const n: number = prices.length
  const dp: number[][] = Array(n).fill([0, 0])
  dp[0] = [0, -prices[0], 0, -prices[0], 0]

  for (let i = 1; i < n; i++) {
    dp[i][0] = dp[i - 1][0]
    dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1])
    dp[i][2] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][2])
    dp[i][3] = Math.max(dp[i - 1][2] - prices[i], dp[i - 1][3])
    dp[i][4] = Math.max(dp[i - 1][3] + prices[i], dp[i - 1][4])
  }
  return dp[n - 1][4]
}
```
### 买卖股票的最佳时机IV
> 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。
> 设计一个算法来计算你所能获取的最大利润。你最多可以**完成 k 笔交易**。
> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
> 来源：[https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv)

#### 代码实现
```javascript
function maxProfit(k: number, prices: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. 考虑可以完成k笔交易
  // q2. dp[i][j] 表示第i天剩下的最大现金
  // q3. 沿用最佳时机III的思路 dp[i][0] 不操作 dp[i][1] 买入的状态 dp[i][2] 卖出的状态 ...
  // q4. 因此采用偶数位表示卖出，奇数位表示买入
  // 因此有 dp[i][j+1] = max(dp[i-1][j+1],dp[i-1][j]-prices[i])
  // dp[i][j+2] = max(dp[i-1][j+2],dp[i-1][j+1]+prices[i])
  const n: number = prices.length
  if (n === 0) return 0

  const dp: number[][] = Array.from(Array(prices.length), () => Array(2 * k + 1).fill(0))

  // 沿用最佳时机III得到的规律，奇数位(不是索引位)都初始化为-prices[0]
  for (let j = 1; j < 2 * k; j += 2) {
    dp[0][j] = -prices[0]
  }

  for (let i = 1; i < n; i++) {
    for (let j = 0; j < 2 * k - 1; j += 2) {
      dp[i][j + 1] = Math.max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i])
      dp[i][j + 2] = Math.max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i])
    }
  }

  return dp[n - 1][2 * k]
}
```
### 最佳时机含手续费
> 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。
> 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8
> 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
> 来源：[https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

#### 代码实现
```javascript
function maxProfit(prices: number[], fee: number): number {
  // Think for yourself for 5 minutes...
  // dp[i][0] 表示第i天持有股票的现金 a. 保持现状 dp[i-1][0] b. 买入 dp[i-1][1] - prices[i]
  // dp[i][1] 表示第i天卖出股票的现金 a. 保持现状 dp[i-1][1] b. 卖出 dp[i-1][0] + prices[i] - fee
  // 最后结果比较第i天选择持有还是卖出 所剩余的现金

  const n: number = prices.length
  if (n === 0) return 0

  const dp: number[][] = Array(n).fill([0, 0])

  dp[0][0] -= prices[0]

  for (let i = 1; i < n; i++) {
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i])
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee)
  }

  return Math.max(dp[n - 1][0], dp[n - 1][1])
}
```
### 最佳时机含冷冻期
> 给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。
> 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
> 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
> 输入: prices = [1,2,3,0,2] 输出: 3  解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
> 来源：[https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown)

#### 代码实现
```javascript

function maxProfit(prices: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. 考虑卖出之后第二天为冷冻期
  // q2. 确定股票状态  买入 保持 卖出 冷冻中
  // 交易状态为 [买入, 卖出, 冷冻期, 买入, 卖出, 冷冻]
  // dp[i][0] 表示买入 可选 a. 持有  dp[i-1][0] b1. 今天买入但前一天是冷冻期 dp[i - 1][3] - prices[i]  b2. 前一天是保持卖出状态dp[i-1][1] - prices[i]
  // dp[i][1] 达到保持卖出 a. 保持状态2 dp[i-1][1]  b. 前一天是冷冻期 dp[i-1][3]
  // dp[i][2] 确定卖出 dp[i-1][0] + prices[i]
  // dp[i][3] 冷冻 dp[i-1][2]
  // 对于结果需要求 后三种状态的最大值

  const n: number = prices.length
  
  if (n === 0) return 0

  const dp: number[][] = Array.from(Array(prices.length), () => Array(4).fill(0))

  dp[0][0] -= prices[0]

  for (let i = 1; i < n; i++) {
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i])
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][3])
    dp[i][2] = Math.max(dp[i - 1][0] + prices[i])
    dp[i][3] = Math.max(dp[i - 1][2])
  }

  return Math.max(dp[n - 1][1], dp[n - 1][2], dp[n - 1][3])
}
```

## 总结
动态规划算法解题套路大概可以概括如下：

1.  理解问题：理解问题的关键是要找出问题中的重复子问题，这是动态规划算法的核心。 
2.  定义状态：将问题的解定义成状态，并且想出如何表示这个状态。一般来说，状态是由一些变量组成的。 
3.  设计转移方程：针对每个状态，想出有哪些转移方式。状态的转移由一些确定的操作完成，这些操作可以表示为一个简单的公式或者递归式。 
4.  初始化：针对状态转移方程，设计一个符合条件的初始化状态。 
5.  解决问题：得到状态转移方程和初始化状态后，就可以使用动态规划算法解决问题了。 
6.  最优解：动态规划算法往往通过求解一系列状态，然后在这些状态中寻找最优解。一般来说，最终状态就是最优解，但是有些问题，需要在最终状态之外进行额外的计算 
## 导图
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679204220095-13a7af74-03ef-4a02-8f35-a812718ced0e.png#averageHue=%23ebf8ed&clientId=u34ce0f28-6c5d-4&from=paste&height=1121&id=uca9aec24&name=image.png&originHeight=2242&originWidth=1968&originalType=binary&ratio=2&rotation=0&showTitle=false&size=2395315&status=done&style=none&taskId=ubc34ef9c-fd86-405b-9fb0-309423ea4ac&title=&width=984)
## 
## 
## 资料


