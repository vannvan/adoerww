# 算法:位运算 
## 概念
位运算符将它的操作数视为 32 位元的二进制串（0 和 1 组成）而非十进制八进制或十六进制数。例如：十进制数字 18 用二进制表示为 10010，位运算符就是在这个二进制表示上执行运算，但是返回结果是标准的 JavaScript 数值。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679707069449-d4f1be01-7981-4080-a4d6-b904bd5b2bef.png#averageHue=%23eaeaea&clientId=u8231e546-07a9-4&from=paste&height=81&id=u0e4cacd9&name=image.png&originHeight=74&originWidth=551&originalType=binary&ratio=2&rotation=0&showTitle=false&size=5214&status=done&style=none&taskId=ucafdb430-a807-46cd-b3ea-be653567dfe&title=&width=600)

| Operator | Usage | Description |
| --- | --- | --- |
| 按位与 [AND(en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#bitwise_and) | a & b | 在 a,b 的位表示中，每一个对应的位都为 1 则返回 1，否则返回 0. |
| 按位或 [OR(en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#bitwise_or) | a &#124; b | 在 a,b 的位表示中，每一个对应的位，只要有一个为 1 则返回 1，否则返回 0. |
| 按位异或 [XOR(en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#bitwise_xor) | a ^ b | 在 a,b 的位表示中，每一个对应的位，两个不相同则返回 1，相同则返回 0. |
| 按位非 [NOT(en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#bitwise_not) | ~ a | 反转被操作数的位。 |
| 左移 [shift(en-US)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#left_shift) | a << b | 将 a 的二进制串向左移动 b 位，右边移入 0. |
| 算术右移 | a >> b | 把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位。(译注：算术右移左边空出的位是根据最高位是 0 和 1 来进行填充的) |
| 无符号右移 (左边空出位用 0 填充) | a >>> b | 把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位，并把左边空出的位都填充为 0 |

## 实例
ps:二进制和十进制互转
> parseInt(26,10).toString(2)  //  '11010'
> parseInt('11010',2)  //  '26'

以下运算均是4位无符号整数进行运算

| 操作 | 结果 | 等同于 | 结果 | 过程 |
| --- | --- | --- | --- | --- |
| 5 & 1 | 1 | 0101 &
0001 | 0001 | 都为1->1，否则0 |
| 5 &#124; 1 | 5 | 0101 &#124;
0001 | 0101 | 一个为1->1，否则0 |
| 5 ^ 1 | 4 | 0101 ^
0001 | 100 | 对应位不同->1，相同0 |
| 7 ^ 9 | 14 | 0111 ^
1001 | 1110 | 对应位不同->1，相同0 |
| ~5  | 10 js是-6 | ~0101 | 1010 | 反转所有位 |
| 5 << 1 | 10 | 0101 << 1 | 1010 | 向左移动1位，右边移入1个0 |
| 7<<2 | 28 | 0111 << 2 | 11100 | 向左移动2位，右边一如2个0 |
| 5>>1 | 2 | 0101>>1 | 0010 | 向右移动1位，左边高位是0，用0填充 |
| 5>>>1 | 2 | 0101>>>1 | 0010 |  |
| 7>>>1 | 3 | 0111>>>1 | 0011 | 向右移动1位，左边空位为0 |
| 14>>>2 | 3 | 0111>>>2 | 0011 | 向右移动2位，左边空位为0 |

### 特别说明
JavaScript 使用 32 位按位运算数
JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。
在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。
执行按位操作后，结果将转换回 64 位 JavaScript 数。
上面的例子使用 4 位无符号二进制数。所以 ~ 5 返回 10。
由于 JavaScript 使用 32 位有符号整数，JavaScript 将返回 -6。
00000000000000000000000000000101 (5)
11111111111111111111111111111010 (~5 = -6)
有符号整数使用最左边的位作为减号。
## 技巧
> <<1 是×2的意思
>>1 是÷2的意思，但是位运算不能处理小数。
>>0 可以去掉小数点转换成整数
> x&1 判断奇偶性
> 12.1 | 0// 12  浮点数向下取整
> 12.9 | 0// 12

```javascript
// 左移一位相当于在原数字基础上乘2，利用这一特点，实现2的n次方:
// 实现2的n次方
function power(n) {
    return 1 << n
}
power(3) // 8
```
```javascript
// 右移一位相当于在原数字基础上除2
64 >> 1 // 32 
```
```javascript
// 可以使用无符号右移来判断一个数的正负
function isPos(n) {
    return (n === (n >>> 0)) ? true : false;
}

isPos(-1); // false
isPos(1); // true
```
## 进制转换
### 十->二
```javascript
// 除二取余
function toBinary(value) {
    if (isNaN(Number(value))) {
        throw `${value} is not a number` 
    }
    let bits = []
    while (value >= 1) {
        bits.unshift(value % 2)
        value = Math.floor(value / 2)
    }
    return bits.join('')
}
```
### 二->十
```javascript
// 取幂相加
function toDecimal(value) {
    let bits = value.toString().split('')
    let res = 0
    while (bits.length) {
        let bit = bits.shift()
        if (bit == 1) {
            // ** 为幂运算符，如：2**3 为 8
            res += 2 ** bits.length
        }
    }
    return res
}
```
## 例题
### 二进制求和
> 给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。
> 输入:a = "11", b = "1" 输出："100"
> 来源：[https://leetcode.cn/problems/add-binary/](https://leetcode.cn/problems/add-binary/)

#### 代码实现1
```javascript
// 此方法不能应对parseInt在将很大的二进制转十进制时，溢出的情况
function addBinary(a: string, b: string): string {

  // x保存结果，y保存进位,其实也可以直接用ab
  let x = parseInt(a, 2)
  let y = parseInt(b, 2)
  while (y) {
    let carry = x & y // 依次是1 2 0
    x = x ^ y // 依次是 2 0 4  // 4是最后的结果
    y = carry << 1 // 2 4 0
  }

  return x.toString(2) 
}

```
过程分析，以"11","1"为例，结果是"100" 对应十进制4
开始时，x=3 y=1
第一轮: carry=x&y 相当于 0011 & 0001  carry = "0001" 即 1; x=x^y  相当于 0011 ^0001 , x="0010" 即2；y=carry<<1 相当于"0001"<<1 y="0010" 即2
#### 代码实现2
```javascript
var addBinary = function (a, b) {
  let [num1, num2] = a.length > b.length ? [a, b] : [b, a]
  let result = ''
  let carry = 0
  for (let i = 0; i < num1.length; i++) {
    let empty1 = num1[num1.length - i - 1]
    let empty2 = num2[num2.length - i - 1] || 0
    if (+empty1 + +empty2 === 2) {
      result = carry + result
      carry = 1
    } else if (+empty1 + +empty2 === 1) {
      if (carry === 1) {
        result = '0' + result
      } else {
        result = '1' + result
      }
    } else if (+empty1 + +empty2 === 0) {
      result = carry + result
      carry = 0
    }
  }

  return carry ? carry + result : result
}
```
### 只出现一次的数字
> 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
> 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
> 输入：nums = [2,2,1] 输出：1
> 来源：[https://leetcode.cn/problems/single-number](https://leetcode.cn/problems/single-number)

#### 代码实现1
```javascript
var singleNumber = function(nums) {
  return nums.reduce((value1,value2) => value1 ^ value2);
};
```
相同的数字异或为0：因为相同的数字每一位都是相同的，所以异或值都为0，结果自然为0。
0异或任何数等于数字本身：因为0异或1为1，0异或0为0，结果都为自身
所以我们可以通过**对数组进行异或求和**，最后的结果就是只出现了一次的数字（相同的数字都异或成了0）
#### 代码实现2
```javascript
function singleNumber(nums: number[]): number {
  // Think for yourself for 5 minutes...

  let single: number = 0
  for (const val of nums) {
    single ^= val
  }

  return single
}
```
过程分析
比如对于[2,2,1,3,3,3]

| 原数字 | 2 | 2 | 1 | 3 | 3 | 3 |
| --- | --- | --- | --- | --- | --- | --- |
| 异或后 | 0 | 0 | 1 | 0 | 0 | 0 |

### 只出现一次的数字 II
> 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
> 你必须设计并实现线性时间复杂度的算法且不使用额外空间来解决此问题。
> 输入：nums = [2,2,3,2] 输出：3
> 来源：[https://leetcode.cn/problems/single-number-ii](https://leetcode.cn/problems/single-number-ii)

#### 代码实现 
```javascript
function singleNumber(nums: number[]): number {
  // Think for yourself for 5 minutes...
  let result = 0
  for (let i = 0; i < 32; i++) {
    let sum = 0
    for (let j = 0; j < nums.length; j++) {
      let empty = (nums[j] >> i) & 1
      sum += empty
    }
    if (sum % 3 !== 0) {
      result |= 1 << i
    }
  }
  return result
}
```
### 丢失的数字
> 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
> 输入：nums = [3,0,1]   输出：2
> 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
> 来源：[https://leetcode.cn/problems/missing-number](https://leetcode.cn/problems/missing-number)

#### 代码实现1
```javascript
function missingNumber(nums: number[]): number {
 const n: number = nums.length
  let total: number = Math.floor((n * (n + 1)) / 2) // 这个范围数字的和
  let arrSum = 0
  for (let i = 0; i < n; i++) {
    arrSum += nums[i] // 已有数字的和
  }

  return total - arrSum
};
```
#### 代码实现2
```javascript
var missingNumber = function(nums) {
    const n = nums.length;
    let res = 0;
    // 先和新补的索引异或一下
    res ^= n;
    // 和其他的元素、索引做异或
    for (let i = 0; i < n; i++)
        res ^= i ^ nums[i];
    return res;
}
```
比如对于[0,1,3,4]

| 原数字 | 0 | 1 |  | 3 | 4 |
| --- | --- | --- | --- | --- | --- |
| 下标 | 0 | 1 | 2 | 3 | 4 |
| 异或后 | 0 | 0 | 2 | 0 | 0 |

只要把所有的元素和索引做异或运算，成对儿的数字都会消为 0，只有这个落单的元素会剩下
### 位1的个数
> 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F)）。
> 输入：n = 00000000000000000000000000001011
> 输出：3
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
> 来源：[https://leetcode.cn/problems/number-of-1-bits](https://leetcode.cn/problems/number-of-1-bits)

#### 代码实现 
```javascript
// ts这么玩儿会报错
function hammingWeight(n: number): number {
  // Think for yourself for 5 minutes...
  let res = 0
  while (n != 0) {
    n = n & (n - 1)
    res++
  }
  return res
}
```
### 找不同
> 给定两个字符串 s 和 t ，它们只包含小写字母。
> 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。
> 请找出在 t 中被添加的字母。
> 输入：s = "abcd", t = "abcde" 输出："e" 解释：'e' 是那个被添加的字母。
> 来源：[https://leetcode.cn/problems/find-the-difference/](https://leetcode.cn/problems/find-the-difference/)

#### 代码实现
```javascript
function findTheDifference(s: string, t: string): string {
  // Think for yourself for 5 minutes...

  let left = 0
  let right = 0
  for (const s1 of s) {
    left ^= s1.charCodeAt(0)
  }

  for (const t1 of t) {
    right ^= t1.charCodeAt(0)
  }
	// 'abcd', 'abcde'  left=4 right=97
  return String.fromCharCode(left ^ right)
}
```
### 格雷编码
> 给你一个整数 n ，返回任一有效的 **n 位格雷码序列** 。
> 来源：[https://leetcode.cn/problems/gray-code/](https://leetcode.cn/problems/gray-code/)

#### 代码实现
```typescript
function grayCode(n: number): number[] {
  // Think for yourself for 5 minutes...
  const ret = []
  for (let i = 0; i < 1 << n; i++) {
    ret.push((i >> 1) ^ i)
  }
  return ret
}
```

## 资料

- 
- 
- 

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679670055515-eab43b0f-d242-4ebf-a7c6-02a0d369ba17.png#averageHue=%23d1d1d1&clientId=ub7ba7a12-51d7-4&from=paste&height=656&id=u9beb64f6&name=image.png&originHeight=917&originWidth=839&originalType=binary&ratio=2&rotation=0&showTitle=false&size=66694&status=done&style=none&taskId=u34f0179c-1389-42c4-aab3-629b389c50a&title=&width=600)
