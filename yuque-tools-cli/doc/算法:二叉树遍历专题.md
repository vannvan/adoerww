# 算法:二叉树遍历专题 
## 例题
###  [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-right-side-view/)
#### 代码实现
```typescript
/**
* BFS 自上向下
*/
function levelOrder(root: TreeNode | null): number[][] {
    //二叉树的层序遍历
    let res = [], queue = [];
    queue.push(root);
    if(root === null) {
        return res;
    }
    while(queue.length !== 0) {
        // 记录当前层级节点数,下面quene长度是会变的，因此要在这里存一份
        let length = queue.length;
        //存放每一层的节点
        let curLevel = [];
        for(let i = 0;i < length; i++) {
            let node = queue.shift();
            curLevel.push(node.val);
            // 存放当前层下一层的节点
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        //把每一层的结果放到结果数组
        res.push(curLevel);
    }
    return res;
};

/**
* DFS
*/
function levelOrder(root: TreeNode | null): number[][] {
    const ans: number[][] = []

    const dfs = (node: TreeNode,level: number) => {

        // 当ans长度等于当前访问的层数时，初始化一个空数组
        if(ans.length === level) {
            ans.push([])
        }

        ans[level].push(node.val) 

        if(node.left !== null) {
            dfs(node.left,level+1)
        }
        if(node.right !== null) {
            dfs(node.right,level+1)
        }
    }

    if(root !== null) {
        dfs(root,0)
    }

    return ans
}
```
### 107. [二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)
#### 代码实现
```typescript
/*
* 自下向上
*/
function levelOrderBottom(root: TreeNode | null): number[][] {
   //二叉树的层序遍历
    const ans: number[][] = []
    const queue: TreeNode[] = [];
  
    queue.push(root);
  
    if(root === null) {
        return ans;
    }
    while(queue.length !== 0) {
        // 记录当前层级节点数,下面queue长度是会变的，因此要在这里存一份
        let length = queue.length;
        // 存放每一层的节点
        let curLevel = [];
        for(let i = 0;i < length; i++) {
            const node = queue.shift();
            curLevel.push(node.val);
            // 存放当前层下一层的节点
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        //把每一层的结果放到结果数组
        ans.push(curLevel);
    }
    return ans.reverse()
};
```
### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)
#### 代码实现
```typescript
/**
* 每一层最右边的值
*/
function rightSideView(root: TreeNode | null): number[] {
    //二叉树的层序遍历
    const ans: number[] = []
    const queue: TreeNode[] = [];
  
    queue.push(root);
  
    if(root === null) {
        return ans;
    }
    while(queue.length !== 0) {
        // 记录当前层级节点数,下面queue长度是会变的，因此要在这里存一份
        let length = queue.length;
        // 存放每一层的节点
        let curLevel = [];
        for(let i = 0;i < length; i++) {
            const node = queue.shift();
            curLevel.push(node.val);
            // 存放当前层下一层的节点
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        //把每一层的结果放到结果数组
        ans.push(curLevel[curLevel.length-1]);
    }
    return ans;
};
```
### [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)
#### 代码实现
```typescript
function levelOrder(root: Node | null): number[][] {
    const ans: number[][] = []
    const dfs = (node: Node,level:number) => {
        if(!node) return 
        if(ans.length === level) {
            ans[level] = []
        }
        ans[level].push(node.val)
        const children = node.children
        for(let i = 0;i < children.length; i++) {
            dfs(children[i],level+1)
        }
    }

    dfs(root,0)
    return ans
};
```
### [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)
#### 代码实现
```typescript

function largestValues(root: TreeNode | null): number[] {
    const ans: number[] = []
    const queue: TreeNode[] = []

    if(root === null) {
        return ans;
    }

    queue.push(root)

    while(queue.length) {
        const length = queue.length 
        let max = Number.MIN_SAFE_INTEGER
        for(let i = 0; i < length; i++) {
            const node = queue.shift() 
        
            node.val > max && (max = node.val)

            node.left && queue.push(node.left)
            node.right && queue.push(node.right)
        }
        ans.push(max)
    }

    return ans 
};
```
### [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)
#### 代码实现
```typescript
function averageOfLevels(root: TreeNode | null): number[] {
    const ans: number[] = []
    const queue: TreeNode[] = [] 

    if(root !== null) {
        queue.push(root)
    }

    while(queue.length) {
        const length = queue.length
        let sum: number = 0
        for(let i = 0; i < length; i++) {
            const node = queue.shift();
            
            sum = sum += node.val ?? 0
            // node.val && curLevel.push(node.val)

            node.left && queue.push(node.left)
            node.right && queue.push(node.right)
        }
        // const avg = curLevel.reduce((prev,curr) => prev + curr) / curLevel.length
        ans.push(sum/length)
    }

    return ans
};
```
### [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)
#### 代码实现
```typescript
function connect(root: Node | null): Node | null {
    if(root === null) {
        return null
    }
    
    const queue:Node[]  = [root]

    while(queue.length) {

        const length = queue.length 

        for(let i = 0;i<length;i++) {
            const node = queue.shift() 
            if(i < length - 1) {
                node.next = queue[0]
            }
            node.left && queue.push(node.left) 
            node.right && queue.push(node.right)

        }
    }
    return root 
};
```
### ⭐️[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)
#### 代码实现
```typescript
/**
 * BFS
 */
function minDepth(root: TreeNode | null): number {
  if (!root) return 0
  let depth = 1

  let queue = [root]

  while (queue.length > 0) {
    let size = queue.length
    for (let i = 0; i < size; i++) {
      let cur = queue.shift()

      // 是否已到达终点
      if (cur.left === null && cur.right === null) {
        return depth
      }
      if (cur.left !== null) {
        queue.push(cur.left)
      }

      if (cur.right !== null) {
        queue.push(cur.right)
      }
    }
    depth++
  }

  return depth
}

/**
* DFS 
 */
function minDepth(root: TreeNode | null): number {
  if (root === null) return 0
  
  let leftDepth = minDepth(root.left)
  let rightDepth = minDepth(root.right)

  return root.left == null || root.right == null
    ? leftDepth + rightDepth + 1
    : Math.min(leftDepth, rightDepth) + 1
}

/*
* DFS 自顶向下
*/
function minDepth(root: TreeNode | null): number {
  if (!root) return 0

  let ans = Infinity
  
  const dfs = function (node: TreeNode, depth: number) {
    if (node === null) {
      return
    }
    if (node.left === null && node.right === null) {
      ans = ans == Infinity ? depth : Math.min(ans, depth)
    }

    dfs(node.left, depth + 1)
    dfs(node.right, depth + 1)
  }

  dfs(root, 1)

  return ans
}
```
