# 算法:哈希表 
## 三种结构
- 数组
- Set
- Map

采用哈希解题通常就是用空间换时间的思路

## 例题
### 有效的字母异位词
> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
> 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。
> 输入: s = "anagram", t = "nagaram" 输出: true 
> 来源：[https://leetcode.cn/problems/valid-anagram](https://leetcode.cn/problems/valid-anagram)

#### 代码实现
```typescript
function isAnagram(s: string, t: string): boolean {
  // Think for yourself for 5 minutes...
  if (s.length != t.length) return false

  const hash: Map<string, number> = new Map()

  for (const c of s) {
    const a = hash.get(c) || 0
    hash.set(c, a + 1)
  }

  for (const d of t) {
    if (hash.has(d) && hash.get(d)) {
      const a: number = hash.get(d) as any
      hash.set(d, a - 1)
    } else {
      return false
    }
  }

  return true
}
```
### 两个数组的交集
> 给定两个数组 nums1 和 nums2 ，返回 _它们的交集_ 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。
> 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2]
> 来源：[https://leetcode.cn/problems/intersection-of-two-arrays/](https://leetcode.cn/problems/intersection-of-two-arrays/)

#### 代码实现
```typescript
function intersection(nums1: number[], nums2: number[]): number[] {
  // Think for yourself for 5 minutes...

  const longNums: number[] = nums1.length > nums2.length ? nums1 : nums2

  const shortNums: number[] = nums1.length < nums2.length ? nums1 : nums2

  const res: Set<number> = new Set()
  for (const a of longNums) {
    if (shortNums.includes(a)) {
      res.add(a)
    }
  }
  return [...res]
}
```
### 快乐数
> 编写一个算法来判断一个数 n 是不是快乐数。
> 「快乐数」 定义为：
> 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
> 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
> 如果这个过程 结果为 1，那么这个数就是快乐数。
> 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。
> 输入：n = 19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1
> 来源：[https://leetcode.cn/problems/happy-number](https://leetcode.cn/problems/happy-number)

#### 代码实现
```typescript
function isHappy(n: number): boolean {
  // Think for yourself for 5 minutes...

  // q1. 考虑数字拆成各位数之后逐渐拆分一定后面一定不会重复，重复就代表无限循环就不是快乐数了
  let m = new Map()

  const getSum = (num: number) => {
    let sum = 0
    while (n) {
      sum += (n % 10) ** 2
      n = Math.floor(n / 10)
    }
    return sum
  }

  while (true) {
    // n出现过，证明已陷入无限循环
    if (m.has(n)) return false
    if (n === 1) return true
    m.set(n, 1)
    n = getSum(n)
  }
}
```
### 两数之和
> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。
> 输入：nums = [2,7,11,15], target = 9
> 输出：[0,1]
> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
> 来源：[https://leetcode.cn/problems/two-sum](https://leetcode.cn/problems/two-sum)

#### 代码实现
```typescript
function twoSum(nums: number[], target: number): number[] {
   let map = new Map<number, number>()
  for (let i = 0; i < nums.length; i++) {
    if (map.has(target - nums[i])) {
      return [map.get(target - nums[i]), i]
    }
    map.set(nums[i], i)
  }
  return [-1, -1]
}
```
### 四数相加 II
> 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：
> 0 <= i, j, k, l < n
> nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
> 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
> 来源：[https://leetcode.cn/problems/4sum-ii](https://leetcode.cn/problems/4sum-ii)

#### 代码实现
```typescript
function fourSumCount(nums1: number[], nums2: number[], nums3: number[], nums4: number[]): number {
  // Think for yourself for 5 minutes...'

  const map: Map<number, number> = new Map()
  let count: number = 0
  let tmpVal: number = 0
  for (let i of nums1) {
    for (let j of nums2) {
      tmpVal = map.get(i + j) || 0
      map.set(i + j, tmpVal + 1)
    }
  }

  for (let k of nums3) {
    for (let l of nums4) {
      tmpVal = map.get(0 - (k + l)) || 0
      if (tmpVal) {
        count += tmpVal
      }
    }
  }

  return count
}
```
### 赎金信
> 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
> 如果可以，返回 true ；否则返回 false 。
> magazine 中的每个字符只能在 ransomNote 中使用一次。
> 输入：ransomNote = "a", magazine = "b" 输出：false
> 输入：ransomNote = "aa", magazine = "aab" 输出：true
> 来源：[https://leetcode.cn/problems/ransom-note](https://leetcode.cn/problems/ransom-note)

#### 代码实现
```typescript
function canConstruct(ransomNote: string, magazine: string): boolean {
  // Think for yourself for 5 minutes...

  let n: number = ransomNote.length

  const hash: Map<string, number> = new Map()

  for (const s of magazine) {
    const a = hash.get(s) || 0
    hash.set(s, a + 1)
  }


  for (const s of ransomNote) {
    if (hash.has(s) && hash.get(s)) {
      const a = hash.get(s) || 0
      hash.set(s, a - 1)
      n--
    } else {
      return false
    }
  }


  return n == 0
}
```
### 多数元素
> 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
> 输入：nums = [3,2,3] 输出：3
> 输入：nums = [2,2,1,1,1,2,2] 输出：2
> 来源：[https://leetcode.cn/problems/majority-element](https://leetcode.cn/problems/majority-element)

#### 代码实现
```typescript
function majorityElement(nums: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. 多数元素指的是 次数大于 n/2的元素

  let ans: number = 0
  let max = 0
  const hash = {}

  for (const val of nums) {
    hash[val] = (hash[val] || 0) + 1
  }

  Object.keys(hash).forEach((key) => {
    if (hash[key] > max) {
      console.log(key, hash[key])
      max = hash[key]
      ans = Number(key)
    }
  })

  return ans
}

function majorityElement(nums: number[]): number {
  // 如果元素出现次数大于数组长度的一半，那最中间的那个元素一定是出现次数最多的元素
  nums.sort((a, b) => a - b)
  return nums[Math.floor(nums.length / 2)]
}
```
### 整数转罗马数字
> 输入: num = 3 输出: "III"
> 输入: num = 58 输出: "LVIII" 解释: L = 50, V = 5, III = 3.
> 来源：[https://leetcode.cn/problems/integer-to-roman/](https://leetcode.cn/problems/integer-to-roman/)

#### 代码实现
```typescript
function intToRoman(num: number): string {
  // Think for yourself for 5 minutes...

  // 21 XXI 22 XXII

  const hash: [number, string][] = [
    [1000, 'M'],
    [900, 'CM'],
    [500, 'D'],
    [400, 'CD'],
    [100, 'C'],
    [90, 'XC'],
    [50, 'L'],
    [40, 'XL'],
    [10, 'X'],
    [9, 'IX'],
    [5, 'V'],
    [4, 'IV'],
    [1, 'I'],
  ]

  // q1. 先根据最大位取值
  // q2. 从左到右的每一位，需要选尽可能大的符号

  const roman: string[] = []

  for (const [value, symbol] of hash) {
    while (num >= value) {
      num -= value
      roman.push(symbol)
    }
    if (num === 0) break
  }

  return roman.join('')
}
```
#### 相关题目

- 
```typescript
function romanToInt(s: string): number {
  // Think for yourself for 5 minutes...

  //  用switch处理会更快
  const symbolValues = new Map()
  symbolValues.set('I', 1)
  symbolValues.set('V', 5)
  symbolValues.set('X', 10)
  symbolValues.set('L', 50)
  symbolValues.set('C', 100)
  symbolValues.set('D', 500)
  symbolValues.set('M', 1000)


  let ans = 0
  const n = s.length
  for (let i = 0; i < n; ++i) {
    // XIX可以视作X-I+V = 10 - 1 + 5 = 14
    // 因此 若存在小的数字在大的数字左边的情况，需要减去小的数字
    const value = symbolValues.get(s[i])
    if (i < n - 1 && value < symbolValues.get(s[i + 1])) {
      ans -= value
    } else {
      ans += value
    }
  }
  return ans
}
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1680092406189-090049c7-c702-4d67-a10d-a4a3312abb06.png#averageHue=%23f5f5f5&clientId=u2345a890-3e34-4&from=paste&height=430&id=u2e6b0279&name=image.png&originHeight=860&originWidth=1184&originalType=binary&ratio=2&rotation=0&showTitle=false&size=176834&status=done&style=none&taskId=u033cf998-1bda-4060-aef5-8888b658c2a&title=&width=592)



## 资料

