# 算法:动态规划Ⅰ 
## 概念
动态规划（dynamic programming, DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。
动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。
## 性质

1. **最优子结构性质**。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。
2. **子问题重叠性质**。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，**对每一个子问题只计算一次**，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。
3. **无后效性**：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。例如：f(4), f(10), f(14) ，我们只需要求出他们的具体值，他们的计算过程对我们之后要求解的问题没有影响。
## 应用场景

1. 背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合
2. 最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。
3. 矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。
4. 硬币找零：给出面额为d1, …, dn的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。
5. 图的全源最短路径：对所有顶点对(u, v)，找出从顶点u到顶点v的最短路径。
## 三个步骤

1. **划分**：按照问题的特征，把问题分为若干阶段。注意：划分后的阶段**一定是有序的或者可排序**的
2. **确定状态和状态变量**：将问题发展到各个阶段时所处的各种不同的客观情况表现出来。状态的选择要满足无后续性
3. **确定决策并写出状态转移方程**：状态转移就是根据上一阶段的决策和状态来导出本阶段的状态。根据相邻两个阶段状态之间的联系来确定决策方法和状态转移方程
4. **边界条件**：状态转移方程是一个递推式，因此需要找到递推终止的条件
## 例题
### 硬币找零
> 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
> 你可以认为每种硬币的数量是无限的。
> [https://leetcode.cn/problems/gaM7Ch/](https://leetcode.cn/problems/gaM7Ch/)

#### 返回数量
##### 代码实现
```javascript
/**
 * 返回零钱个数
 * 以 [1, 2, 5, 10, 20], 36 为例
 * 金额 1 的最优解 是1 1
 * 金额 2 的最优解 是1 过程，找dp[2] 会经过两轮 A轮 dp[1]和dp[1-1]+1 取1 B轮dp[2]和dp[2-1] 取1
 * 金额 3 的最优解 是2 1+2 过程，找dp[3] 会用到1和2 dp[3-1]+1 前者小
 * 金额 4 的最优解 是2 2+2 过程，找dp[4] 会经过两轮 A dp[4]和dp[4-1]+1 取3 B dp[4]和dp[4-2]+1 取2
 * 整体的思路就是 假设在计算dp(需要找零的钱)之前，我们已经计算出dp(0) 到dp(需要找零的钱-1)的值。
 * @param coins
 * @param amount
 * @returns number
 */
const minCoinChange2 = (coins: number[], amount: number) => {
  const max = amount + 1
  const dp = new Array(max).fill(max)
  dp[0] = 0 // 金额0的最优解为0
  // 从1开始，这里假设了所有1，2，3，4，5...的钱都有，第i块钱的时候，
  // 要去尝试每一个可用面值一次i-coin，因为假设前面已经找到了少1元面值的数
  for (let i = 1; i <= amount; i++) {
    // 内层遍历就是整个零钱数组的过程，当前凑的钱数i都尝试一下所有可用的面值
    for (const coin of coins) {
      if (coin <= i) {
        dp[i] = Math.min(dp[i], dp[i - coin] + 1)
      }
    }
  }

  return dp[amount] > amount ? -1 : dp[amount]
}
```
##### 实现思路
dp[i]的含义是：找零i元钱需要的最少零钱个数
对于dp[i]的最优解，在coin小于i的情况下，a. 直接之前已经计算出的dp[i]  b. i-coin的最优解+1 ，需要求两者的最小值
通过归纳法，以 [1, 2, 5, 10, 20], 36 为例，当使用1时amount=dp[35]+1,当使用2时amount=dp[34]+1，当使用5时amount=dp[31]+1,当使用10时，amount=dp[26]+1... 即认为每个金额前或许存在着比当前金额本身更少的解法，以上**dp[i] = Math.min(dp[i], dp[i - coin] + 1)**就是在实现这个环节的。
#### 返回零钱数组
##### 代码实现
```javascript

/**
 * 返回零钱数组
 * 以 [1, 2, 5, 10, 20], 36 为例
 * 会对所有小于amount的金额计算minCoinChange的结果
 * @param coin 钱的面额数组
 * @param amount 需要找的钱
 * @returns number[]
 */

const minCoinChange = (coins: number[], amount: number) => {
  const cache = {}
  const makeChange = (value: number) => {
    if (!value) return []
    if (cache[value]) return cache[value]
    let lastMin: number[] = [] // 最终的最优解
    let preMin: number[] = [] // 既是小于当前面额的某个面额的最优解，也是后续value-coins[i]的最优解
    let newAmount: number
    for (let i = 0; i < coins.length; i++) {
      const coin = coins[i]
      newAmount = value - coin // 剩下的需要找的钱
      if (newAmount >= 0) {
        preMin = makeChange(newAmount) // 在coins没用完之前，对剩余的钱找最小的结果
      }
      // 当到36的时候，此时coins[i] 1元的时候 preMin 已经从 35元拿到了 [5,10,20] (preMin.length || !newAmount)成立,
      // 同时preMin.length=3 lastMin.length - 1=0不成立  !lastMin.length成立
      // newAmount 为35成立
      if (
        newAmount >= 0 &&
        (preMin.length < lastMin.length - 1 || !lastMin.length) &&
        (preMin.length || !newAmount)
      ) {
        // preMin的存在是用来存储每一轮使用coins[i]的时候，当前数额是否在 value-coins[i]的时候找到了最优解
        lastMin = [coin].concat(preMin)
        console.log('new min for', lastMin, value)
      }
    }
    cache[value] = lastMin
    return cache[value]
  }

  return makeChange(amount)
}
```
##### 实现要点
整体思路是对小于等于所求金额amount的最优解建立一个cache，在递归里直接更新amount对应下标的最优解。
每次递归需初始化最终的最优解、for循环所需的本次找完钱的最优解、和剩余需要找的钱。
最长的if条件怎么理解呢？经过一次找钱后，**preMin<lastMin.length - 1 || **!**lastMin.length  **即剩余金额找钱的方式已经比上次找的更少了或还没有最优解(前者一般第一轮不会执行，后者一般只有第一轮执行)
**preMin.length || !newAmount  **前者第一轮不会执行，后者找完了不会执行
### 切绳子
> 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
> [https://leetcode.cn/problems/jian-sheng-zi-lcof/](https://leetcode.cn/problems/jian-sheng-zi-lcof/)

#### 代码实现
```javascript
/**
 * 切绳子，返回最大乘积
 * @param length
 * @returns number
 */
const cutTheRope = (length: number) => {
  // 不能切
  if (length < 2) {
    return 0
  }
  // 只能从中间切
  if (length == 2) {
    return 1
  }
  // 只能切为 1 1 1 或 1 2 所以最大为2
  if (length === 3) {
    return 2
  }

  const dp = new Array(length + 1)
  dp[0] = 0
  dp[1] = 1
  // 绳子长度为2或3时，不进行拆分，最大乘积为绳子的长度
  dp[2] = 2
  dp[3] = 3

  for (let i = 4; i <= length; i++) {
    dp[i] = 0
    let max = 0
    // 至少切一刀，所以从1开始，切过中间值以后，与中间值以前的计算结果一样，所以只用算出前面部分的结果，因此 j<=i/2
    for (let j = 1; j <= i / 2; j++) {
      const result = dp[j] * dp[i - j]
      if (max < result) {
        max = result
      }
      dp[i] = max
    }
  }

  return dp[length]
}
// cutTheRope(8)  18  切法是2 3 3  dp[2]=2 dp[3]=3 dp[4]=4 dp[5]=6
```
#### 实现思路
dp[i]的含义是：i长度的绳子，可以拆分的长度的最大乘积
在于归纳总结绳子的切法和最大乘积的关系，以及绳子切到一半之后，后面的结果肯定是前面已经算出来的这个界限，才是规划的意义， dp[j] * dp[i - j] 会更新每一种长度的最大乘积
更好的解：
### 背包问题
#### 代码实现
```javascript

/**
 * 获取最大价值组合的物品位置
 * @param n 最大个数
 * @param capacity 容量
 * @param KW 最佳组合矩阵
 * @param weights 重量
 * @param values 价值
 */
const findMaxValue = (
  n: number,
  capacity: number,
  KW: number[][],
  weights: number[],
  values: number[]
) => {
  let i = n
  let w = capacity
  // 当剩余数量和容量都大于0就执行循环
  while (i > 0 && w > 0) {
    // 这里的含义是假设取了这个物品和少取一次这个物品的价值相同，那就往前找少取一次这个物品的位置
    if (KW[i][w] !== KW[i - 1][w]) {
      console.log(`物品 ${i} 可以是解的一部分 w,v: ${weights[i - 1]}, ${values[i - 1]};`)
      i--
      w = w - KW[i][w]
    } else {
      i-- // 继续往上找
    }
  }
}

/**
 *
 * @param weights 物品重量
 * @param values 物品的价值
 * @param capacity 背包容量
 * @param n 物品数量
 * @returns number
 */
const knapSack = (weights: number[], values: number[], capacity: number, n: number) => {
  // 初始化所有子方案矩阵
  const KW: number[][] = []

  for (let i = 0; i <= n; i++) {
    KW[i] = []
  }
  // i是将要装的物品数量
  for (let i = 0; i <= n; i++) {
    // w 将要装进去的物品体积
    for (let w = 0; w <= capacity; w++) {
      // 当数量为0 表示什么都不装，当容量为0，表示什么都装不下，矩阵第一行第一列统一为0
      if (i == 0 || w == 0) {
        KW[i][w] = 0
        // 此处的含义是装了w之后 还剩下的容量的处理方式
      } else if (weights[i - 1] <= w) {
        // 物品i的重量必须小于约束容量
        // planA 的含义是 装了当前物品的价值 + 前i-1的最佳组合的价值，
        // [w - weights[i - 1]] 即因为已经装了w 剩下的就是weights[i - 1]
        // 或者说是 容量为w-weights[i-1]的时候的不放物品i的价值
        const planA = values[i - 1] + KW[i - 1][w - weights[i - 1]] 
        // planB 的含义是 不装当前物品 直接取前i-1的最佳组合
        const planB = KW[i - 1][w] 
        KW[i][w] = planA > planB ? planA : planB
      } else {
        // 尝试装w，容量不够，取前一个方案i-1
        KW[i][w] = KW[i - 1][w]
      }
    }
  }

  // findMaxValue(n, capacity, KW, weights, values)
  // console.log(KW)
  console.log('最佳组合的最大价值为', KW[n][capacity])
  return KW[n][capacity]
}
```
#### 实现要点
KW[i][w]的含义：从下标[0,i]的物品里任意取，放进容量为w的背包，其最大价值是多少。

1. 如果装不下当前物品，那么前n个物品的最佳组合和前n-1个物品的最佳组合是一样的
2. 如果装的下当前物品，
- 假设A：装当前物品，在给当前物品预留了相应空间的情况下，前n-1个物品的最佳组合加上当前物品的价值就是总价值
- 假设B：不装当前物品，那么前n个物品的最佳组合和前n-1个物品的最佳组合是一样的

选取假设A和假设B中较大的价值，就是当前最佳组合的价值
从表的最右下角开始回溯，如果发现前n个物品的最佳组合价值和前n-1个物品的最佳组合的价值一样，说明第n个物品没有被装入，否则第n个物品被装入。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677166251026-26e629ea-30e9-473f-b937-44568e3847f2.png#averageHue=%23fbfcfc&clientId=u4fb16ff9-639b-4&from=paste&height=340&id=uc9ddbd42&name=image.png&originHeight=1050&originWidth=1854&originalType=binary&ratio=2&rotation=0&showTitle=false&size=465772&status=done&style=none&taskId=u8fc8997b-8521-457e-8cc6-3cc194d34df&title=&width=600)

### ⭐️背包问题2
> 只限制背包最大个数，计算最大价值

#### 代码实现
```typescript
function weightBagProblemNormal(weight, value, size) {
  // 定义 dp 数组
  const len = weight.length,
    dp = Array(len)
      .fill([])
      .map(() => Array(size + 1).fill(0))


  // 初始化
  for (let j = weight[0]; j <= size; j++) {
    dp[0][j] = value[0]
  }


  // weight 数组的长度len 就是物品个数
  for (let i = 1; i < len; i++) {
    // 遍历物品
    for (let j = 0; j <= size; j++) {
      // 遍历背包容量
      if (j < weight[i]) dp[i][j] = dp[i - 1][j]
      else dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
    }
  }


  console.table(dp)

  return dp[len - 1][size]
}
```
#### ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678957777566-72aec29e-9fd5-4ea1-8c07-aa9a1edc2579.png#averageHue=%23d0cfcc&clientId=ucfa155a2-c2eb-4&from=paste&height=268&id=sVu7P&name=image.png&originHeight=536&originWidth=1404&originalType=binary&ratio=2&rotation=0&showTitle=false&size=166470&status=done&style=none&taskId=u19deaa56-47c7-4ae5-926a-f6721ef9a7f&title=&width=702)
#### 代码实现
```javascript
/**
 * 只限制个数算最大价值的01背包
 * @param weights 重量
 * @param values 价值
 * @param size 个数
 * @returns
 */
function weightBagProblem(weights: number[], values: number[], size: number) {
  const len = weights.length,
    dp = Array(size + 1).fill(0)
  // 从0开始
  for (let i = 0; i < len; i++) {
    for (let j = size; j >= weights[i]; j--) {  // 注意要倒序
      // dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。
      dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i])
    }
  }
  return dp[size]
}
```
思路分析
dp[j]的含义是：容量为为j的背包所背的最大价值
### ⭐️最长递增子序列
> 给你一个整数数组 nums ，找到其中最长**严格递增子序列**的长度。
> 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
> **示例 1：**
> 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
> [https://leetcode.cn/problems/longest-increasing-subsequence/](https://leetcode.cn/problems/longest-increasing-subsequence/)

#### 返回数量
```javascript

/**
 * 最长子递增子序列长度
 * dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。
 * @param {number[]} nums
 * @return {number}
 */
const lengthOfLIS = (nums: number[]): number => {
  //  // dp 数组的定义，它记录的正是以每个元素为末尾的最长递增子序列的长度。
  const dp = new Array(nums.length).fill(1)
  let res = 0
  for (let i = 0; i < nums.length; i++) {
    // j 序列就是在求 nums 以每个元素为末尾的最长子序列长度
    // 因此这段的含义是：位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。
    for (let j = 0; j < i; j++) {
      // 寻找nums[0..j-1] 中比 nums[i] 小的元素
      if (nums[i] > nums[j]) {
        console.log('num', nums[i], nums[j])
        // 把 nums[i] 算上，即可形成长度为 dp[j] + 1，且以 nums[i] 为结尾的递增子序列
        dp[i] = Math.max(dp[i], dp[j] + 1)
        // 或 dp[i] = dp[i] > dp[j] + 1 ? dp[i] : dp[j] + 1
      }
    }
    if (dp[i] > res) {
      res = dp[i]
    }
  }

  return res
}
```
### ⭐️最长连续递增序列
> 给定一个未经排序的整数数组，找到**最长且 连续递增的子序列，并返回该序列的长度。**
> 连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。
> 输入：nums = [1,3,5,4,7]
> 输出：3
> 解释：最长连续递增序列是 [1,3,5], 长度为3。
> 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
> 来源：[https://leetcode.cn/problems/longest-continuous-increasing-subsequence](https://leetcode.cn/problems/longest-continuous-increasing-subsequence)

#### 代码实现
```javascript
function findLengthOfLCIS(nums: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. 考虑需要连续递增的子序列
  // q2. dp[i] 表示以nums[i]结尾的连续递增子序列
  // dp[i] = dp[i-1]+1

  const n: number = nums.length
  const dp: number[] = Array(n).fill(1)

  let result: number = 0
  for (let i = 0; i < n; i++) {
    if (nums[i] > nums[i - 1]) {
      dp[i] = dp[i - 1] + 1
    }
    if (dp[i] > result) {
      result = dp[i]
    }
  }

  return result
}
```
### ⭐️最长重复子数组
> 给两个整数数组 nums1 和 nums2 ，返回 _两个数组中 **公共的 、长度最长的子数组的长度 **_。
> 输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7] 输出：3 解释：长度最长的公共子数组是 [3,2,1] 。
> 来源：[https://leetcode.cn/problems/maximum-length-of-repeated-subarray/](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

#### 代码实现
```javascript
function findLength(nums1: number[], nums2: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. 子数组=连续子序列
  // 以一个数组为基准，从另一个数组元素依次确定A[i-1]和B[j-1]位置的值是否相等
  // dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。
  // 当A[i-1]===B[j-1]的时候，dp[i][j] = dp[i-1][j-1] + 1
  const dp: number[][] = Array.from(Array(m+1), () => Array(n+1).fill(0))
  
  let result: number = 0

  for (let i = 1; i <= nums1.length; i++) {
    for (let j = 1; j <= nums2.length; j++) {
      if (nums1[i - 1] === nums2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1
      }
      result = dp[i][j] > result ? dp[i][j] : result
    }
  }
  return result
}

/**
 * 滚动数组优化版
 * @param nums1
 * @param nums2
 */
function findLength(nums1: number[], nums2: number[]): number {
  const dp: number[] = Array(nums2.length + 1).fill(0)

  let result: number = 0

  for (let i = 1; i <= nums1.length; i++) {
    for (let j = nums2.length; j > 0; j--) {
      if (nums1[i - 1] === nums2[j - 1]) {
        dp[j] = dp[j - 1] + 1
      } else {
        dp[j] = 0
      }
      result = dp[j] > result ? dp[j] : result
    }
  }
  return result
}
```
PS：对于为什么定义下标为i-1结尾的解释：
### ⭐️最长公共子序列LCS
> 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
> 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
> 输入：text1 = "abcde", text2 = "ace"  输出：3   解释：最长公共子序列是 "ace" ，它的长度为 3 。
> 来源：[https://leetcode.cn/problems/qJnOS7/](https://leetcode.cn/problems/qJnOS7/)

最长公共子序列是一个十分实用的问题，它可以描述两段文字之间的"相似度"，即它们的雷同程度，从而能够用来辨别抄袭。对一段文字进行修改之后，计算改动前后文字的最长公共子序列，将除此子序列外的部分提取出来，这种方法判断修改的部分，往往十分准确。  
PS:
#### 返回数量
```javascript
/**
 * 最长子序列长度  
 * eg: 'abedcf', 'daecfa'
 * @param wordX 字符串x
 * @param wordY 字符串y
 * @returns number
 */
const longestCommonSubsequence = (wordX: string, wordY: string): number => {
  const m = wordX.length
  const n = wordY.length
  // 初始化dp矩阵
  const dp: number[][] = []
  for (let i = 0; i <= m; i++) {
    dp[i] = []
    for (let j = 0; j <= n; j++) {
      dp[i][j] = 0
    }
  }

  for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
      if (i === 0 || j === 0) {
        dp[i][j] = 0
        // 当纵横位置字符相同的话，当前位置的值等于左上斜角的值+1
      } else if (wordX[i - 1] === wordY[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1
      } else {
        // 否则就比较正上方和正左侧的值，哪个大就取哪个
        const topValue = dp[i - 1][j]
        const leftValue = dp[i][j - 1]
        dp[i][j] = topValue > leftValue ? topValue : leftValue
      }
    }
  }
  return dp[m][n]
}
```
#### 返回序列值
```javascript
/**
 * 获取子序列值
 * @param solution 序列矩阵
 * @param wordX
 * @param m x 轴
 * @param n y 轴
 * @returns string
 */
const getSolution = (solution: string[][], wordX: string, m: number, n: number): string => {
  let xAxis = m // 横向
  let yAxis = n // 纵向
  let x = solution[yAxis][xAxis]  // 最右下角
  let result = ''
  while (x !== '-') {
    if (solution[yAxis][xAxis] === 'diagonal') {
      result = wordX[yAxis - 1] + result
      yAxis--
      xAxis--
    } else if (solution[yAxis][xAxis] === 'left') {
      xAxis--
    } else if (solution[yAxis][xAxis] === 'top') {
      yAxis--
    }
    x = solution[yAxis][xAxis]
  }

  return result
}

/**
 * 最长子序列值
 * eg: 'abedcf', 'daecfa'
 * @param wordX 字符串x
 * @param wordY 字符串y
 * @returns string
 */
const longestCommonSubsequencePlan = (wordX: string, wordY: string): string => {
  const m = wordX.length
  const n = wordY.length
  // 初始化dp矩阵
  const dp: number[][] = []
  const solution: string[][] = []
  for (let i = 0; i <= m; i++) {
    dp[i] = []
    solution[i] = []
    for (let j = 0; j <= n; j++) {
      dp[i][j] = 0
      solution[i][j] = ''
    }
  }

  for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
      if (i === 0 || j === 0) {
        dp[i][j] = 0
        solution[i][j] = '-'
        // 当纵横位置字符相同的话，当前位置的值等于左上斜角的值+1
      } else if (wordX[i - 1] === wordY[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1
        solution[i][j] = 'diagonal'
      } else {
        // 否则就比较正上方和正左侧的值，哪个大就取哪个
        const topValue = dp[i - 1][j]
        const leftValue = dp[i][j - 1]
        dp[i][j] = topValue > leftValue ? topValue : leftValue
        solution[i][j] = topValue > leftValue ? 'top' : 'left'
      }
    }
  }
  // 因为上面是 wordX作为外层for循环，因此wordX是在y轴
  return getSolution(solution, wordX, m, n)
}

```
#### 简洁版
```typescript
function longestCommonSubsequence(text1: string, text2: string): number {
  // Think for yourself for 5 minutes...
  // q1. 子序列，不需要连续的
  // q2. dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]
  // 对于dp[i][j] 在对比过程中存在 text1[i-1]和text2[j-1] ，存在两种情况
  // a. 相同 dp[i][j] = dp[i-1][j-1]+1
  // b. 不同 就取text1[0,i-2]和text2[0,j-1] 或text1[0,i-1]和text2[0,j-2]的最长子序列，即max(dp[i-1][j],dp[i][j-1])
  // dp[0][i] 为0  dp[j][0] 为0

  const [m, n] = [text1.length, text2.length]

  const dp: number[][] = Array.from(Array(m+1), () => Array(n+1).fill(0))


  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i - 1] === text2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
      }
    }
  }

  return dp[m][n]
}
```
#### 实现思路
先用归纳法列出矩阵标识序列矩阵的特征
特征1：**dp[0][j]或dp[j][0]  都为0**
特征2：**dp[i][j] = dp[i - 1][j - 1] + 1**   当坐标所处位置两个字符串的字符一致，那么长度为左上角的值+1
特征3：当不存在以上情况，那么当前坐标位置的值就取左侧和上侧中较大的那一个 **dp[i][j] = dp[i-1][j] / dp[i][j-1]**

在寻找具体子序列值的之后，以一个字符串为基准，以序列矩阵的标识为依据，从最右下角开始找，当遇到‘diagonal’时，说明序列矩阵横纵位置出现相同的字符，记下来，当遇到‘top’或‘left’时，往它们更小的方向去找，即可求得最后的结果。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677311552391-194bb323-5cb7-489e-abdd-1d59e64ae537.png#averageHue=%23fbfafa&clientId=u2db308b2-e67b-4&from=paste&height=704&id=u94aa6587&name=image.png&originHeight=1408&originWidth=2528&originalType=binary&ratio=2&rotation=0&showTitle=false&size=307615&status=done&style=none&taskId=u17ec9879-4219-477f-9f00-df31f1ffd7e&title=&width=1264) 
### ⭐️判断子序列
> 给定字符串 s 和 t ，判断 s 是否为 t 的子序列
> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
> 输入：s = "abc", t = "ahbgdc" 输出：true
> 来源：[https://leetcode.cn/problems/is-subsequence](https://leetcode.cn/problems/is-subsequence)

#### 代码实现
```javascript
function isSubsequence(s: string, t: string): boolean {
  // Think for yourself for 5 minutes...
  // q1. s为t的子序列，s长度一定<=t的长度
  // q2. 一定满足s和t的公共子序列长度为s的长度
  // 当 i-1 == j-1的字符时更新值
  // 当不等于时 t需要删减元素了

  const [m, n] = [s.length, t.length]

  const dp: number[][] = Array.from(Array(m + 1), () => Array(n + 1).fill(0))
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (s[i - 1] === t[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1
      } else {
        // 这里因为与LCS不同的点就是 LCS是比较dp[i - 1][j], dp[i][j - 1]，
        // 但此题需要的是从长的t中找s，因此当遇到不同时只能移动t[j]而不能移动s[i],相当于是让s[i-1]再去和t[j-2]做比较
        dp[i][j] = dp[i][j - 1]
      }
    }
  }

  return dp[m][n] === m
}
```
### 不同的子序列
> 给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。
> 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）
> 题目数据保证答案符合 32 位带符号整数范围。
> 输入：s = "rabbbit", t = "rabbit" 输出：3
> 解释：
> 如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
> rabbbit
> rabbbit
> rabbbit
> 来源：[https://leetcode.cn/problems/distinct-subsequences](https://leetcode.cn/problems/distinct-subsequences)

#### 代码实现
```javascript
function numDistinct(s: string, t: string): number {
  // Think for yourself for 5 minutes...
  // dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数
  // s[i-1] ==t[i-1] 时 分两种情况 a. 用s[i-1]匹配，那么dp[i-1][j-1] b. 不用s[i-1]匹配，dp[i-1][j]
  // 例如 s：bagg 和 t：bag 对于s[2]和s[3]是相同的，可以选择用或不用[2],[3] 因为他们各自会构成一个结果
  // s[i-1]!=t[i-1] 时，dp[i-1][j]
  // dp[i][0] 表示 s中任意i-1结尾的位置删除元素，出现空字符串的个数，全是 1
  // dp[0][j] 表示 空字符串随意删除元素，出现t中j结尾的字符串个数，全是0

  const [m, n] = [s.length, t.length]

  const dp: number[][] = Array.from(Array(m + 1), () => Array(n + 1).fill(0))

  for (let i = 0; i <= m; i++) dp[i][0] = 1
  for (let j = 1; j <= n; j++) dp[0][1] = 0 // 可以省略

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (s[i - 1] == t[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
      } else {
        dp[i][j] = dp[i - 1][j]
      }
    }
  }

  return dp[m][n]
}
```
### ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679145322207-791dafcc-e548-4f08-b888-6262d68e6e03.png#averageHue=%23f2f2f2&clientId=u86e15571-2fbc-4&from=paste&height=607&id=uef41019e&name=image.png&originHeight=1194&originWidth=1180&originalType=binary&ratio=1&rotation=0&showTitle=false&size=212092&status=done&style=none&taskId=u1df4afe2-d99b-4e12-8217-6ff1c728b83&title=&width=600)
### 两个字符串的删除操作
> 给定两个单词 word1 和 word2 ，返回使得 word1 和  word2_ _**相同**所需的**最小步数**。
> **每步 **可以删除任意一个字符串中的一个字符。
> 输入: word1 = "sea", word2 = "eat"  输出: 2
> 解释: 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"
> 来源：[https://leetcode.cn/problems/delete-operation-for-two-strings](https://leetcode.cn/problems/delete-operation-for-two-strings)

#### 代码实现
```typescript
function minDistance(word1: string, word2: string): number {
  // Think for yourself for 5 minutes...
  // q1. 考虑要使两个字符串相等每次可以删掉一个数据
  // q2 dp[i][j]的含义是 以i-1结尾的word1，和以j-1结尾的word2，要达到相等需要删除的最少次数
  // 当word1[i-1] 和 word2[j-1] 相等的时候 dp[i][j] = dp[i-1][j-1]
  // 当word1[i-1] 和 word2[j-1]不想等的时候 分三种删除方式,取最小值
  // a. 删除word1[i-1]  -> dp[i-1][j]+1
  // b. 删除word2[j-1] -> dp[i][j-1]+1
  // c. 两个都删除 -> dp[i-1][j-1] + 2 因为 dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2 因此这种可以去除

  const [m, n] = [word1.length, word2.length]

  const dp: number[][] = Array.from(Array(m + 1), () => Array(n + 1).fill(0))

  for (let i = 0; i <= m; i++) dp[i][0] = i // 要使以i-1结尾的word1和空字符串匹配，需要删除i个字符
  for (let j = 0; j <= n; j++) dp[0][j] = j // 要使空字串和j-1结尾的word2匹配，需要删除j个字符

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1]
      } else {
        dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)
      }
    }
  }

  return dp[m][n]
}
```
### ⭐️回文子串 
> 给你一个字符串 s ，请你统计并返回这个字符串中 **回文子串** 的数目。
> 输入：s = "abc" 输出：3 解释：三个回文子串: "a", "b", "c"
> 输入：s = "aaa" 输出：6 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa" 
来源：[https://leetcode.cn/problems/palindromic-substrings/](https://leetcode.cn/problems/palindromic-substrings/)

#### 代码实现
```javascript

function countSubstrings(s: string): number {
  // Think for yourself for 5 minutes...
  // dp[i][j] 表示区间[i,j]范围内的字符是否能构成回文字符串 boolean
  // 当s[i]与s[j]相等时，分三种情况
  // a. i=j [a] 这种
  // b. i和j相差为1 [a,a]
  // c. i和j相差大于1 [c,a,b,a,c] 就缩小区间 s[i+1]和s[j-1]是否相等
  // 遍历顺序的确定，如果按照从上到下，从左到右，考虑对于情况c而言 dp[i][j] = s[i+1]和s[j-1] .. 此时要求的结果在当前位置的左下方
  // 显然需要采用从下往上，从左往右的顺序遍历才可以
  const n: number = s.length

  const dp: boolean[][] = Array.from(Array(n), () => Array(n).fill(false))

  let result: number = 0

  for (let i = n - 1; i >= 0; i--) {
    for (let j = i; j < n; j++) {
      // if (s[i] == s[j]) {
      //   // a b
      //   if (j - i <= 1) {
      //     dp[i][j] = true
      //     result++
      //   } else if (dp[i + 1][j - 1]) {
      //     // c
      //     result++
      //     dp[i][j] = true
      //   }
      // }

      // 简化
      if ((j - i <= 1 || dp[i + 1][j - 1]) && s[i] == s[j]) {
        result++
        dp[i][j] = true
      }
    }
  }

  return result
}
```
### ⭐️最长回文子序列
> 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度
> 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
> 输入：s = "bbbab" 输出：4 解释：一个可能的最长回文子序列为 "bbbb" 。 
> 来源：[https://leetcode.cn/problems/longest-palindromic-subsequence](https://leetcode.cn/problems/longest-palindromic-subsequence)

#### 代码实现
```javascript

function longestPalindromeSubseq(s: string): number {
  // Think for yourself for 5 minutes...
  // dp[i][j] 表示[i,j]区间最长回文子序列的长度
  // 如果s[i]等于s[j]  那么dp[i][j] = dp[i+1][j-1] + 2
  // 如果不相等 a. 加入s[i]的回文子序列长度 dp[i+1][j] b. 加入s[j]的回文子序列长度 d[i][j-1]
  // 遍历顺序是 从下往上，从左到右，因此右上角才是答案
  // 有递推公式 dp[i][j] = dp[i+1][j-1] + 2 可知，[i][j]位置是有赖于[i-1]和[j-1]的，因此遍历需确保两者>=0
  // 因此内层j从i+1开始

  const n: number = s.length
  const dp: number[][] = Array.from(Array(n), () => Array(n).fill(0))

  // 当i==j时 s[i]===s[j] 等于1 ，对应矩阵斜角线
  for (let i = 0; i < n; i++) dp[i][i] = 1

  for (let i = n - 1; i >= 0; i--) {
    for (let j = i + 1; j < n; j++) {
      if (s[i] === s[j]) {
        dp[i][j] = dp[i + 1][j - 1] + 2
      } else {
        dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])
      }
    }
  }

  return dp[0][n - 1]
}
```
### ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679204002760-e099f05e-7977-45ce-b7d3-0cf33b37e85b.png#averageHue=%23f2f2f2&clientId=u5e0a65b7-c99a-4&from=paste&height=470&id=u104d6f98&name=image.png&originHeight=884&originWidth=1128&originalType=binary&ratio=2&rotation=0&showTitle=false&size=173457&status=done&style=none&taskId=u9add5545-b13e-469c-b455-003cf2b555a&title=&width=600)
### 最长回文子串
[算法:字符串](https://www.yuque.com/vannvan/tools/qol7oyuzgic6thgi?view=doc_embed&inner=BtZkh)
### 矩阵链相乘
#### 推导过程
##### 矩阵扫盲
一个p*q的矩阵A和一个q*r的矩阵B的乘积是一个新的p*r的矩阵C，计算公式如下：其中1<=i<=p并且1<=j<=r。
ps:(扫盲->只有在第一个矩阵的列数（column）和第二个矩阵的行数（row）相同时才有意义)。
定义：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677300286762-0d1d1fdf-d5ff-4f36-a507-e9fe3fc64946.png#averageHue=%23f9f9f9&clientId=u2db308b2-e67b-4&from=paste&height=405&id=u61d263d0&name=image.png&originHeight=810&originWidth=1632&originalType=binary&ratio=2&rotation=0&showTitle=false&size=120236&status=done&style=none&taskId=u687b2704-698f-4203-bb75-4b0c4684205&title=&width=816)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677294034544-aa95af5c-ddc7-4890-836a-62567e698915.png#averageHue=%23fef4f4&clientId=u2db308b2-e67b-4&from=paste&height=160&id=udfaf279f&name=image.png&originHeight=384&originWidth=1436&originalType=binary&ratio=2&rotation=0&showTitle=false&size=111441&status=done&style=none&taskId=u62e2ccb2-c79c-44c9-87d5-99eb0a31096&title=&width=600)
示例：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677296029551-61148a51-dc3c-419d-bacc-2de0e38cab74.png#averageHue=%23fbfbfb&clientId=u2db308b2-e67b-4&from=paste&height=228&id=u3b42d3e5&name=image.png&originHeight=776&originWidth=2038&originalType=binary&ratio=2&rotation=0&showTitle=false&size=74169&status=done&style=none&taskId=ucc030a10-7881-47d1-9340-2bb1981d13e&title=&width=600)
A(3*3)和B(2*3)得到规模为2*3的矩阵C
##### 矩阵链
对于Ai..j的任何一个计算顺序，我们都可以把它拆分成下面两个计算步骤
step1: Ai...j  = Ai...kAk + 1...j   (举例:对于A1,A2,A3矩阵来说，可以为(A1A2)A3或A1(A2A3)两种计算方式，k的位置就是括号的位置 )
此时的关键点就是这个k的值，即应该在哪一个地方利用“括号”把序列划分成两个子序列。
step2: 如果Ai...k 和Ak+1...j  都是使用最优序列计算的，那么存在m[i,j]即Ai...j的最少乘积计算次数为：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677303458667-1313e4c1-e83e-40a4-a63f-aa976be2cac4.png#averageHue=%23f4f4f4&clientId=u2db308b2-e67b-4&from=paste&height=109&id=uf9f127c6&name=image.png&originHeight=434&originWidth=2390&originalType=binary&ratio=2&rotation=0&showTitle=false&size=102903&status=done&style=none&taskId=u611e7966-85b6-4ddd-8aa8-11233e87ba4&title=&width=600)

以上公式的含义是，根据我们前面的定义，Ai...k的乘积结果为一个规模为Pi-1*Pk的矩阵，而Ak+1....Aj的乘积结果为一个规模为Pk*Pj的矩阵，所以，求Ai...j的最少乘积次数则为【Ai...k所需要的最少乘积次数】+【Ai+1...j所需要的最少乘积次数】+【中间生成的两个临时矩阵所需要的乘积次数】。

递推公式
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677303547346-de5c94af-7a14-47dc-8caa-e763cb0faef5.png#averageHue=%23f6f6f6&clientId=u2db308b2-e67b-4&from=paste&height=77&id=u31b0793b&name=image.png&originHeight=308&originWidth=2414&originalType=binary&ratio=2&rotation=0&showTitle=false&size=88449&status=done&style=none&taskId=ufc24db09-eb23-4e9b-ad09-0167c044f99&title=&width=600)

一个比较好理解的计算过程图
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677303672164-509b7a35-af93-47f9-9088-586448e13d20.png#averageHue=%23cfdece&clientId=u2db308b2-e67b-4&from=paste&height=258&id=ue7b40dc3&name=image.png&originHeight=1072&originWidth=2492&originalType=binary&ratio=2&rotation=0&showTitle=false&size=700157&status=done&style=none&taskId=u8beb3004-b5e1-4279-86c3-e7633f1365f&title=&width=600)
次序
1,2 -> 2,3 -> 3,4 -> 4,5 -> 5,6
1,3 -> 2,4 -> 3,5 -> 4,6
1,4 -> 2,5 -> 3,6
1,5 -> 2,6
1,6
#### 
代码实现
##### 返回数量
```javascript

const minMatrixChainMultiTimes = (p: number[]): number => {
  const { length } = p
  // 最优次数二维矩阵
  const m: number[][] = []

  const s: number[][] = []

  // 对角线填充为0
  for (let i = 1; i <= length; i++) {
    m[i] = []
    m[i][i] = 0
  }

  for (let i = 0; i <= length; i++) {
    s[i] = []
    for (let j = 0; j <= length; j++) {
      s[i][j] = 0
    }
  }

  for (let x = 2; x <= length; x++) {
    // 从dp[1][2] 开始算,因为只用算对角线右上方的，因此length - x + 1
    for (let i = 1; i <= length - x + 1; i++) {
      const j = i + x - 1
      m[i][j] = Number.MAX_SAFE_INTEGER
      for (let k = 0; k <= j - 1; k++) {
        const q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]
        console.log('i,j', i, j)
        if (q < m[i][j]) {
          m[i][j] = q
          s[i][j] = k
        }
      }
    }
  }
	// const bestMethod = getBestMethod(s, 1, length - 1, '')
  // console.log('bestMethod', bestMethod)   // ([A1]([A2]([A3][A4])))
  return m[1][length - 1]
}
```
##### 返回结果
```javascript

/**
 * 最佳矩阵相乘组合方式
 * @param s 完整矩阵
 * @param i
 * @param j
 * @param str
 * @returns
 */
const getBestMethod = (s: number[][], i: number, j: number, str: string) => {
  if (i == j) {
    // console.log(`[A${i}]`)
    str += `[A${i}]`
  } else {
    // console.log('(')
    let a = '(' + getBestMethod(s, i, s[i][j], str)
    let b = getBestMethod(s, s[i][j] + 1, j, str) + ')'
    // console.log(')')
    str = str + a + b
  }
  return str
}
```
## 👉总结归纳
### 梳理
一般当题解中涉及“最”值的计算，那么可能可以考虑一下动态规划的思路。
**最优子结构性质再理解**
例如：在硬币找零实现过程中，其实是在逐步找每个amount范围内的金额的找钱方法，“子问题最优解”即1,2,3,...n个金额的最优解，因此对于amount而言，在这些子问题中必然存在可以构成其达成最优解的方法，将dp中存储的子问题解直接取出不用再计算就是规划的意义之一；在切绳子的实现过程中，也是在逐步找n长度范围内的子问题最优解，需要注意的是，切绳子的结果分为“切点”两端的“子问题”，而对于“切点”之后的问题，在“切点”之前已经找过了，因此需要控制计算dp[i]的范围为当前长度的一半即可。

**子问题重叠性质再理解**
例如：在硬币找零过程中，以找16元为例，前面已计算出了1，2，3，... 15元的找钱方式，16元可以是他本身减去一个金额之后+dp[小于16的数]的结果，而无需再依次计算他的子问题。

**无后效性再理解**
例如：在最长递增序列求解过程中，当确定了以i位置为基准的最长序列之后，之后求解i+1,i+2...n-1位置的最长序列都不会再影响i位置的结果。

在预计可能可以采用动态规划解题之前，要先尝试带入具体值是否满足以上三个性质，再进行归纳确定字结构求解的具体方案，确定max或min迭代更新的条件，从而更新dp[i]。

### 技巧
构造数组,在不属于题目主要考察范围的情况下使用
```typescript
const dp: number[] = new Array(n).fill(0) // 一维
const dp: number[][] = new Array(m).fill(0).map(() => new Array(n).fill(0)) // 二维
const dp: number[][] = Array.from(Array(m), () => Array(n).fill(0))  // 二维
```

## 资料
找零钱
[点击查看【bilibili】](https://player.bilibili.com/player.html?bvid=BV1cT4y1w7Ct)

示例切绳子过程很清晰

背包问题
[点击查看【bilibili】](https://player.bilibili.com/player.html?bvid=BV1K4411X766)
[点击查看【bilibili】](https://player.bilibili.com/player.html?bvid=BV1g7411B7SP)


[点击查看【bilibili】](https://player.bilibili.com/player.html?bvid=BV1XY4y1w7EN)

