# 算法:数组 
## 题型详解
### 二分查找
#### 查找元素
> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
> 来源：[https://leetcode.cn/problems/binary-search](https://leetcode.cn/problems/binary-search)

[算法:双指针](https://www.yuque.com/vannvan/tools/ta0fig2nzk9vfwnm?view=doc_embed&inner=ylHPF)
#### 在排序数组中查找元素的第一个和最后一个位置
> 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
> 如果数组中不存在目标值 target，返回 [-1, -1]。
> 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。
> 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4]
> 来源：[https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```javascript
function getBorder(nums: number[], target: number, type: 'left' | 'right') {
  let left = 0
  let right = nums.length - 1
  let border = -1

  while (left <= right) {
    let mid = Math.floor(left + (right - left) / 2)
    if (nums[mid] > target) {
      right = mid - 1
    } else if (nums[mid] < target) {
      left = mid + 1
    } else {
      if (type === 'left') {
        right = mid - 1
      } else {
        left = mid + 1
      }
      border = mid
    }
  }

  return border
}

function searchRange(nums: number[], target: number): number[] {
  // Think for yourself for 5 minutes...
  let leftBorder = getBorder(nums, target, 'left')
  let rightBorder = getBorder(nums, target, 'right')
  return [leftBorder, rightBorder]
}
```
### 有序数组的平方-双向指针
> 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
> 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]
> 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]
> 来源：[https://leetcode.cn/problems/squares-of-a-sorted-array/](https://leetcode.cn/problems/squares-of-a-sorted-array/)

```javascript
/**
 * 有序数组的平方
 * 返回有序数组
 * @param nums
 * @returns
 */
const sortedSquares = (nums: number[]):number[] => {
  let k = nums.length - 1
  let result: number[] = []
  for (let left = 0, right = nums.length - 1; left <= right; ) {
    // 如果右边更大，把较大的放到尾部，右边往左移
    if (nums[left] * nums[left] < nums[right] * nums[right]) {
      result[k] = nums[right] * nums[right]
      k--
      right--
    } else {
      result[k] = nums[left] * nums[left]
      k--
      left++
    }
  }
  return result
}
```
### 长度最小的子数组-滑动窗口
> 给定一个含有 n 个正整数的数组和一个正整数 target 。
> 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
> 输入：target = 7, nums = [2,3,1,2,4,3]   输出：2 
> 解释：子数组 [4,3] 是该条件下的长度最小的子数组。
> 来源：[https://leetcode.cn/problems/minimum-size-subarray-sum](https://leetcode.cn/problems/minimum-size-subarray-sum)

```javascript
function minSubArrayLen(target: number, nums: number[]): number {
  let result = Number.MAX_SAFE_INTEGER
  let sublen = 0
  let sum = 0
  let startIndex = 0 // 滑动窗口起始位置
  for (let i = 0; i < nums.length; i++) {
    sum += nums[i]
    while (sum >= target) {
      sublen = i - startIndex + 1 // 当前子序列长度
      result = result > sublen ? sublen : result  // 更新当前最小结果
      // sum -= nums[startIndex++] // 此时是已经找到了一个子数组了，需要将前前一位减去开始往后面移动
      // 更好理解的写法
      sum = sum - nums[startIndex] // 减去当前
      startIndex++ // 左指针开始往后移
    }
  }
  return result === Number.MAX_SAFE_INTEGER ? 0 : result
}

/**
 * 另一种写法
 * @param target 
 * @param nums 
 * @returns 
 */
function minSubArrayLen2(target: number, nums: number[]): number {
  let result = Number.MAX_SAFE_INTEGER
  let start = 0
  let end = 0
  let sum = 0
  while (end < target) {
    sum += nums[end]
    // 当找到一组子数组后，继续往后面走
    while (sum >= target) {
      result = Math.min(result, end - start + 1) // 更新当前最小结果
      sum -= nums[start]
      start++
    }
    end++
  }

  return result === Number.MAX_SAFE_INTEGER ? 0 : result
}
```
每一轮迭代，将num[end]加到sum，如果sum>=target，则更新子数组长度(此时长度是end-start+1),然后将num[start]从sum中减去并将start右移，直到sum<s,在此过程中同样更新子数组的最小长度，在每一轮迭代的最后，将end右移。
### 水果成篮-滑动窗口
> 来源：[https://leetcode.cn/problems/fruit-into-baskets/](https://leetcode.cn/problems/fruit-into-baskets/)

#### 代码实现
```javascript

const totalFruit = (fruits: number[]): number => {
  let res = 0
  let map = new Map()
  let startIndex = 0
  for (let right = 0; right < fruits.length; ++right) {
    map.set(fruits[right], (map.get(fruits[right]) || 0) + 1)
    //如果哈希表大小大于2，那就移动startIndex将fruits[startIndex]从哈希表中移除，直到满足要求为止
    while (map.size > 2) {
      map.set(fruits[startIndex], map.get(fruits[startIndex]) - 1)
      if (map.get(fruits[startIndex]) == 0) {
        map.delete(fruits[startIndex])
      }
      startIndex++
    }

    res = Math.max(res, right - startIndex + 1)
  }
  return res
}
```
#### 类似例题
滑动窗口
[算法:滑动窗口](https://www.yuque.com/vannvan/tools/hbhzmfmoxigpndxx?view=doc_embed&inner=nsqS6)

### 螺旋矩阵II-模拟，找边界
> 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
> 示例:
> 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]
> 来源：[https://leetcode.cn/problems/spiral-matrix-ii/](https://leetcode.cn/problems/spiral-matrix-ii/)

#### 代码实现
```javascript

/**
 * 生成螺旋矩阵
 * eg: n=3
 * @param n
 */
const generateMatrix = (n: number): number[][] => {
  let res: number[][] = new Array(n).fill(0).map(() => new Array(n).fill(0))
  let l = 0 // 左
  let r = n - 1 // 右
  let t = 0 // 上
  let b = n - 1 // 下
  let num = 1
  const limit = n * n
  while (num <= limit) {
    for (let i = l; i <= r; i++) res[t][i] = num++ // 从左到右，最后上边界下移,，因为水平方向不动即res[t],i递增，然后t++ 
    t++
    for (let i = t; i <= b; i++) res[i][r] = num++ // 从上到下，最后右边界左移 r--
    r--
    for (let i = r; i >= l; i--) res[b][i] = num++ // 从右到左，最后下边界上移 b--
    b--
    for (let i = b; i >= t; i--) res[i][l] = num++ // 从下到上，最后左边界右移，l++
    l++
  }
  return res
}

```
#### 类似一题
> 给你一个 m 行 n 列的矩阵 matrix ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677498840762-b71052f6-fcff-4a47-872c-86b349c4c95d.png#averageHue=%23e1e1e1&clientId=ua3a2937d-d250-4&from=paste&height=121&id=u27aa88a0&name=image.png&originHeight=242&originWidth=242&originalType=binary&ratio=2&rotation=0&showTitle=false&size=19244&status=done&style=none&taskId=u8579a3b3-c209-4788-b8fc-6661eb38441&title=&width=121)
> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 
> 输出：[1,2,3,6,9,8,7,4,5]
> 来源：[https://leetcode.cn/problems/spiral-matrix/](https://leetcode.cn/problems/spiral-matrix/)

```javascript
const spiralOrder = (matrix: number[][]): number[] => {
  let res: number[] = []
  let l = -1 // 左，注意这里，下面一开始++l 才为0
  let t = 0 // 上
  let b = matrix.length - 1 // 下
  let r = matrix[0].length - 1 // 右

  console.log(t, r, b, l)

  while (t <= b && l <= r) {
    if (++l > r) break
    for (let i = l; i <= r; i++) res.push(matrix[t][i]) // 左到右
    if (++t > b) break
    for (let i = t; i <= b; i++) res.push(matrix[i][r]) // 上到下
    if (--r < l) break
    for (let i = r; i >= l; i--) res.push(matrix[b][i]) // 右到左
    if (--b < t) break
    for (let i = b; i >= t; i--) res.push(matrix[i][l]) // 下到上
  }
  return res
}

// 用例
const source = [
      [1, 2, 3],
      [8, 9, 4],
      [7, 6, 5],
    ]

const source2 = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
]

const source3 = [
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9, 10, 11, 12],
]

const source4 = [[3], [2], [1]]

const target = [1, 2, 3, 4, 5, 6, 7, 8, 9]
const target2 = [1, 2, 3, 6, 9, 8, 7, 4, 5]
const target3 = [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]
const target4 = [3, 2, 1]

expect(spiralOrder(source)).toEqual(target)
expect(spiralOrder(source2)).toEqual(target2)
expect(spiralOrder(source4)).toEqual(target4)

```
### ⭐️合并两个有序数组-双指针
> 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
> 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
> 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
> 输出：[1,2,2,3,5,6]
> 解释：需要合并 [1,2,3] 和 [2,5,6] 。
> 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
> 来源：[https://leetcode.cn/problems/merge-sorted-array/](https://leetcode.cn/problems/merge-sorted-array/)

#### 代码实现
```javascript
const mergeArray = (nums1: number[], m: number, nums2: number[], n: number): void => {
  let sorted = new Array(m + n).fill(0)
  let p1 = 0
  let p2 = 0
  let cur = 0
  while (p1 < m || p2 < n) {
    // 不行
    // if (nums1[p1] < nums2[p2]) {
    //   cur = nums1[p1++]
    // } else if (m === p1) {
    //   //
    //   cur = nums2[p2++]
    // } else if (n === p2) {
    //   cur = nums1[p1++]
    //   // p1++
    // } else {
    //   console.log('cur', cur)

    //   cur = nums2[p2++]
    // }
    if (p1 === m) {
      cur = nums2[p2++]
    } else if (p2 === n) {
      cur = nums1[p1++]
    } else if (nums1[p1] < nums2[p2]) {
      cur = nums1[p1++]
    } else {
      cur = nums2[p2++]
    }

    console.log('cur', cur)

    sorted[p1 + p2 - 1] = cur
  }
  for (let i = 0; i < sorted.length; i++) {
    nums1[i] = sorted[i]
  }
  console.log('sorted', sorted)
  console.log('nums1', nums1)
}
```
#### 类似题

- 
### 加一-单向指针
> 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
> 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
> 你可以假设除了整数 0 之外，这个整数不会以零开头。
> 来源：[https://leetcode.cn/problems/plus-one/](https://leetcode.cn/problems/plus-one/)

#### 代码实现
```javascript

const plusOne = (digits: number[]): number[] => {
  let { length } = digits

  let last = length - 1

  while (last >= 0) {
    if (digits[last] == 9) {
      // 向左移动，当前位值变成-
      digits[last] = 0
      last--
    }
    if (digits[last] < 9) {
      digits[last]++
      return digits
    }
  }

  // 只有全是9的情况会走到这里
  let a = new Array(digits.length + 1).fill(0)
  a[0] = 1
  return a
}
// 用例
expect(plusOne([9])).toEqual([1, 0])
expect(plusOne([9, 9])).toEqual([1, 0, 0])
expect(plusOne([1, 2, 3])).toEqual([1, 2, 4])
expect(plusOne([1])).toEqual([2])
expect(plusOne([0])).toEqual([1])
expect(plusOne([1, 9])).toEqual([2, 0])
expect(plusOne([1, 9, 9])).toEqual([2, 0, 0])
expect(plusOne([1, 9, 9, 9])).toEqual([2, 0, 0, 0])
```
### 滑动窗口最大值
> 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回 滑动窗口中的最大值 。
> 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
> 输出：[3,3,5,5,6,7]
> 解释：
> 滑动窗口的位置                最大值
> ---------------               -----
> [1  3  -1] -3  5  3  6  7       3
>  1 [3  -1  -3] 5  3  6  7       3
>  1  3 [-1  -3  5] 3  6  7       5
>  1  3  -1 [-3  5  3] 6  7       5
>  1  3  -1  -3 [5  3  6] 7       6
>  1  3  -1  -3  5 [3  6  7]      7
> 来源：[https://leetcode.cn/problems/sliding-window-maximum/](https://leetcode.cn/problems/sliding-window-maximum/)

#### 代码实现
```javascript
function maxSlidingWindow(nums: number[], k: number): number[] {
  class Queue {
    items: number[]
    constructor() {
      this.items = []
    }

    enQueue(value: number) {
      let back = this.items[this.items.length - 1]
      // 如果新来的比之前的都大，把之前的干掉
      while (back != undefined && back < value) {
        this.items.pop()
        back = this.items[this.items.length - 1]
      }
      this.items.push(value)
    }

    deQueue(value: number) {
      let front = this.items[0]
      if (value == front) {
        this.items.shift() // 取队列头部
      }
    }

    front() {
      return this.items[0]
    }
  }

  let helperQueue = new Queue()
  let i = 0
  let j = 0
  let resArr: number[] = []
  // 先把第一组滑动窗口的内容放进去
  while (j < k) {
    helperQueue.enQueue(nums[j++])
  }
  // 拿到第一组的最大值
  resArr.push(helperQueue.front())

  // 接下来要开始滑动了
  while (j < nums.length) {
    helperQueue.enQueue(nums[j])  // 进
    helperQueue.deQueue(nums[i]) // 出
    resArr.push(helperQueue.front())
    i++
    j++
  }

  return resArr
}
```
以 nums: 1, 3, -1, -3, 5, 3, 6, 7  k:3为例
构造一个单调队列，每次来都将最大的放到前面，当新插入值比前面都大就将小鱼该值的元素都干掉，确保队列头部的只永远都是最大值
结合动画
先将0-k范围的第一组放进去并拿到最大值，放进结果数组，开始滑动窗口，先进去一个，再出来一个，拿到最大值，向后移动

### 前 K 个高频元素
> 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 **任意顺序** 返回答案。
> 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2]
> 你所设计算法的时间复杂度 **必须** 优于 O(n log n) ，其中 n_ _是数组大小。
> 来源：[https://leetcode.cn/problems/top-k-frequent-elements/](https://leetcode.cn/problems/top-k-frequent-elements/)

#### 代码实现
```javascript

class Heap {
  compareFn: any
  queue: any[]
  constructor(compareFn) {
    this.compareFn = compareFn
    this.queue = []
  }

  // 添加
  push(item: any) {
    // 推入元素
    this.queue.push(item)

    // 上浮
    let index = this.size() - 1 // 记录推入元素下标
    let parent = Math.floor((index - 1) / 2) // 记录父节点下标

    while (parent >= 0 && this.compare(parent, index) > 0) {
      // 注意compare参数顺序
      ;[this.queue[index], this.queue[parent]] = [this.queue[parent], this.queue[index]]

      // 更新下标
      index = parent
      parent = Math.floor((index - 1) / 2)
    }
  }

  // 获取堆顶元素并移除
  pop() {
    // 堆顶元素
    const out = this.queue[0]

    // 移除堆顶元素 填入最后一个元素
    this.queue[0] = this.queue.pop() as number

    // 下沉
    let index = 0 // 记录下沉元素下标
    let left = 1 // left 是左子节点下标 left + 1 则是右子节点下标
    let searchChild = this.compare(left, left + 1) > 0 ? left + 1 : left

    while (searchChild !== undefined && this.compare(index, searchChild) > 0) {
      // 注意compare参数顺序
      ;[this.queue[index], this.queue[searchChild]] = [this.queue[searchChild], this.queue[index]]

      // 更新下标
      index = searchChild
      left = 2 * index + 1
      searchChild = this.compare(left, left + 1) > 0 ? left + 1 : left
    }

    return out
  }

  size() {
    return this.queue.length
  }

  // 使用传入的 compareFn 比较两个位置的元素
  compare(index1: number, index2: number) {
    // 处理下标越界问题
    if (this.queue[index1] === undefined) return 1
    if (this.queue[index2] === undefined) return -1

    return this.compareFn(this.queue[index1], this.queue[index2])
  }
}

function topKFrequent(nums: number[], k: number): number[] {
  let map: Map<number, number> = new Map()

  for (let i = 0; i < nums.length; i++) {
    map.set(nums[i], (map.get(nums[i]) || 0) + 1)
  }

  const helperHeap = new Heap((a, b) => a[1] - b[1])

  for (const entry of map.entries()) {
    helperHeap.push(entry)
    if (helperHeap.size() > k) {
      helperHeap.pop() // 堆顶是频次较小的不要
    }
  }

  const res: number[] = []

  for (let i = helperHeap.size() - 1; i >= 0; i--) {
    res[i] = helperHeap.pop()[0] 
  }
  // console.log('helperHeap', helperHeap)

  return res
}
```
理解题意
> nums: [1, 1, 1, 2, 2, 3] k: 2 为例 1的频次3 2的频次2 3的频次1  前2个高频即需要按频次将 1 2 3这三个元素排序，且拿出前2个
> 构造map  {1:3},{2:2},{3:1} => 需要的map顺序是{1:3},{2:2},{3:1}  取出前2个，即只能取1,2
> nums: [1,2,3,3,2,2,1,3,3] k: 2为例 1的频次2 2的频次3 3的频次4 
> 构造map {1:2},{2:3},{3:4} => 需要的map顺序是{3:4},{2:3},{1:2}  去除前2个，即只能取3,2

可以看出，根据map我们可以很容易记录每个元素出现的频次，采用不考虑时间复杂度限制(O(n log n))的方法我们只需生成map，再根据map中的value值大小获取原始元素的顺序，再截取前k个元素。
但若考虑时间复杂度就需要采用更高阶的方法，以降低时间复杂度，将map中的key和value存放于小顶堆中，因此在记录遍历完nums中的所有元素之后，分以下两个步骤
step1：因为我们的map未经过排序，需要先将所有元素推入小顶堆中让其排序，在这个过程当中控制heap的size小于等于k，因此有如下动作：
```javascript
helperHeap.push(entry)
if (helperHeap.size() > k) {
  helperHeap.pop() // 堆顶是频次较小的不要
}
// 这里完成的就是既控制了heap的size在k范围内，也确保了heap中存放的是频次较大的map元素
```
step2：此时已经获取到前k个高频元素了，依次从堆顶将原始元素放入结果数组：
```javascript
for (let i = helperHeap.size() - 1; i >= 0; i--) {
  res[i] = helperHeap.pop()[0] 
}
// 此处是从后往前放，结果是频次高的在前面
```
#### 完整堆实现->见
上述的方法改用采用MinHeap只需要调整compare方法即可
调整为
```javascript
compare(a, b) {
  if (!a || !b) return false
  return a[1] >= b[1]
}
```
[数据结构:二叉堆](https://www.yuque.com/vannvan/tools/vmsg2vy8qyv3w266?view=doc_embed&inner=IVi4n)

### ⭐️轮转数组
> 给定一个整数数组 nums，将数组中的元素向右轮转 k_ _个位置，其中 k_ _是非负数。
> 输入: nums = [1,2,3,4,5,6,7], k = 3    输出: [5,6,7,1,2,3,4]
> 解释:
> 向右轮转 1 步: [7,1,2,3,4,5,6]
> 向右轮转 2 步: [6,7,1,2,3,4,5]
> 向右轮转 3 步: [5,6,7,1,2,3,4]
> 来源：[https://leetcode.cn/problems/rotate-array/](https://leetcode.cn/problems/rotate-array/)

相关题目：[算法:字符串-左旋字符串](https://www.yuque.com/vannvan/tools/qol7oyuzgic6thgi#K5p2n)
#### 代码实现
原题不用返回
```typescript
function rotate(nums: number[], k: number): number[] {
  const n = nums.length
  const newArr = new Array(n)
  for (let i = 0; i < n; ++i) {
    newArr[(i + k) % n] = nums[i]
  }
  for (let i = 0; i < n; ++i) {
    nums[i] = newArr[i]
  }

  return nums
}


function rotate(nums: number[], k: number): number[] {
  const reverse = (nums: number[], start: number, end: number) => {
    while (start < end) {
      let tmp = nums[start]
      nums[start] = nums[end]
      nums[end] = tmp
      start++
      end--
    }
  }

  k %= nums.length

  // 先翻转全部
  reverse(nums, 0, nums.length - 1)

  // 反转前半部份
  reverse(nums, 0, k - 1)

  // 反转后半部份
  reverse(nums, k, nums.length - 1)

  return nums
}

```
第二种方法的过程
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679495948013-77c9b6b9-5545-4e57-a373-604208e130a5.png#averageHue=%23f6f6f6&clientId=u9fc4cecb-1657-4&from=paste&height=168&id=u29b7eb64&name=image.png&originHeight=448&originWidth=1598&originalType=binary&ratio=2&rotation=0&showTitle=false&size=57325&status=done&style=none&taskId=ucc87e244-8443-444e-ab7f-84101556182&title=&width=600)
### 寻找数组的中心下标
> 给你一个整数数组 nums ，请计算数组的 中心下标 。
> 数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
> 如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
> 如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 
> 输入：nums = [1, 7, 3, 6, 5, 6]
> 输出：3
> 解释：
> 中心下标是 3 。
> 左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
> 右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
> 来源：[https://leetcode.cn/problems/find-pivot-index](https://leetcode.cn/problems/find-pivot-index)

#### 代码实现
```typescript
function pivotIndex(nums: number[]): number {
  const total = nums.reduce((a, b) => a + b, 0)
  let sum = 0

  // 当遍历到i元素时，设其左侧为sum ，则其右侧为 total-nums[i]-sum 即s*sum+numssi=total
  for (let i = 0; i < nums.length; i++) {
    // if (2 * sum + nums[i] == total) {
    //   return i
    // }
    // sum += nums[i]

    sum += nums[i]
    if (total - sum === sum - nums[i]) return i
  }

  return -1
}


// 容易理解的版本
function pivotIndex(nums: number[]): number {
  const length: number = nums.length
  const sum: number = nums.reduce((a, b) => a + b)
  let leftSum: number = 0
  for (let i = 0; i < length; i++) 
    // rightSum 含义是剩余数字的和
    const rightSum: number = sum - leftSum - nums[i]
    if (leftSum === rightSum) return i
    leftSum += nums[i]
  	// 细品上下两种写法的区别
    // leftSum += nums[i];
    // rightSum = sum - leftSum + nums[i];// leftSum 里面已经有 nums[i]，多减了一次，所以加上
    // if(leftSum === rightSum) return i;
  }
  return -1
}
```

## 资料

