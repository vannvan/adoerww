# 算法:数学 
## 例题
### 阶乘后的零
> 给定一个整数 n ，返回 n! 结果中**尾随零的数量。**
> 提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1
> 输入：n = 3 输出：0 解释：3! = 6 ，不含尾随 0
> 来源：[https://leetcode.cn/problems/factorial-trailing-zeroes/](https://leetcode.cn/problems/factorial-trailing-zeroes/)

```javascript
function trailingZeroes(n: number): number {
  // Think for yourself for 5 minutes...
  let ans: number = 0

  let divisor: number = 5
  while (divisor <= n) {
    ans += Math.floor(n / divisor)

    divisor *= 5
  }

  return ans
}
```
思路分析，要满足末尾有0，肯定要有相乘后可以有0的因子，2*5=10 => 因为每个偶数都具备提供2，因此取决于有多少个5
以25为例， 5 可以提供一个，10 可以提供一个，15 可以提供一个，20 可以提供一个，25 可以提供两个，总共有 6 个因子 5，所以 25! 的结果末尾就有 6 个 0。
### 计数质数
> 给定整数 n ，返回 _所有**小于非负整数 ****n**** 的质数的数量**_** 。**
> 输入：n = 10 输出：4 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
> 来源：[https://leetcode.cn/problems/count-primes/](https://leetcode.cn/problems/count-primes/)

#### 代码实现
```javascript
function countPrimes(n: number): number {
  // Think for yourself for 5 minutes...
  // q1.小于n的质数

  let ans: number = 0

  const isPrime = new Array(n).fill(true)

  for (let i = 2; i < n; i++) {
    if (isPrime[i]) {
      ans += 1
      for (let j = i * i; j < n; j += i) {
        isPrime[j] = false
      }
    }
  }
  return ans
}
```
如果x是质数，那么2x,3x,....nx一定不是质数，设isPrime[i]表示i不是质数，如果是质数则为true，否则为0，从小到大遍历每个数，如果这个数为质数，就将其所有倍数都标记为合数=>false
### 超级次方
> 你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。
> 输入：a = 2, b = [3] 输出：8
> 输入：a = 2147483647, b = [2,0,0] 输出：1198
> 来源：[https://leetcode.cn/problems/super-pow/](https://leetcode.cn/problems/super-pow/)

#### 代码实现
```javascript
const pow = (a: number, k: number) => {
  const base = 1337
  // 对因子求模
  a %= base
  let res = 1
  for (let i = 0; i < k; i++) {
    // 这里有乘法，是潜在的溢出点
    res *= a
    // 对乘法结果求模
    res %= base
  }
  return res
}

function superPow(a: number, b: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. 考虑如何快速通过数组b计算 次方
  // q2. 考虑如何取模不会溢出
  const base = 1337
  if (b.length === 0) return 1
  const last = b.pop()
  const part1 = pow(a, last)
  const part2 = pow(superPow(a, b), 10)
  // 每次乘法都要求模
  return (part1 * part2) % base
}
```
思路分析
以a=99 b=[2,3,4,5]为例

1. 992345=99234∗10+5
2. 99234∗10+5=99234∗10∗995
3. 99234∗10∗995=(99234)10∗995
### ⭐️N字型变换
> 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。
> 比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：
> 来源：[https://leetcode.cn/problems/zigzag-conversion](https://leetcode.cn/problems/zigzag-conversion)

#### 代码实现
```javascript
function convert(s: string, numRows: number): string {
  // Think for yourself for 5 minutes...
  // q1. 一个完整的N字型需要 2*numRow-(numRows-2)个字母
  // q2. 构造过程：当向下时需要r个字符，再向上时需要r-2个字符，然后再回到第一行，因此N字型变换周期是t=2r-2
  // 每个周期会占用矩阵上的1+r-2=r-1列，因此有n/t个周期，矩阵的列数为r-1行
  // q3. 模拟填充二维矩阵

  const n = s.length
  const r = numRows
  if (r === 1 || r >= n) {
    return s
  }

  const t = r * 2 - 2

  const c = Math.floor((n + t - 1) / t) * (r - 1)

  const mat = new Array(r).fill(0).map(() => new Array(c).fill(0))

  for (let i = 0, x = 0, y = 0; i < n; ++i) {
    mat[x][y] = s[i]
    if (i % t < r - 1) {
      ++x // 向下移动
    } else {
      --x
      ++y // 向右上移动
    }
  }

  const ans: string[] = []
  
  for (const row of mat) {
    for (const ch of row) {
      if (ch !== 0) {
        ans.push(ch)
      }
    }
  }
  return ans.join('')
}
```
### 逆波兰表达式
> 给你一个字符串数组 tokens ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437) 表示的算术表达式。
> 请你计算该表达式。返回一个表示表达式值的整数。
> 输入：tokens = ["2","1","+","3","*"] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
> 来源：[https://leetcode.cn/problems/evaluate-reverse-polish-notation/](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

#### 代码实现
```javascript
function evalRPN(tokens: string[]): number {
  // Think for yourself for 5 minutes...

  const stack: number[] = []

  for (const val of tokens) {
    if (isNaN(Number(val))) {
      // 非数字
      // ⚠️先出栈的是右操作数，后出栈的是左操作数
      const num2 = stack.pop()
      const num1 = stack.pop()
      switch (val) {
        case '+':
          stack.push(num1 + num2)
          break
        case '-':
          stack.push(num1 - num2)
          break
        case '*':
          stack.push(num1 * num2)
          break
        case '/':
          stack.push((num1 / num2) | 0)
          break
      }
    } else {
      stack.push(Number(val))
    }
  }

  return stack.pop()
}
```
### 直线上最多的点数
> 给你一个数组 points ，其中 points[i] = [xi, yi] 表示 **X-Y** 平面上的一个点。求最多有多少个点在同一条直线上。
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679752849047-e1bf2c5d-c4c5-47ef-9572-5df7e410b2a0.png#averageHue=%23fcfcfc&clientId=u2b15dde2-a008-4&from=paste&height=277&id=u9ab03877&name=image.png&originHeight=810&originWidth=876&originalType=binary&ratio=2&rotation=0&showTitle=false&size=42556&status=done&style=none&taskId=ubd9faceb-e518-441c-8206-1d1a1902af7&title=&width=300)
> 来源：[https://leetcode.cn/problems/max-points-on-a-line/](https://leetcode.cn/problems/max-points-on-a-line/)

#### 代码实现
```javascript
function maxPoints(points: number[][]): number {
  // Think for yourself for 5 minutes...
  // q1. 两点确定一条线
  // q2. 由于直接计算斜率可能会因为精度丢失导致计算不准确，因此借助第三个点
  // 由 k 确定的点判断 s1和s2相对于这个点的斜率是否相同
  const n = points.length

  let ans = 1 // 最次也有一个点，所以初始化为1
  
  for (let i = 0; i < n; i++) {
    let x = points[i]
    for (let j = i + 1; j < n; j++) {
      let y = points[j]
      let count = 2
      for (let k = j + 1; k < n; k++) {
        let p = points[k]
        let s1 = (y[1] - x[1]) * (p[0] - y[0])
        let s2 = (p[1] - y[1]) * (y[0] - x[0])
        if (s1 === s2) count++
      }
      ans = Math.max(count, ans)
    }
  }

  return ans
}
```
### 有效的完全平方数
> 给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。
> 完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。
> 不能使用任何内置的库函数，如  sqrt 。
> 输入：num = 16 输出：true 解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。
> 来源：[https://leetcode.cn/problems/valid-perfect-square](https://leetcode.cn/problems/valid-perfect-square)

#### 代码实现
```javascript

function isPerfectSquare(num: number): boolean {
  // Think for yourself for 5 minutes...

  let left = 1
  let right = num

  while (left < right) {
    if (left * left == num) {
      return true
    } else if (right * right === num) {
      return true
    } else {
      left++
      right--
    }
  }

  return false
}

// 按道理会更快
function isPerfectSquare(num: number): boolean {
  // Think for yourself for 5 minutes...

  let left = 1
  let right = num

  while (left <= right) {
    let mid = Math.floor((right - left) / 2) + left
    const square = mid * mid
    if (square < num) {
      left = mid + 1
    } else if (square > num) {
      right = mid - 1
    } else {
      return true
    }
  }

  return false
}
```
### 排列硬币
> 你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。
> 给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679754959766-9eeb2dfa-507e-40a9-ab4c-263bfe523c8a.png#averageHue=%23f3d489&clientId=u41294ec2-f4fc-4&from=paste&height=314&id=u0a582107&name=image.png&originHeight=828&originWidth=792&originalType=binary&ratio=2&rotation=0&showTitle=false&size=166421&status=done&style=none&taskId=uf6d13ee2-07e1-431d-b6fc-da31ee5ae0c&title=&width=300)
> 来源：[https://leetcode.cn/problems/arranging-coins](https://leetcode.cn/problems/arranging-coins)

#### 代码实现
```typescript
function arrangeCoins(n: number): number {
  // Think for yourself for 5 minutes...
  // q1. 能构成完整台阶满足 total = ((k+1)*k)/2

  let left = 0
  let right = n
  
  while (left < right) {
    // 先加1再除以2是为了让中间值靠右，因为在后序对右边的值处理是 right = mid - 1，不然会陷入死循环
    const mid = Math.floor((right - left + 1) / 2) + left
    if (mid * (mid + 1) <= 2 * n) {  // 还没用完
      left = mid // 缩小右侧区间
    } else {
      right = mid - 1 // 缩小左侧区间
    }
  }

  return left
}
```
+1再理解
当区间只剩下两个元素的时候，left = mid 和 right = mid - 1 这种划分方式，如果 mid 使用默认下取整的方式，在数值上 left = mid，而它对应的其中一个区间是 [mid..right]，在这种情况下，下一轮搜索区间还是 [left..right]，搜索区间没有减少，会进入死循环。
### ⭐️最小操作次数使数组元素相等
逆向思维！！解题不必顺着题干的思路
> 给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。
> 输入：nums = [1,2,3]  输出：3
> 解释：
> 只需要3次操作（注意每次操作会增加两个元素的值）：
> [1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
> 来源：[https://leetcode.cn/problems/minimum-moves-to-equal-array-elements](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements)

#### 代码实现
```typescript
function minMoves(nums: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. n为nums的长度，每次操作会使n-1个元素增加1
  // q2. 反过来可以理解为  每次让1个元素减1
  // 可以转换为计算数组中所有元素都减少到数组元素最小值的次数

  const min = Math.min(...nums)

  let count: number = 0
  for (const num of nums) {
    count += num - min
  }

  return count
}
```
### Nim 游戏
> 你和你的朋友，两个人一起玩 Nim 游戏：
> 桌子上有一堆石头。
> 你们轮流进行自己的回合， **你作为先手 。**
> 每一回合，轮到的人拿掉 1 - 3 块石头。
> 拿掉最后一块石头的人就是获胜者。
> 假设**你们每一步都是最优解**。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。
> 输入：n = 4  输出：false 
> 解释：以下是可能的结果:
> 1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。
> 2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。
> 3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。
> 在所有结果中，你的朋友是赢家。
> 来源：[https://leetcode.cn/problems/nim-game](https://leetcode.cn/problems/nim-game)

#### 代码实现 
```javascript
var canWinNim = function(n) {
    return n % 4 !== 0;
};
```
既然考虑每一步都是最优解，以用例1作为推导思路，作为先手，只要不是4的整数倍就一定是输的
推理过程：[https://leetcode.cn/problems/nim-game/solution/nim-you-xi-by-leetcode-solution-95g8/](https://leetcode.cn/problems/nim-game/solution/nim-you-xi-by-leetcode-solution-95g8/)
### 石子游戏
> 来源：[https://leetcode.cn/problems/stone-game/](https://leetcode.cn/problems/stone-game/)

#### 代码实现
```javascript
var stoneGame = function(piles) {
    return true;
}
```


## 资料

- 
- 
- 
