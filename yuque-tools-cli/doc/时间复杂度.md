# 时间复杂度 
## 常见复杂度形式
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677337893890-d849f014-c623-4ea5-abe6-43e927d234f9.png#averageHue=%23fcfcfc&clientId=ubb965150-2637-4&from=paste&height=330&id=u7846c8b5&name=image.png&originHeight=1346&originWidth=2446&originalType=binary&ratio=2&rotation=0&showTitle=false&size=501377&status=done&style=none&taskId=u608406f0-3cf1-4b01-8b0c-f710659c863&title=&width=600)
## 时间趋势
下图描绘了各种复杂度的算法中，当输入规模增长时，操作数量（运行时间）的变化趋势。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677337999162-d1f3c61a-c5f3-4adf-9242-493a243b72ed.png#averageHue=%23f8cb9e&clientId=ubb965150-2637-4&from=paste&height=389&id=u9f375547&name=image.png&originHeight=1010&originWidth=1556&originalType=binary&ratio=2&rotation=0&showTitle=false&size=449325&status=done&style=none&taskId=u4a0a469a-6ca0-40b7-af26-fcf1c2ce14d&title=&width=600)
**O(1) < O(logn) < O(n) < nlogn < n^2 < n^3 < 2^n < n!**
## O(1) 常数
这种复杂度的算法的运行时间不会随着输入规模的增加而增加。这类操作的实际例子就是在数组中按索引查找值，或者在哈希表中按键查找值：
```javascript
/**
 * O(1)
 * @param num
 */
const inc = (num: number) => {
  num++
}
```
## O(n) 线性
线性复杂度算法往往在连续迭代数据结构时涉及到。参考先前的对数搜索示例，在数组中搜索值可以用（效率较低）的线性时间来进行：
```javascript

/**
 * O(n)
 * array有n个元素，最坏的情况就会执行n次
 * @param array
 * @param value
 * @returns
 */
const search = (array: string[], value: string) => {
  for (let i = 0; i < array.length; i++) {
    if (isEqual(array[i], value)) {
      return i
    }
  }
  return -1
}
```
## O(n^k) 指数
```javascript
// k层for循环
```
## O(log2n) 对数
典型的对数复杂度算法是二分搜索算法。这是一种用于在有序数组中查找特定值的算法，它不断迭代读取当前范围的中间值，判断目标值是小于还是大于中间值，排除不包含目标的那一半内容
```javascript
/**
 * O(log2n)
 * 因为循环了x次，2x=n 因此 x=log2n
 * @param i
 * @returns
 */
function f(i) {
  var sum = 0
  for (var j = 0; j < i; j++) {
    sum += i
  }
  return sum
}
```
## O(nlogn) 对数线性
它们同时包含对数和线性部分。其中最常见的示例是排序算法。
[算法:排序](https://www.yuque.com/vannvan/tools/ny0rqdwqq0oln9an?view=doc_embed&inner=BPKRC)
## O(kⁿ) 多项式
即随着输入规模的增加，运行时间将按固定倍数来增长。一个典型的例子是直接计算斐波纳契数列中的第 n 项。在下面的示例中，每当输入 **n** 增加 1 时，执行的操作数量就会翻倍
```javascript
const fibonacci = (n) => {
  if (n == 1 || n == 2) return 1
  return fibonacci(n - 1) + fibonacci(n - 2)
}
```
## O(n!) 阶乘复杂度
这种一般设计类似用到排列组合思想的问题会用到，但用到排列组合一般会考虑用动态规划了。
## O(m+n) 
```javascript
/**
 * O(m+n)
 * @param m
 * @param n
 * @returns
 */
function total(m, n) {
  var sum1 = 0
  for (var i = 0; i < n; i++) {
    sum1 += i
  }
  var sum2 = 0
  for (var i = 0; i < m; i++) {
    sum2 += i
  }
  return sum1 + sum2
}

```
## 资料

