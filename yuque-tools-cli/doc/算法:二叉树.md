# 算法:二叉树 
## 题型类别
- 二叉树遍历
- 二叉树属性
- 修改与改造
- 公共祖先
- 二叉搜索树的修改与改造
## 二叉树遍历既要会递归也要会迭代
### 迭代前序
```typescript
// 前序遍历：中左右
// 压栈顺序：右左中
var preorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        if (node.right) stack.push(node.right); // 右
        if (node.left) stack.push(node.left); // 左
        stack.push(node); // 中
        stack.push(null);
    };
    return res;
};

```
### 迭代中序
```typescript
//  中序遍历：左中右
//  压栈顺序：右中左
var inorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        if (node.right) stack.push(node.right); // 右
        stack.push(node); // 中
        stack.push(null);
        if (node.left) stack.push(node.left); // 左
    };
    return res;
};

```
### 迭代后序
```typescript
// 后续遍历：左右中
// 压栈顺序：中右左
 
var postorderTraversal = function(root, res = []) {
    const stack = [];
    if (root) stack.push(root);
    while(stack.length) {
        const node = stack.pop();
        if(!node) {
            res.push(stack.pop().val);
            continue;
        }
        stack.push(node); // 中
        stack.push(null);
        if (node.right) stack.push(node.right); // 右
        if (node.left) stack.push(node.left); // 左
    };
    return res;
};

```

## 例题
### ⭐️二叉树的层序遍历
>  给你二叉树的根节点 root ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1680095052981-4a8f5513-bec0-42d0-9bef-a80838da260a.png#averageHue=%23ededeb&clientId=u9707715c-734a-4&from=paste&height=351&id=ub742a5dd&name=image.png&originHeight=810&originWidth=830&originalType=binary&ratio=2&rotation=0&showTitle=false&size=147154&status=done&style=none&taskId=u29d6e760-1477-429d-8c3a-531b5146d66&title=&width=360)
> 来源：[https://leetcode.cn/problems/binary-tree-level-order-traversal/](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

#### 代码实现-BFS
```typescript
function levelOrder(root: TreeNode | null): number[][] {
    //二叉树的层序遍历
    const ans: number[][] = []
    const queue: TreeNode[] = [];
  
    queue.push(root);
  
    if(root === null) {
        return ans;
    }
    while(queue.length !== 0) {
        // 记录当前层级节点数,下面queue长度是会变的，因此要在这里存一份
        const length = queue.length;
        // 存放每一层的节点
        const curLevel = [];
        for(let i = 0;i < length; i++) {
            const node = queue.shift();
            curLevel.push(node.val);
            // 存放当前层下一层的节点
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        //把每一层的结果放到结果数组
        ans.push(curLevel);
    }
    return ans;
};
```
#### 代码实现-DFS
```typescript
function levelOrder(root: TreeNode | null): number[][] {
    const ans: number[][] = []

    const dfs = (node: TreeNode,level: number) => {
        // 当ans长度等于当前访问的层数时，初始化一个空数组
        if(ans.length === level) {
            ans.push([])
        }

        ans[level].push(node.val) 
      
        if(node.left !== null) {
            dfs(node.left,level+1)
        }
        if(node.right !== null) {
            dfs(node.right,level+1)
        }
    }

    if(root !== null) {
        dfs(root, 0)
    }

    return ans
}

```
#### 相关例题
[算法:二叉树遍历专题](https://www.yuque.com/vannvan/tools/ixmt4575zi5q9qg4?view=doc_embed)
### 翻转二叉树
> 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1680245996864-7e78a705-f98f-4f7b-92fe-0c60f1f0a9e0.png#averageHue=%23dfd1c3&clientId=u6f433772-b58f-4&from=paste&height=279&id=u54f0097e&name=image.png&originHeight=558&originWidth=1282&originalType=binary&ratio=2&rotation=0&showTitle=false&size=164101&status=done&style=none&taskId=ub044cf2b-850b-4c20-a720-12c317a7749&title=&width=641)
> 来源：[https://leetcode.cn/problems/invert-binary-tree/](https://leetcode.cn/problems/invert-binary-tree/)

#### 代码实现
```typescript

/**
 * 递归法
 */
function invertTree(root: TreeNode | null): TreeNode | null {
  if (root === null) return null

  const rightNode = root.right
  root.right = invertTree(root.left)
  root.left = invertTree(rightNode)
  return root
}


/**
 * 迭代法,模拟前序遍历
 */
function invertTree(root: TreeNode | null): TreeNode | null {
  if (!root) return null
  const swap = (root: TreeNode, left: TreeNode, right: TreeNode) => {
    let tmp = left
    root.left = right
    root.right = tmp
  }

  const stack = [root]
  while (stack.length) {
    const node = stack.pop()
    node.left && stack.push(node.left)
    node.right && stack.push(node.right)
    swap(node, node.left, node.right)
  }

  return root
}
```
### 对称二叉树
> 给你一个二叉树的根节点 root ， 检查它是否轴对称。
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1680268591351-fb25fb26-7c6b-4ce0-91b8-a79a85ed1512.png#averageHue=%23f3f4f1&clientId=u88753805-fc9a-4&from=paste&height=385&id=ud01ea12d&name=image.png&originHeight=770&originWidth=890&originalType=binary&ratio=2&rotation=0&showTitle=false&size=167101&status=done&style=none&taskId=u8d7af92d-b859-4147-b133-0c1882447f6&title=&width=445)
> 来源：[https://leetcode.cn/problems/symmetric-tree/](https://leetcode.cn/problems/symmetric-tree/)

#### 代码实现
```typescript
/**
* 迭代+队列，栈和队列的类似，取时用pop即可
*/
function isSymmetric(root: TreeNode | null): boolean {
  if (!root) return false

  const queue: TreeNode[] = []

  queue.push(root.left)
  queue.push(root.right)

  while (queue.length) {
    let leftNode = queue.shift() //左节点
    let rightNode = queue.shift() //右节点
    if (leftNode === null && rightNode === null) {
      continue
    }
    if (leftNode === null || rightNode === null || leftNode.val !== rightNode.val) {
      return false
    }

    // [3,4,4,3] 模式对照
    queue.push(leftNode.left) //左节点左孩子入队 1
    queue.push(rightNode.right) //右节点右孩子入队 4
    queue.push(leftNode.right) //左节点右孩子入队 2
    queue.push(rightNode.left) //右节点左孩子入队 3
  }

  return true
}


/**
* 递归法
 */
function isSymmetric(root: TreeNode | null): boolean {

    const compareNode = (left:TreeNode,right:TreeNode) => {
        if(left === null && right !== null || left !== null && right === null) {
            return false
        }else if(left === null  && right === null) {
            return true  
        }else if(left.val !== right.val) {
            return false  
        }
        const outSide = compareNode(left.left,right.right)  // 两端的
        const inSide = compareNode(left.right,right.left) // 中间的
        return outSide && inSide
    }

    if(!root)  return true  

    return compareNode(root.left,root.right)
}
```
### ⭐️完全二叉树插入器
> 完全二叉树 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。
> 设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1680274479785-8edd87d6-5ab0-415d-97a9-06bb309db80b.png#averageHue=%23f9f9f9&clientId=u0c09af81-964e-4&from=paste&height=208&id=eb29o&name=image.png&originHeight=416&originWidth=1136&originalType=binary&ratio=2&rotation=0&showTitle=false&size=96248&status=done&style=none&taskId=u7df73fbf-5fb4-4b72-b1ed-497a2844d38&title=&width=568)
> 来源：[https://leetcode.cn/problems/complete-binary-tree-inserter](https://leetcode.cn/problems/complete-binary-tree-inserter)

#### 代码实现
node节点
```typescript
class TreeNode {
  val: number
  left: TreeNode | null
  right: TreeNode | null
  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = val === undefined ? 0 : val
    this.left = left === undefined ? null : left
    this.right = right === undefined ? null : right
  }
}
```
```typescript
class CBTInserter {
  private arr: TreeNode[]
  constructor(root: TreeNode | null) {
    this.arr = []
    const queue = [root]
    while (queue.length) {
      const size = queue.length
      for (let i = 0; i < size; i++) {
        const node = queue.pop()
        this.arr.push(node)
        if (node.left) queue.unshift(node.left)
        if (node.right) queue.unshift(node.right)
      }
    }
  }

  insert(val: number): number {
    const node = new TreeNode(val)
    this.arr.push(node)
    const index = this.arr.length
    const parentIndex = (index >> 1) - 1
    if (index % 2 === 0) {
      this.arr[parentIndex].left = node
    } else {
      this.arr[parentIndex].right = node
    }
    return this.arr[parentIndex].val
  }

  get_root(): TreeNode | null {
    return this.arr[0]
  }
}
```
### 完全二叉树的节点个数
> 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
> 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1680274223133-6458a9c2-ba58-472a-84c6-b78d2a6aabb0.png#averageHue=%23fcfcfc&clientId=u6f221b0f-e3eb-4&from=paste&height=410&id=uf5f7a9f6&name=image.png&originHeight=820&originWidth=1202&originalType=binary&ratio=2&rotation=0&showTitle=false&size=161122&status=done&style=none&taskId=udd9360e9-82a3-4041-bee7-3e504a2b19f&title=&width=601)
> 来源：[https://leetcode.cn/problems/count-complete-tree-nodes](https://leetcode.cn/problems/count-complete-tree-nodes)

#### 代码实现
```typescript
/**
 * 易理解版
 * @param root
 * @returns
 */
function countNodes2(root: TreeNode | null): number {
  // 递归法计算二叉树节点数
  // 1. 确定递归函数参数
  const getNodeSum = function (node) {
    //2. 确定终止条件
    if (node === null) {
      return 0
    }
    //3. 确定单层递归逻辑
    let leftNum = getNodeSum(node.left)
    let rightNum = getNodeSum(node.right)
    return leftNum + rightNum + 1
  }
  return getNodeSum(root)
}

/**
 * 精简版
 * @param root
 * @returns
 */
function countNodes(root: TreeNode | null): number {
  if (!root) return 0
  return countNodes(root.left) + countNodes(root.right) + 1
}
```
### 平衡二叉树
> 给定一个二叉树，判断它是否是高度平衡的二叉树。
> 本题中，一棵高度平衡二叉树定义为：
> 一个二叉树_每个节点 _的左右两个子树的高度差的绝对值不超过 1 。
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1680275885408-07ac880a-c4e2-4f78-abb7-1947d5994e5f.png#averageHue=%23f9f9f9&clientId=u613c8589-7c6a-4&from=paste&height=328&id=u800ec1b2&name=image.png&originHeight=656&originWidth=1026&originalType=binary&ratio=2&rotation=0&showTitle=false&size=108089&status=done&style=none&taskId=ucc1219e3-70dc-48ee-b65c-4524d7c8c51&title=&width=513)
> 来源：[https://leetcode.cn/problems/balanced-binary-tree/](https://leetcode.cn/problems/balanced-binary-tree/)

#### 代码实现
```typescript
/**
* 递归法
*/
function getDepth(root: TreeNode | null): number {
  if (root === null) return 0
  let leftDepth: number = getDepth(root.left)
  if (leftDepth === -1) return -1
  let rightDepth: number = getDepth(root.right)
  if (rightDepth === -1) return -1
  if (Math.abs(leftDepth - rightDepth) > 1) return -1
  return 1 + Math.max(leftDepth, rightDepth)
}
function isBalanced(root: TreeNode | null): boolean {
  // Think for yourself for 5 minutes...
  return getDepth(root) !== -1
}
```
#### 提取高度函数
以下高度计算函数可以复用

- 
- 
```typescript
/*
  高度计算函数
*/
const height = (node: TreeNode | null) => {
  if (node === null) {
    return 0
  }
  return Math.max(height(node.left), height(node.right)) + 1
}

function isBalanced(root: TreeNode | null): boolean {
  if (root === null) {
    return true
  }
  return (
    Math.abs(height(root.left) - height(root.right)) <= 1 &&
    isBalanced(root.left) &&
    isBalanced(root.right)
  )
}
```
## 
## 
## 
## 资料

- 
