# 数据结构:链表 
概念：
> [https://www.yuque.com/vannvan/cgsqcn/vh7v1ihxmexcft9o#QvfNi](https://www.yuque.com/vannvan/cgsqcn/vh7v1ihxmexcft9o#QvfNi)

## 单链表
### 示例图
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676509616492-2755cbe9-3ba3-4c3c-bdc7-c7ffff607db6.png#averageHue=%23efefef&clientId=u03387b31-e274-4&from=paste&height=130&id=u5e7f914e&name=image.png&originHeight=216&originWidth=996&originalType=binary&ratio=2&rotation=0&showTitle=false&size=48917&status=done&style=none&taskId=u40c7f17a-028f-4e6d-8b70-e3ef22f013f&title=&width=600)
### 代码实现
```javascript
/**
 * 单链表
 */

class Node {
  constructor(data) {
    this.data = data
    this.next = null
  }
}

class singleLinkedList {
  constructor() {
    this.head = null
  }

  add(data) {
    let node = new Node(data)
    if (this.head === null) {
      this.head = node
    } else {
      let current = this.head
      // 从头开始捋一遍，添加到最后
      while (current.next) {
        current = current.next
      }
      current.next = node
    }
  }

  insert(data, target) {
    const node = new Node(data)
    let current = this.head
    // 从头开始
    while (current.next) {
      if (current.data === target) {
        node.next = current.next
        current.next = node
        break
      }
      current = current.next
    }
  }

  find(data) {
    let current = this.head
    while (current) {
      if (current.data === data) {
        return current
      }
      current = current.next // 没有找到就往后移动
    }
    return null
  }

  remove(data) {
    let current = this.head
    let previous = null
    while (current) {
      if (current.data === data) {
        if (previous === null) {
          this.head = current.next
        } else {
          previous.next = current.next // 把前一个和后一个关系续上
        }
        return true
      }
      // 往后移动继续找
      previous = current
      current = current.next
    }
    return false
  }
}

const list = new singleLinkedList()
list.add(2)
list.add(4)
list.add(3)
// list.insert(5, 4)

console.dir(list, { depth: null })

```
### 要点

1. 谨记 当前项需要有next相关联
2. 删除时，删除项和下一项就断开关联了，因此删除前要把前一项缓存一份，跟后续的接上
## 双向链表
### 示例图
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676509583659-e9aeb678-99e7-4425-862f-98139defa933.png#averageHue=%23ededed&clientId=u03387b31-e274-4&from=paste&height=135&id=u18d6d025&name=image.png&originHeight=304&originWidth=1354&originalType=binary&ratio=2&rotation=0&showTitle=false&size=93747&status=done&style=none&taskId=u60e2c77f-849a-4d2b-879c-425eaa1f12e&title=&width=600)
### 代码实现
```javascript
/**
 * 双向链表
 */

class Node {
  constructor(data, next) {
    this.data = data
    this.next = next
  }
}

class DoublyLinkNode extends Node {
  constructor(data, next, prev) {
    super(data, next)
    this.prev = prev
  }
}

class DoublyLinkedList {
  constructor() {
    this.tail = {}
    this.head = null
    this.count = 0
  }

  add(data) {
    const node = new DoublyLinkNode(data)
    if (this.head === null) {
      this.head = node
      this.tail = node
    } else {
      // 前后项关联起来
      this.tail.next = node
      node.prev = this.tail
      
      this.tail = node
    }
    this.count++
  }

  insert(data, index) {
    if (index >= 0 && index <= this.count) {
      const node = new DoublyNode(data)
      let current = this.head
      if (index === 0) {
        // 在最前面添加
        if (this.head == null) {
          // NEW
          this.head = node
          this.tail = node // NEW
        } else {
          node.next = this.head
          this.head.prev = node // NEW
          this.head = node
        }
      } else if (index === this.count) {
        // 在最后面添加
        // last item NEW
        current = this.tail
        current.next = node
        node.prev = current
        this.tail = node
      } else {
        // 在中间添加
        const previous = this.getElementAt(index - 1)
        current = previous.next
        node.next = current
        previous.next = node
        current.prev = node // NEW
        node.prev = previous // NEW
      }
      this.count++
      return true
    }
    return false
  }

  removeAt(index) {
    if (index >= 0 && index < this.count) {
      let current = this.head
      if (index === 0) {
        // 删除头部
        this.head = this.head.next
        if (this.count === 1) {
          // {2}
          this.tail = undefined
        } else {
          this.head.prev = undefined
        }
      } else if (index === this.count - 1) {
        // 删除尾部
        // last item //NEW
        current = this.tail
        this.tail = current.prev
        this.tail.next = undefined
      } else {
        // 删除中间的元素
        current = this.getElementAt(index)
        const previous = current.prev
        // link previous with current's next - skip it to remove
        previous.next = current.next
        current.next.prev = previous // NEW
      }
      this.count--
      return current.data
    }
    return undefined
  }

  getElementAt(index) {
    if (index >= 0 && index <= this.count) {
      let node = this.head
      for (let i = 0; i < index && node != null; i++) {
        node = node.next
      }
      return node
    }
    return undefined
  }

  toString() {
    if (this.head == null) {
      return '--'
    }
    let objString = `${this.head.data}`
    let current = this.head.next
    while (current != null) {
      objString = `${objString},${current.data}`
      current = current.next
    }
    return objString
  }
}

const link = new DoublyLinkedList()
link.add(1)
link.add(3)
link.add(2)

// link.removeAt(1)
console.dir(link)

// console.log(link.toString())

```
### 要点

1. 前后握手，知道前一项要能找到后一项，知道后一项要能找到前一项，因此需要有一份有prev和next
2. head即第一项元素的prev，tail即最后一项元素的next
3. 删除中间的元素时，要先把前一项取出来，他自己删除后前一项要能和后一项握起手来

《学习JavaScript数据结构与算法》中的双向链表
## 循环链表
### 示例图
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676509670262-9dada430-5c1f-4221-8d8c-1ea23e82294f.png#averageHue=%23f1f1f1&clientId=u03387b31-e274-4&from=paste&height=147&id=ub9d55cfc&name=image.png&originHeight=268&originWidth=1092&originalType=binary&ratio=2&rotation=0&showTitle=false&size=46298&status=done&style=none&taskId=u2caf93f7-68dd-4d33-90ce-84b9f45505b&title=&width=600)
### 代码实现
```javascript
/**
 * 循环链表
 */

class Node {
  constructor(data, next) {
    this.data = data
    this.next = next
  }
}

class CircularLinkedList {
  constructor() {
    this.head = null
    this.count = 0
  }

  add(data) {
    let node = new Node(data)
    if (this.head === null) {
      this.head = node
    } else {
      let current = this.getElementAt(this.count - 1)
      current.next = node
    }
    // 关键，首尾相接才是循环
    node.next = this.head
    this.count++
  }

  insert(data, index) {
    if (index >= 0 && index <= this.count) {
      const node = new Node(data)
      let current = this.head
      if (index === 0) {
        if (this.head == null) {
          // if no node  in list
          this.head = node
          node.next = this.head
        } else {
          node.next = current
          current = this.getElementAt(this.size() - 1)
          // update last element
          this.head = node
          current.next = this.head
        }
      } else {
        const previous = this.getElementAt(index - 1)
        node.next = previous.next
        previous.next = node
      }
      this.count++
      return true
    }
    return false
  }

  removeAt(index) {
    if (index >= 0 && index < this.count) {
      let current = this.head
      if (index === 0) {
        if (this.size() === 1) {
          this.head = undefined
        } else {
          const removed = this.head
          current = this.getElementAt(this.size() - 1)
          this.head = this.head.next
          current.next = this.head
          current = removed
        }
      } else {
        // no need to update last element for circular list
        const previous = this.getElementAt(index - 1)
        current = previous.next
        previous.next = current.next
      }
      this.count--
      return current.element
    }
    return undefined
  }

  getElementAt(index) {
    if (index >= 0 && index <= this.count) {
      let node = this.head
      for (let i = 0; i < index && node != null; i++) {
        node = node.next
      }
      return node
    }
    return undefined
  }
}

const link = new CircularLinkedList()
link.add(1)
link.add(3)
link.add(2)

link.removeAt(2)

console.dir(link)

```

### 要点

1. 首尾相接，因此必须存在最后一项.next = head
2. 不管是insert还是removeAt 只要操作的不是第一项，都需要把操作项的前一项找出来，和下一项的关系续起来

《学习JavaScript数据结构与算法》中的循环链表

### 引申：双向循环链表
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676509712462-53661001-3802-4849-8709-10f2d858a232.png#averageHue=%23eeeeee&clientId=u03387b31-e274-4&from=paste&height=138&id=ub1e0a87e&name=image.png&originHeight=330&originWidth=1430&originalType=binary&ratio=2&rotation=0&showTitle=false&size=82290&status=done&style=none&taskId=u01b52134-f5f4-4c1b-b5e6-64f83c5ba1f&title=&width=600)

