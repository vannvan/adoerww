# 算法:栈与队列 
## 关键词
- 一进一出
- 单调栈/单调队列
### 栈使用技巧

1.  处理括号匹配问题：使用栈来存储左括号，并在遇到右括号时检查栈顶元素是否为对应的左括号。 
2.  实现函数调用：每次函数调用时，在栈中保存当前函数的上下文，包括程序计数器和局部变量等信息，当函数返回时再恢复上下文。 
3.  计算逆波兰表达式：使用栈来存储数字，并在遇到操作符时弹出栈顶元素进行运算，再将结果入栈。 
4.  实现深度优先搜索算法：使用栈来存储需要遍历的节点，每次从栈中弹出一个节点并加入到已访问集合中，再将其邻居节点加入栈中。 
5.  实现图的拓扑排序：使用栈来存储入度为0的节点，并在每次弹出一个节点后将其所有出边的终点入度减一，若减为0则加入栈中。 
6.  实现表达式求值：使用两个栈，一个存储数字，一个存储操作符，每次遇到运算符时弹出栈顶两个数进行运算，再将结果入栈。 
### 单调栈理解
以单调递增栈为例，单调递增栈即栈内元素保持单调递增的栈
**操作规则：**
如果新的元素比栈顶元素大，就入栈
**如果新的元素较小，那就一直把栈内元素弹出来，直到栈顶比新元素小**
**操作过程：**
当元素出栈时，说明这个**新元素**是出栈元素**向后**找第一个比其小的元素
> 举个例子，配合下图，现在索引在 6 ，栈里是 1 5 6 。
> 接下来新元素是 2 ，那么 6 需要出栈。
> 当 6 出栈时，右边 2 代表是 6 右边第一个比 6 小的元素。

当元素出栈后，说明新**栈顶元素**是出栈元素**向前**找第一个比其小的元素
> 当 6 出栈时，5 成为新的栈顶，那么 5 就是 6 左边第一个比 6 小的元素。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679233083919-672b05dd-da92-4127-b82e-768a637ba516.png#averageHue=%23f5f4f2&clientId=uef0a2d68-7096-4&from=paste&height=360&id=uf178a557&name=image.png&originHeight=720&originWidth=1492&originalType=binary&ratio=2&rotation=0&showTitle=false&size=428523&status=done&style=none&taskId=u7e132286-02df-4f7a-a726-356a75a4663&title=&width=746)
**PS: 单调栈一般是记录元素下标的，因为存下标可以通过出/入栈下标【arr[stack[stack.length-1]】来做前后对比，而一般不考虑存数值**
## 例题
### 每日温度
> 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。
> 输入: temperatures = [73,74,75,71,69,72,76,73] 输出: [1,1,4,2,1,1,0,0]
> 来源：[https://leetcode.cn/problems/daily-temperatures](https://leetcode.cn/problems/daily-temperatures)

#### 代码实现 
```typescript
function dailyTemperatures(temperatures: number[]): number[] {
  // Think for yourself for 5 minutes...
  // [73, 74, 75, 71, 69, 72, 76, 73]
  // q1. 下一个高温在几天之后 即i之后的相对于i升温
  // 如果i+1 > i 那么 i位置的就是1
  // 如果i+n > i 那么 i位置就是n
  // 因为第一项前面没有元素，先把第一项推入栈中
  // 栈顶(数组的尾部)只push “较大”的元素的索引，(从栈顶到栈底依次递减)
  // 当下次遇到当前元素小于栈顶元素时，说明i位置以前的差值都需要更新了
  // 直到把栈掏空为止，最后再将当前元素入栈，开始下一轮出入栈操作

  const stack: number[] = [] // 用于存储元素右面第一个比他大的元素下标
  const n: number = temperatures.length

  const result: number[] = Array(n).fill(0)

  const T: number[] = temperatures

  stack.push(0)

  for (let i = 1; i < n; i++) {
    const top = stack[stack.length - 1]
    if (T[i] <= T[top]) {
      stack.push(i)
    } else {
      while (stack.length && T[i] > T[stack[stack.length - 1]]) {
        const top = stack.pop()
        if (top != undefined) {
          result[top] = i - top
        }
      }
      stack.push(i)
    }
  }
  return result
}
```
#### 倒着扫描
```typescript
function dailyTemperatures(temperatures: number[]): number[] {
  const n: number = temperatures.length
  const T: number[] = temperatures

  const stack: number[] = []

  const result: number[] = Array(n).fill(0)

  for (let i = n - 1; i >= 0; i--) {
    while (stack.length && T[stack[stack.length - 1]] <= T[i]) {
      stack.pop()
    }
    result[i] = !stack.length ? 0 : stack[stack.length - 1] - i
    stack.push(i)
  }

  return result
}
```
### 下一个更大的数I
> nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。
> 给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。
> 对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。
> 返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。
> 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].   输出：[-1,3,-1]
> 解释：nums1 中每个值的下一个更大元素如下所述：
> - 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
> - 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
> - 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
> 来源：[https://leetcode.cn/problems/next-greater-element-i](https://leetcode.cn/problems/next-greater-element-i)

#### 代码实现
```typescript
function nextGreaterElement(nums1: number[], nums2: number[]): number[] {
  // Think for yourself for 5 minutes...
  // q1. 求nums1中的数字x 在nums2中的x的下一个更大的数 ，两个数组都不含重复数字
  // 将nums1的元素用hash表存起来，key对应数字 ，value对应下标
  // 递增栈[1,2,3]
  // 栈顶存放上一个较小的元素，当前元素大于栈顶元素时，就要将上一个(即栈顶元素)的"下一个更大的元素"更新为当前元素
  const hash: Map<number, number> = new Map()

  for (let i = 0; i < nums1.length; i++) {
    hash.set(nums1[i], i)
  }

  const stack: number[] = []

  stack.push(0)

  const result: number[] = Array(nums1.length).fill(-1)

  for (let i = 1; i < nums2.length; i++) {
    let top = stack[stack.length - 1]
    while (stack.length > 0 && nums2[i] > nums2[top]) {
      let index = hash.get(nums2[top])
      if (index !== undefined) {
        // console.log('更新', i, nums2[i])
        result[index] = nums2[i]
      }
      stack.pop()
      top = stack[stack.length - 1]
    }
    if (hash.get(nums2[i]) !== undefined) {
      stack.push(i)
    }
  }
  // console.log('result', result)
  return result
}
```
#### 倒着扫描
```typescript
function nextGreaterElement(nums1: number[], nums2: number[]): number[] {
  // const result: number[] = []
  const stack: number[] = Array(nums2.length).fill(0)

  const hash: Map<number, number> = new Map()

  for (let i = nums2.length - 1; i >= 0; i--) {
    while (stack.length && stack[stack.length - 1] <= nums2[i]) {
      stack.pop()
    }
    // result[i] = stack.length ? stack[stack.length - 1] : -1
    hash.set(nums2[i], stack.length ? stack[stack.length - 1] : -1)
    stack.push(nums2[i])
  }

  return Array.from({ length: nums1.length }, (_, k) => hash.get(nums1[k]) || -1)
}
```
#### 类似题目
> 

### ⭐️商品折扣后的最终价格
> 给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。
> 商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j > i 且 prices[j] <= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。
> 请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。
> 输入：prices = [8,4,6,2,3] 输出：[4,2,4,2,3]
> 来源：[https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop](https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop)

#### 代码实现
```typescript
// 常规方法
function finalPrices(prices: number[]): number[] {
  // Think for yourself for 5 minutes...
  // q1. 下一个更小的数,返回相减之后到值
  // q2. 以当前i位置为基准，找到第一个比他小的数

  const n: number = prices.length

  const ans: number[] = []
  for (let i = 0; i < n; i++) {
    let p: number = i + 1
    while (p < n && prices[p] > prices[i]) p++
    // 找到p的位置后，如果p到结尾了，说明没找到,就是当前值
    if (p == n) {
      ans[i] = prices[i]
    } else {
      const a = prices[i] - prices[p]
      ans[i] = a
    }
  }
  return ans
}
// 单调栈
function finalPrices(prices: number[]): number[] {
  const n: number = prices.length

  const stack: number[] = []

  const ans: number[] = []

  for (let i = n - 1; i >= 0; i--) {
    // 当栈顶的元素比新来的大，说明新来的是之前的价格的相对小的值了
    // 就把栈顶的元素弹出
    while (stack.length && stack[stack.length - 1] > prices[i]) {
      stack.pop()
    }
    // 当前位比栈顶元素大才会走到这里，因为是倒着扫描，栈顶就是当前元素下一个更小的值
    ans[i] = stack.length == 0 ? prices[i] : prices[i] - stack[stack.length - 1]
    stack.push(prices[i])
  }
  return ans
}
```
### ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679325022502-173139b8-4fe7-4872-907a-5ec53f9f11a6.png#averageHue=%23f4f4f4&clientId=u344b011d-3c23-4&from=paste&height=180&id=u7b4cffc0&name=image.png&originHeight=360&originWidth=820&originalType=binary&ratio=2&rotation=0&showTitle=false&size=47974&status=done&style=none&taskId=u5d4332a8-5e75-4e44-b98a-367abc3c79e&title=&width=410)
### 下一个更大的数II
> 给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。
> 数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。
> 输入: nums = [1,2,1]   输出: [2,-1,2]
> 解释: 第一个 1 的下一个更大的数是 2；
> 数字 2 找不到下一个更大的数； 
> 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
> 来源：[https://leetcode.cn/problems/next-greater-element-ii](https://leetcode.cn/problems/next-greater-element-ii)

PS：模拟环形遍历
```typescript
let index = 0
while (index < 20) {
  console.log(nums[index % n])
  index++
}
```
#### 代码实现
```typescript

function nextGreaterElements(nums: number[]): number[] {
  // Think for yourself for 5 minutes...
  const n: number = nums.length

  const result: number[] = Array(n).fill(0)

  const stack: number[] = []

  // 数组长度加倍模拟环形数组
  for (let i = 2 * n - 1; i >= 0; i--) {
    while (stack.length && stack[stack.length - 1] <= nums[i % n]) {
      stack.pop()
    }

    result[i % n] = stack.length === 0 ? -1 : stack[stack.length - 1]
    stack.push(nums[i % n])
  }

  return result
}
```
### 接雨水
> 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679234546916-d52f7298-3bb6-4b2d-8979-b706133573ec.png#averageHue=%23bfbfbf&clientId=uef0a2d68-7096-4&from=paste&height=81&id=uabec87d7&name=image.png&originHeight=161&originWidth=412&originalType=binary&ratio=2&rotation=0&showTitle=false&size=10776&status=done&style=none&taskId=u9f2b12e2-56ab-44fd-9c56-706d6a424d2&title=&width=206)
> 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
> 输出：6
> 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
> 来源：[https://leetcode.cn/problems/trapping-rain-water](https://leetcode.cn/problems/trapping-rain-water)

#### 代码实现
```typescript

/**
 * 单调栈
 * @param height
 */
function trap(height: number[]): number {
  let sum: number = 0

  const stack: number[] = []
  stack[0] = 0
  for (let i = 1; i < height.length; i++) {
    // 栈不为空，且当前元素（右墙）比栈顶（右墙的左侧）大：说明形成凹槽了
    while (stack.length && height[i] > height[stack[stack.length - 1]]) {
      // 凹槽处弹出，尝试结算此低洼处能积攒的雨水
      const bottom = stack[stack.length - 1]
      stack.pop()

      let bottomHeight = height[bottom] // 凹槽处的高度
      let rightHeight = height[i] // 凹槽右边的高度
      let leftHeight = height[stack[stack.length - 1]] // 凹槽左边的高度

      if (stack.length) {
        // 能积攒的水=(右墙位置-左墙位置-1) * (min(右墙高度, 左墙高度)-凹槽处高度)
        let height = Math.min(rightHeight, leftHeight) - bottomHeight
        let width = i - stack[stack.length - 1] - 1 // 注意减一，只求中间宽度
        sum += height * width
      }
    }

    stack.push(i)
  }

  return sum
}
```
#### 动态规划
```typescript
/**
 * 动态规划
 * @param height
 * @returns
 */
function trap2(height: number[]): number {
  const n: number = height.length
  if (n <= 2) return 0

  // 记录每根柱子左边的最大高度
  const maxLeft: number[] = Array(n).fill(0)
  maxLeft[0] = height[0]

  for (let i = 1; i < height.length; i++) {
    maxLeft[i] = Math.max(height[i], maxLeft[i - 1])
  }

  // 记录每根柱子右边的最大高度
  const maxRight: number[] = Array(n).fill(0)
  maxRight[n - 1] = height[n - 1]

  for (let j = n - 2; j >= 0; j--) {
    maxRight[j] = Math.max(height[j], maxRight[j + 1])
  }

  let sum = 0

  for (let i = 0; i < n; i++) {
    let count = Math.min(maxLeft[i], maxRight[i]) - height[i]
    if (count > 0) sum += count
  }

  return sum
}
```
### 柱状图中最大的矩形
> 给定 _n_ 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。
> 求在该柱状图中，能够勾勒出来的矩形的最大面积。
> 
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679235275447-b40aee47-779c-4ae5-8084-5971cf539334.png#averageHue=%23f5eeee&clientId=uef0a2d68-7096-4&from=paste&height=242&id=u6678a9a0&name=image.png&originHeight=484&originWidth=1044&originalType=binary&ratio=2&rotation=0&showTitle=false&size=109235&status=done&style=none&taskId=u2b97a079-40c3-434c-8a3d-ea3df8d8000&title=&width=522)
> 输入：heights = [2,1,5,6,2,3] 输出：10 解释：最大的矩形为图中红色区域，面积为 10
> 来源：[https://leetcode.cn/problems/largest-rectangle-in-histogram/](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

#### 代码实现
```typescript

/**
 * 单调递减栈
 * @param heights
 * @returns
 */
function largestRectangleArea(heights: number[]): number {
  // Think for yourself for 5 minutes...

  const stack: number[] = []

  heights.unshift(0)
  heights.push(0)

  let result: number = 0

  for (let i = 0; i < heights.length; i++) {
    while (stack.length && heights[i] < heights[stack[stack.length - 1]]) {
      const curr = stack[stack.length - 1]
      stack.pop()
      let left = stack[stack.length - 1] + 1
      let right = i - 1
      result = Math.max(result, (right - left + 1) * heights[curr])
    }

    stack.push(i)
  }

  return result
}
```
思路分析
以heights [2, 1, 5, 6, 2, 3]为例，当遍历到第一个元素(heights[0])时，高度为2的最大面积还不确定，因此继续往后遍历，到下一位heights[1]时，我们发现高度变小了，因此可以暂时确定下来高度为2的最大面积
当再进入heights[2]时，同样，高度为5的最大面积也不能确定，继续往后，到heights[3]时，高度为6的最大面积也不能确定，再继续heights[4]，此时heights[4]小于heights[3]了，因此可以确定高度为6的最大面积，同时也可以确定高度为5的最大面积。

经过上述推导最大面积的过程我们发现，i位置所在高度的最大面积是需要进入i+n项之后(将要呈递减)才能确定这个位置的最大高度，因此能够确定某个位置柱形宽度的顺序是**从右推导左。**

因此需要引入单调栈，用以记录某个位置之前的“较低”的柱子(栈)，如果当前i位置的高度小于栈的最后一位元素了(栈顶元素)，那么就需要更新这个区间的矩形面积值了。
#### 暴力解法
```typescript
/**
 * 暴力解法
 * @param heights
 */
function largestRectangleArea(heights: number[]): number {
  // 对于每一个元素，我们去求它可以向两边延伸，找到能够构成矩形的左右两端点
  // 能有构成矩形的条件时这个点是>=当前点的
  let n: number = heights.length
  if (n == 0) return 0
  let result: number = 0

  for (let i = 0; i < n; i++) {
    let left = i
    let currHeight = heights[i]

    // 找当前元素左边最后 1 个大于等于 heights[i] 的下标
    while (left > 0 && heights[left - 1] >= currHeight) {
      left--
    }

    // 找当前元素右边最后 1 个大于等于 heights[i] 的下标
    let right = i
    while (right < n - 1 && heights[right + 1] >= currHeight) {
      right++
    }

    let width = right - left + 1
    result = Math.max(result, width * currHeight)
  }

  return result
}
```
### 有效的括号
> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
> 有效字符串需满足：
> 左括号必须用相同类型的右括号闭合。
> 左括号必须以正确的顺序闭合。
> 每个右括号都有一个对应的相同类型的左括号。
> 来源：[https://leetcode.cn/problems/valid-parentheses](https://leetcode.cn/problems/valid-parentheses)

#### 代码实现
```typescript
function isValid(s: string): boolean {
	if (s.length % 2 != 0) return false
  const map = new Map()
  map.set('}', '{')
  map.set(')', '(')
  map.set(']', '[')
  let arr: string[] = s.split('')
  let stack: string[] = []
  while (arr.length) {
    const cur: string = arr.shift() as string
    if (['}', ')', ']'].includes(cur)) {
      const top = stack.pop()
      if (map.get(cur) != top) {
        return false
      }
    } else {
      stack.push(cur)
    }
  }
  return stack.length == 0
};
```
### 括号的分数
> 给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：
> () 得 1 分。
> AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。
> (A) 得 2 * A 分，其中 A 是平衡括号字符串。
> 输入： "(()(()))" 输出： 6
> 来源：[https://leetcode.cn/problems/score-of-parentheses](https://leetcode.cn/problems/score-of-parentheses)

#### 代码实现 
```typescript
function scoreOfParentheses(s: string): number {
  // Think for yourself for 5 minutes...

  const stack: number[] = [0]

  for (let i = 0; i < s.length; i++) {
    if (s[i] === '(') {
      stack.push(0)
    } else {
      // 如果遇到右括号，说明A的分数被计算出来了，如果是0，说明当前元素的前一项是 左括号
      // 如果不是0 说明当前元素的前一项相隔了其他字符 2*v分
      const v = stack.pop() as number
      let top = (stack.pop() as number) + Math.max(2 * v, 1)
      stack.push(top)
    }
  }

  return stack[0]
}
```
### 移除K为数字
> 给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k_ _位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。
> 输入：num = "1432219", k = 3 输出："1219" 解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
> 来源：[https://leetcode.cn/problems/remove-k-digits/](https://leetcode.cn/problems/remove-k-digits/)

#### 代码实现 
```typescript
function removeKdigits(num: string, k: number): string {
  // Think for yourself for 5 minutes...
  // q1. 剩余为空返回“0”
  // q2.使得剩下的数字最小
  const stk: string[] = []
  const n: number = num.length

  for (const digit of num) {
    // q1. 如果栈顶堆元素大于新来的元素就不断去除栈顶堆元素，
    while (stk.length > 0 && stk[stk.length - 1] > digit && k) {
      stk.pop()
      k -= 1
    }
    stk.push(digit)
  }

  console.log('stk', stk)
  // q2.如果删除了m个数字，且m<k,这种情况需要从序列尾部删除k-m个数字
  // removeKdigits('12345264', 5) 会走到这里
  for (; k > 0; --k) {
    stk.pop()
  }

  console.log('stk', stk)

  let ans: string = ''

  let isLeadingZero: boolean = true

  for (const val of stk) {
    // 遇到0就跳过
    if (isLeadingZero && val === '0') {
      continue
    }
    isLeadingZero = false
    ans += val
  }
  // 开头有0也可以这样处理
  // return parseInt(stk.join('')) == 0 || stk.length == 0 ? '0' : String(parseInt(stk.join('')))
  return ans === '' ? '0' : ans
}
```
### 最短无序连续子数组
> 给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
> 请你找出符合题意的 最短 子数组，并输出它的长度。
> 输入：nums = [2,6,4,8,10,9,15]  输出：5
> 解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
> 来源：[https://leetcode.cn/problems/shortest-unsorted-continuous-subarray](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray)

#### 代码实现
```typescript
function findUnsortedSubarray(nums: number[]): number {
  const stack: number[] = []
  let start: number = Infinity
  let end: number = -1
  let max: number = -Infinity

  for (let i = 0; i < nums.length; i++) {
    while (stack.length && nums[stack[stack.length - 1]] > nums[i]) {
      // 保存已经发现的最大值
      max = Math.max(max, nums[stack[1.length - 1]])

      const curr = stack.pop()
      // start只能向前移动
      if (curr && curr < start) {
        start = curr
      }
    }
    if (nums[i] < max) end = i
    stack.push(i)
  }

  if (start > end) return 0
  return end - start + 1
}
```
#### 双指针
[算法:双指针](https://www.yuque.com/vannvan/tools/ta0fig2nzk9vfwnm?view=doc_embed&inner=hV897)
### 比较含退格的字符串
> 给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。
> 注意：如果对空文本输入退格字符，文本继续为空。
> 输入：s = "ab#c", t = "ad#c" 输出：true 解释：s 和 t 都会变成 "ac"。
> 来源：[https://leetcode.cn/problems/backspace-string-compare](https://leetcode.cn/problems/backspace-string-compare)

#### 代码实现
```typescript
function backspaceCompare(s: string, t: string): boolean {
  // Think for yourself for 5 minutes...
  const stack1: string[] = []
  const stack2: string[] = []

  for (const s1 of s) {
    if (s1 === '#') {
      stack1.pop()
    } else {
      stack1.push(s1)
    }
  }

  for (const t1 of t) {
    if (t1 === '#') {
      stack2.pop()
    } else {
      stack2.push(t1)
    }
  }

  return stack1.join('') === stack2.join('')
}
```
### 整理字符串
> 给你一个由大小写英文字母组成的字符串 s 。
> 一个整理好的字符串中，两个相邻字符 s[i] 和 s[i+1]，其中 0<= i <= s.length-2 ，要满足如下条件:
> 若 s[i] 是小写字符，则 s[i+1] 不可以是相同的大写字符。
> 若 s[i] 是大写字符，则 s[i+1] 不可以是相同的小写字符。
> 请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。
> 请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。
> 输入：s = "leEeetcode"   输出："leetcode"
> 解释：无论你第一次选的是 i = 1 还是 i = 2，都会使 "leEeetcode" 缩减为 "leetcode" 。
> 来源：[https://leetcode.cn/problems/make-the-string-great](https://leetcode.cn/problems/make-the-string-great)

#### 代码实现
```typescript
function makeGood(s: string): string {
  // Think for yourself for 5 minutes...
  // q1.若 s[i] 是小写字符，则 s[i+1] 不可以是相同的大写字符。
  // 若 s[i] 是大写字符，则 s[i+1] 不可以是相同的小写字符。

  const stack: string[] = []

  for (const s1 of s) {
    const top = stack[stack.length - 1]
    if (stack.length && top && top != s1 && top.toUpperCase() === s1.toUpperCase()) {
      stack.pop()
    } else {
      stack.push(s1)
    }
  }

  return stack.join('')
}
```
### ⭐️去除重复字母
> 给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。
> 输入：s = "bcabc" 输出："abc"
来源：[https://leetcode.cn/problems/remove-duplicate-letters/](https://leetcode.cn/problems/remove-duplicate-letters/)

PS:
#### 代码实现
```typescript
function removeDuplicateLetters(s: string): string {
  // Think for yourself for 5 minutes...
  // q1. 要去重
  // q2. 不能打乱相对顺序
  // q3. 字典序最小

  const count = {}
  
  for (let i = 0; i < s.length; i++) {
    count[s[i]] = count[s[i]] ? count[s[i]] + 1 : 1
  }

  const inStack = {}

  const stack: string[] = []

  for (const c of s) {
    count[c]--
    // 当栈里面有当前这个字符，就绕过
    if (inStack[c]) continue
    // console.log('此时栈里的元素为:', stack)
    while (stack.length && stack[stack.length - 1] > c) {
      // 若之后不存在栈顶元素了，则停止 pop,因为这时候count对应的这个字符都用完了,后面再也没有这个字符了，
      // 栈里面不存在重复元素
      if (count[stack[stack.length - 1]] == 0) {
        // console.log('剩下的元素:', stack)
        break
      }
      // console.log('此时将要弹出的元素:', stack[stack.length - 1])
      inStack[stack.pop() as any] = false // 出栈了打上标记
    }
    // 若之后不存在栈顶元素了，则停止 pop);
    stack.push(c)
    inStack[c] = true // 入栈了打上标记
  }

  // console.log('stack', stack)

  return stack.join('')
}
```
思路分析
以cbacdcbc为例，当第一个c入栈后，在b入栈时栈里有元素，但b<c，因此b入栈，c出栈，同理b->a也是一样，依次到c时，栈里元素为a，while不成立，栈里元素此时有[a,c]
当d入栈后，c再入栈，此时栈里已经有c了，绕过它


## 单调栈
### 模版👆(对应倒着扫描)
例如，一个数组nums = [2,1,2,4,3]，返回数组 [4,2,4,-1,-1]，含义是每一位数字后面比他大的数字
```typescript
const nextGreaterElement = function(nums) {
    const n = nums.length;
    // 存放答案的数组
    const res = new Array(n).fill(0);
    const stack = []; 
    // 倒着往栈里放
    for (var i = n - 1; i >= 0; i--) { // 倒着入栈
        // 判定个子高矮
        while (stack.length && stack[stack.length - 1] <= nums[i]) {
            // 矮个起开，反正也被挡着了。。。
            stack.pop();
        }
        // nums[i] 身后的更大元素
        res[i] = stack.length ? stack[stack.length - 1] : -1;
        stack.push(nums[i]);
    }
    return res;
};
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679218850374-d4f6eacc-ff34-4625-8030-c6b9a52829ae.png#averageHue=%23fbfaf6&clientId=ucd60b85c-53e4-4&from=paste&height=305&id=uf4888b21&name=image.png&originHeight=862&originWidth=1696&originalType=binary&ratio=1&rotation=0&showTitle=false&size=515641&status=done&style=none&taskId=u5cff84c8-5a92-4e14-a0bd-eac99d24f36&title=&width=600)
### 单调栈套路总结

1. 找到每个元素左边/右边最近的比它大/小的元素

这种问题通常可以用单调栈来解决。我们使用一个栈来保存元素，栈中元素保持单调递增或单调递减。当我们遍历到一个新元素时，如果它比栈顶元素大（或小），则弹出栈顶元素，并记录栈顶元素的答案。然后将新元素压入栈中。最后栈中剩余的元素没有找到比它们大（或小）的元素，它们的答案可以设置为特定的值（例如 -1）。

2. 计算每个元素的一些相关信息

有些问题需要计算每个元素的一些相关信息，例如：最大子段和、柱状图中的最大矩形面积等。对于这种问题，我们可以使用单调栈来从左往右遍历每个元素，计算它们的信息。此时栈中保存的是**未处理元素的下标**。每当遍历一个新元素时，我们需要将栈中所有比它小的元素弹出，并计算它们的相关信息，同时更新答案。然后将新元素压入栈中，继续遍历下一个元素。

3. 找到满足某些限制条件的子数组

有些问题要求找到满足某些限制条件的子数组，例如：和为定值的子数组、最长连续递增子数组等等。这种问题通常可以用单调栈和前缀和/差分数组来解决。我们首先计算出前缀和/差分数组，并使用单调栈从左往右遍历每个元素。当遍历到元素 i 时，我们将其前缀和/差分值加入单调栈中。如果当前栈中元素之间的差值满足限制条件，就更新答案。然后继续遍历下一个元素。


## 资料

- 
- 
- 
