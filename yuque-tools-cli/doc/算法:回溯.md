# 算法:回溯 
## 特征
回溯是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。
PS:回溯和递归是相辅相成的，相对比较暴力
## 常见问题

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等
## 解题框架
### 模版
```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```
## ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678026607989-27c35012-8866-44ab-b14b-c572e471b1ec.png#averageHue=%23fcfbfb&clientId=u02abf051-78a8-4&from=paste&height=263&id=u3f74fb76&name=image.png&originHeight=734&originWidth=1672&originalType=binary&ratio=2&rotation=0&showTitle=false&size=351311&status=done&style=none&taskId=u38889c89-d114-468d-80d1-29ca90338a6&title=&width=600)
### 解题要点

1. 路径：也就是已经做出的选择。
2. 选择列表：也就是你当前可以做的选择。
3. 结束条件：也就是到达决策树底层，无法再做选择的条件。
## 例题
### 子集
> 给你一个整数数组 nums ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。
> 解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。
> 输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
> 来源：[https://leetcode.cn/problems/subsets/](https://leetcode.cn/problems/subsets/)

#### 代码实现
```javascript
function subsets(nums: number[]): number[][] {
  // Think for yourself for 5 minutes...
	// 存放结果
  const res: number[][] = [[]]
	// 回溯路径
  const stack: number[] = []

  const backTrack = (startIndex: number) => {
    // 前序遍历位置，每个节点的值都是一个子集
    if (stack.length) {
      res.push([...stack])
    }

    for (let i = startIndex; i < nums.length; i++) {
      // 做选择
      stack.push(nums[i])
      // 回溯下一层节点
      backTrack(i + 1)
      // 撤销选择
      stack.pop()
    }
  }

  backTrack(0)
  return res
}
```
### ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678107135397-bdbf8e57-0696-44ff-9f23-dee7c5e53708.png#averageHue=%23f8f6f5&clientId=uf7789b61-6803-4&from=paste&height=306&id=u71f985da&name=image.png&originHeight=882&originWidth=1728&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1832792&status=done&style=none&taskId=u3fe7bfb7-eb1e-4e1f-acc2-c15dfeea61d&title=&width=600)
### 子集 II
> 给你一个整数数组 nums ，其中**可能包含重复元素**，请你返回该数组**所有可能的子集**（幂集）。
> 解集 **不能 包含重复的子集**。返回的解集中，子集可以按 任意顺序 排列。
> 输入：nums = [1,2,2] 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
> 来源：[https://leetcode.cn/problems/subsets-ii](https://leetcode.cn/problems/subsets-ii)

#### 代码实现
```javascript

function subsetsWithDup(nums: number[]): number[][] {
  // Think for yourself for 5 minutes...

  const res: number[][] = []

  const track: number[] = []

  const backTrack = (nums: number[], startIndex: number) => {
    res.push([...track])
    for (let i = startIndex; i < nums.length; i++) {
      // 以 1 2 2 为例
      // 当遇到以startIndex为2，如果后面还有数(i > startIndex ),同时当前项num[i]与前一项nums[i-1]相等，说明相邻两个值一样啊
      // 那么之前已经存过相应的子集了，需要跳出循环
      if (i > startIndex && nums[i] == nums[i - 1]) continue
      track.push(nums[i])
      backTrack(nums, i + 1)
      track.pop()
    }
  }
	// 为方便剪枝，需要先排序
  backTrack(nums.sort(), 0)
  return res
}
```
#### Set去重的思路
```javascript
function subsetsWithDupSet(nums: number[]): number[][] {
  // Think for yourself for 5 minutes...

  const res: number[][] = []

  const track: number[] = []

  const backTrack = (nums: number[], startIndex: number) => {
    res.push([...track])

    const usedSet = new Set()

    for (let i = startIndex; i < nums.length; i++) {
      // 可以去掉这一行对比实际的效果
      if (usedSet.has(nums[i])) continue
      usedSet.add(nums[i])
      track.push(nums[i])
      backTrack(nums, i + 1)
      track.pop()
    }
  }

  backTrack(nums, 0)

  return res
}
```
### 👉子集问题归纳

1. 对于不存在重复元素的情况，无虚考虑树遍历过程的重复可能性，因此只需明确startIndex的作用，是在完成“依次”遍历的功能即可。
2. 对于存在重复元素的情况(需要先排序方便操作)，需要考虑在同一层“分别”向下遍历时，当前节点的子集是否已在之前的兄弟节点子集出现过了，因此还需要定义当前层的usedSet用于记录是否同一元素在同一层已经使用过，如果使用过就要绕过，即continue跳出本次循环。
### 组合问题
> 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的** k 个数的组合。**
> 你可以按 **任何顺序** 返回答案。
> 输入：n = 4, k = 2 输出： [   [2,4],   [3,4],   [2,3],   [1,2],   [1,3],   [1,4], ]
> 来源：[https://leetcode.cn/problems/combinations/](https://leetcode.cn/problems/combinations/)

#### 代码实现
```typescript

function combine(n: number, k: number): number[][] {
  // Think for yourself for 5 minutes...

  const  res: number[][] = []

  const track: number[] = []

  const backTracking = (n: number, k: number, startIndex: number): void => {
    if (track.length === k) {
      res.push([...track])
      return
    }
    // 不剪枝的方式
    // for (let i = startIndex; i <= n; i++) {
    //   track.push(i)
    //   backTracking(n, k, i + 1, track)
    //   // 上一步return了之后才会执行这里的pop
    //   track.pop()
    // }

    // 剪枝的操作
    for (let i = startIndex; i <= n - k + track.length + 1; i++) {
      track.push(i)
      //通过 startIndex 参数控制树枝的遍历，避免产生重复的子集
      backTracking(n, k, i + 1)
      track.pop()
    }
  }

  backTracking(n, k, 1)
  return res
}
```
实现思路
把组合问题抽象为如下树结构
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678026907650-c9e244de-53ce-441f-9612-85ee46056a66.png#averageHue=%23fefefe&clientId=u02abf051-78a8-4&from=paste&height=276&id=u6159ace0&name=image.png&originHeight=788&originWidth=1716&originalType=binary&ratio=2&rotation=0&showTitle=false&size=277186&status=done&style=none&taskId=uf8a3ca15-b044-4b6b-b057-e3fc5dcb2f5&title=&width=600)

剪枝过程
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678029960575-e499563a-8c75-4397-a6d5-ddf61a15a5e0.png#averageHue=%23fdfcfc&clientId=u02abf051-78a8-4&from=paste&height=388&id=u8d137941&name=image.png&originHeight=1010&originWidth=1562&originalType=binary&ratio=2&rotation=0&showTitle=false&size=465900&status=done&style=none&taskId=u002831e2-e245-479b-a729-3272285727e&title=&width=600)

### 组合总和
> 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。
> candidates 中的** 同一个 数字可以 无限制重复被选取 **。如果至少一个数字的被选数量不同，则两种组合是不同的。 
> 对于给定的输入，保证和为 target 的不同组合数少于 150 个。
> 输入：candidates = [2,3,6,7], target = 7
> 输出：[[2,2,3],[7]]
> 解释：
> 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
> 7 也是一个候选， 7 = 7 。仅有这两种组合。
> 来源：[https://leetcode.cn/problems/combination-sum](https://leetcode.cn/problems/combination-sum)

#### 代码实现
```typescript
function combinationSum(candidates: number[], target: number): number[][] {
  // Think for yourself for 5 minutes...

  const res: number[][] = []

  const track: number[] = []

  let numSum: number = 0

  const backTrack = (nums: number[], startIndex: number) => {
    if (numSum > target) {
      return
    }

    if (numSum === target) {
      res.push([...track])
      return
    }
	  // 剪枝的操作，当前值和numSum如果已经大于总和了就没必要进入下一次递归了
    // for (let i = startIndex; i < nums.length && numSum + nums[i] <= target; i++) {
    for (let i = startIndex; i < nums.length; i++) {

      numSum += nums[i]
      track.push(nums[i])

      // 同一元素可以重复使用，因此下次也可以是i当前元素
      backTrack(nums, i)

      numSum -= nums[i]
      track.pop()
    }
  }

  backTrack(candidates, 0)

  return res
}

```
### 组合总和 II
> 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
> candidates 中的**每个数字在每个组合中只能使用 一次 。**
> 注意：解集不能包含重复的组合。 
> 输入: candidates = [10,1,2,7,6,1,5], target = 8,
> 输出: [[1,1,6],[1,2,5],[1,7],[2,6]]
> 来源：[https://leetcode.cn/problems/combination-sum-ii](https://leetcode.cn/problems/combination-sum-ii)

#### 代码实现
```javascript

// 这里借用子集2的思路，再维护一个subNum即可
function combinationSum2(candidates: number[], target: number): number[][] {
  // Think for yourself for 5 minutes...

  const res: number[][] = []

  const track: number[] = []

  let sumNum: number = 0

  const backTrack = (nums: number[], startIndex: number) => {
    if (sumNum === target) {
      res.push([...track])
    }
  	// 当已经大于目标值了，就直接跳过
    if (sumNum > target) {
      return
    }

    
    for (let i = startIndex; i < nums.length; i++) {
      // 以 1 2 2 为例
      // 当遇到以startIndex为2，如果后面还有数(i > startIndex ),同时当前项num[i]与前一项nums[i-1]相等
      // 那么之前已经存过相应的子集了，需要跳出循环
      if (i > startIndex && nums[i] == nums[i - 1]) continue
      
      track.push(nums[i])
      sumNum += nums[i]
      
      backTrack(nums, i + 1)
      
      track.pop()
      sumNum -= nums[i]
    }
  }

  backTrack(candidates.sort(), 0)

  return res
}
```
#### Set去重的思路
```javascript

function combinationSum2Set(candidates: number[], target: number): number[][] {
  // Think for yourself for 5 minutes...

  const res: number[][] = []

  const track: number[] = []

  let sumNum: number = 0

  const backTrack = (nums: number[], startIndex: number) => {
    if (sumNum > target) return

    if (sumNum === target) {
      res.push([...track])
      return
    }
    // 同一层去重
    const usedSet = new Set()

    for (let i = startIndex; i < nums.length; i++) {
      // 可以去掉这一行对比实际的效果
      if (usedSet.has(nums[i])) continue

      usedSet.add(nums[i])
      track.push(nums[i])
      sumNum += nums[i]

      backTrack(nums, i + 1)

      track.pop()
      sumNum -= nums[i]
    }
  }

  backTrack(candidates.sort(), 0)

  return res
}
```
### 👉组合问题归纳

1. 对于限定了只需要k个元素的子集，需要考虑下一层遍历是否会超出实际需要，因此将for循环终止条件调整为i <= n - k + track.length + 1 即为剪枝，避免对结果不产生意义的多余递归。
2. 对于存在重复元素的待选数组(需要先排序方便操作)，如果需要考虑**每个数字在每个组合中只能使用一次，**同样要想到采用set去标记同一层元素的使用记录情况(或者当if (i > startIndex && nums[i] == nums[i - 1])) 时也表明当前元素与前一元素相同，那么当前元素的子集一定已经在前一元素的子集遍历过了），这样的思路去完成剪枝。
### 全排列
> 给定一个**不含重复数字**的数组 nums ，返回其 **所有可能的全排列** 。你可以 按任意顺序 返回答案。
> 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> 来源：[https://leetcode.cn/problems/permutations/](https://leetcode.cn/problems/permutations/)

#### 代码实现
```typescript

function permute(nums: number[]): number[][] {
  // Think for yourself for 5 minutes...
  const res: number[][] = []

  const track: number[] = []

  const used: boolean[] = []

  const backTrack = (nums: number[]) => {
    // 满足条件添加到结果集
    if (track.length === nums.length) {
      res.push([...track])
    }

    for (let i = 0; i < nums.length; i++) {
      // 如果track中已经选择过，就要跳过
      if (used[i]) continue

      used[i] = true
      track.push(nums[i])
      backTrack(nums)
      track.pop()
      used[i] = false
    }
  }

  backTrack(nums)

  return res
}
```
### ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678241155991-9b80a583-8c6c-4f61-810a-9738c35c2385.png#averageHue=%23f3f3f3&clientId=u4ca02514-31db-4&from=paste&height=314&id=u84d0cff1&name=image.png&originHeight=790&originWidth=1510&originalType=binary&ratio=2&rotation=0&showTitle=false&size=261461&status=done&style=none&taskId=u02c2d8ad-38cb-44b8-8388-6210184de15&title=&width=600)
###  全排列 II
> 给定一个可包含重复数字的序列 nums ，_**按任意顺序**_ 返回所有**不重复的全排列**。
> 输入：nums = [1,1,2] 输出： [[1,1,2],  [1,2,1],  [2,1,1]]
> 来源：[https://leetcode.cn/problems/permutations-ii/](https://leetcode.cn/problems/permutations-ii/)

#### 代码实现
```javascript

function permuteUnique(nums: number[]): number[][] {
  // Think for yourself for 5 minutes...

  const res: number[][] = []

  const track: number[] = []

  const used: boolean[] = []

  const backTrack = (nums: number[]) => {
    if (track.length === nums.length) {
      res.push([...track])
      return
    }

    for (let i = 0; i < nums.length; i++) {
      // 选择过要跳过
      if (used[i]) continue
    	// 相邻元素相等且前一个元素已用过也跳过
      // !used[i - 1] 和 used[i - 1] 都能获取到结果，但是used[i - 1]会经过多余的路径,具体详解看labuladong
      if (nums[i] == nums[i - 1] && !used[i - 1]) continue
      
      used[i] = true
      track.push(nums[i])
      
      backTrack(nums)
      
      used[i] = false
      track.pop()
    }
  }

  backTrack(nums.sort())
  
  return res
}
```
#### Set去重的思路
```javascript

function permuteUniqueSet(nums: number[]): number[][] {
  // Think for yourself for 5 minutes...

  const res: number[][] = []

  const track: number[] = []

  const used: boolean[] = []

  const backTrack = (nums: number[]) => {
    if (track.length == nums.length) {
      res.push([...track])
      return
    }

    const usedSet = new Set()
    for (let i = 0; i < nums.length; i++) {
      if (usedSet.has(nums[i]) || used[i]) continue

      usedSet.add(nums[i])
      used[i] = true
      track.push(nums[i])

      backTrack(nums)
      track.pop()
      used[i] = false
    }
  }

  backTrack(nums.sort())

  return res
}
```
### 👉全排列问题归纳

1. 对于不含重复数字的数组，实现全排列需要明确因为[1,2]和[2,1]是两种不同的子集，因此每次都需要从头开始，因此它不需要startIndex，而used是用来记录在同一路径上的使用记录，因为“排列”即不存在重复元素
2. 对于**可能包含重复元素**的数组(需要先排序方便操作)，需要在used记录路径上使用情况的同时，附加当前项在前一项是否已遍历过子集的情况，即同一层元素不能重复，采用Set记录或nums[i]==nums[i-1]都可以实现
### 复原IP
> 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
> 例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
> 给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。
> 输入：s = "25525511135" 输出：["255.255.11.135","255.255.111.35"]
> 来源：[https://leetcode.cn/problems/restore-ip-addresses](https://leetcode.cn/problems/restore-ip-addresses)

#### 代码实现
```javascript

function restoreIpAddresses(s: string): string[] {
  // Think for yourself for 5 minutes...

  // 1. 不能多于4个整数
  // 2. 每一位在0-255范围内

  const res: string[] = []

  const isValid = (strArr: string[]) => {
    return (
      strArr.length == 4 &&
      strArr.join('') == s &&
      strArr.every(
        (item) => /^(0|[1-9][0-9]*)$/.test(item) && Number(item) >= 0 && Number(item) <= 255
      )
    )
  }

  const track: string[] = []

  const backTrack = (str: string, startIndex: number) => {
    // console.log('track', track)
    if (track.length > 4) return
    if (isValid(track)) {
      res.push(track.join('.'))
      return
    }

    for (let i = startIndex; i < str.length; i++) {
      const nextStr = str.slice(startIndex, i + 1)
      // 剪枝
      // 如果当前数字长度大于3 且大于255 不满足条件
      if (nextStr.length > 3 && +nextStr > 255) continue

      // 如果当前长度大于1 且第一位是0 不满足条件
      if (nextStr.length > 1 && nextStr[0] === '0') continue

      track.push(nextStr)
      backTrack(str, i + 1)
      track.pop()
    }
  }

  backTrack(s, 0)
  return res
}

```
#### 不需要验证数字有效性的版本
```javascript
function restoreIpAddresses(s: string): string[] {
  const res: string[] = []

  const track: string[] = []

  const backTrack = (str: string, startIndex: number) => {
    if (track.length > 4) return
    // 如果是有效的一定得找到最后的叶子节点上去，所以startIndex == str.length一定不会出现无效数字
    if (track.length === 4 && startIndex == str.length) {
      res.push(track.join('.'))
      return
    }

    for (let i = startIndex; i < str.length; i++) {
      const nextStr = str.slice(startIndex, i + 1)
      if (nextStr.length > 3 && +nextStr > 255) continue
      if (nextStr.length > 1 && nextStr[0] === '0') continue
      track.push(nextStr)
      backTrack(str, i + 1)
      track.pop()
    }
  }

  backTrack(s, 0)
  return res
}
```
### 递增子序列
> 给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。
> 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。
> 输入：nums = [4,6,7,7]
> 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
> 来源：[https://leetcode.cn/problems/non-decreasing-subsequences](https://leetcode.cn/problems/non-decreasing-subsequences)

#### 代码实现
```javascript
function findSubsequences(nums: number[]): number[][] {
  // Think for yourself for 5 minutes...

  // 1. 至少两个元素
  // 2. 如果相邻两数相等也可以

  const res: number[][] = []

  const track: number[] = []

  const backTrack = (nums: number[], startIndex: number) => {
    if (track.length >= 2) {
      res.push([...track])
    }
    // 声明在这里表示仅在当前同一层里判断是否已使用过
    const usedSet: Set<number> = new Set()
    for (let i = startIndex; i < nums.length; i++) {
      const curNum = nums[i]
      // 如果当前数小于之前路径最后一个数说明不满足递增，且当同一层已使用过就不能再重复使用了
      if (curNum < track[track.length - 1] || usedSet.has(nums[i])) continue

      usedSet.add(nums[i])
      track.push(nums[i])

      backTrack(nums, i + 1)
      track.pop()
    }
  }

  backTrack(nums, 0)

  return res
}
// 注：set可以改用为hash存储
```
### ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678199290550-325f830f-ff70-4619-a527-d850271bb6cf.png#averageHue=%23f5f4f4&clientId=uadb1ed52-62b0-4&from=paste&height=313&id=u3b44ac46&name=image.png&originHeight=778&originWidth=1492&originalType=binary&ratio=2&rotation=0&showTitle=false&size=280121&status=done&style=none&taskId=ub58bce30-5082-4485-96f1-4bfedc7554e&title=&width=600)


### 电话号码的字母组合
> 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678024704618-bf699aa3-379e-49f2-8c14-a33300c7485a.png#averageHue=%2360615d&clientId=u45a70db1-cf6a-4&from=paste&height=81&id=mhZ4Y&name=image.png&originHeight=162&originWidth=200&originalType=binary&ratio=2&rotation=0&showTitle=false&size=52943&status=done&style=none&taskId=u4207e51d-db26-4512-aa1e-4aa968eb305&title=&width=100)
> 输入：digits = "23" 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
> 来源：[https://leetcode.cn/problems/letter-combinations-of-a-phone-number/](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

#### 代码实现
```javascript

function letterCombinations(digits: string): string[] {
  // Think for yourself for 5 minutes...

  const track: string[] = []

  const res: string[] = []

  const arr = [
    '', // 0
    '', // 1
    'abc', // 2
    'def', // 3
    'ghi', // 4
    'jkl', // 5
    'mno', // 6
    'pqrs', // 7
    'tuv', // 8
    'wxyz', // 9
  ]
  const k = digits.length
  // 空字符串
  if (!digits) return []

  // 一个数字的情况
  if (k === 1) return arr[digits].split('')

  const backTrack = (str: string, startIndex: number) => {
    if (track.length == k) {
      res.push(track.join(''))
      return
    }

    // 当前位置的字母
    const letter = arr[str[startIndex]]

    // for (let i = 0; i < letter.length; i++) {
    //   track.push(letter[i])
    //   backTrack(str, startIndex + 1)
    //   track.pop()
    // }
    for (const v of letter) {
        track.push(v)
        backTrack(str, startIndex + 1)
        track.pop()
    }
  }

  backTrack(digits, 0)
  return res
}

```

### N皇后
> 每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678202069066-f029e184-f130-415f-8be0-44085ef6f420.png#averageHue=%23161816&clientId=uadb1ed52-62b0-4&from=paste&height=374&id=uea84828c&name=image.png&originHeight=748&originWidth=1386&originalType=binary&ratio=2&rotation=0&showTitle=false&size=263770&status=done&style=none&taskId=ubba18cc8-529a-4c5f-9570-ec25782509a&title=&width=693)
> 来源：[https://leetcode.cn/problems/n-queens/](https://leetcode.cn/problems/n-queens/)

#### 代码实现
```typescript

function solveNQueens(n: number): string[][] {
  // Think for yourself for 5 minutes...

  const res: string[][] = []

  const solution: string[][] = new Array(n).fill([]).map(() => new Array(n).fill('.'))

  const isSafe = (row: number, col: number, solution: string[][], n: number) => {
    // 检查列
    for (let i = 0; i < row; ++i) {
      if (solution[i][col] == 'Q') {
        return false
      }
    }

    // 检查45度对角线，左上角
    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
      if (solution[i][j] == 'Q') {
        return false
      }
    }

    // 检查135度对角线，右上角
    for (let i = row - 1, j = col + 1; i >= 0 && j <= n - 1; i--, j++) {
      if (solution[i][j] == 'Q') {
        return false
      }
    }
    return true
  }

  const formatSolution = (solution: string[][]) => {
    return [...solution].map((el) => el.join(''))
  }

  const backTrack = (row: number) => {
    if (row === n) {
      // console.log('solution', formatSolution(solution))
      res.push([...formatSolution(solution)])
      return
    }

    for (let col = 0; col < n; col++) {
      if (isSafe(row, col, solution, n)) {
        solution[row][col] = 'Q'
        backTrack(row + 1)
        solution[row][col] = '.'
      }
    }
  }
  // 先从第一行开始
  backTrack(0)

  return res
}
```
### 迷宫老鼠
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677330045008-98f03ead-37cc-40f2-83a1-2bbcc8fdd97e.png#averageHue=%23ececec&clientId=u931b9b52-9b22-4&from=paste&height=182&id=ub5fc120b&name=image.png&originHeight=556&originWidth=1830&originalType=binary&ratio=2&rotation=0&showTitle=false&size=153360&status=done&style=none&taskId=u0adc9ba3-b50a-4569-bf99-6362ca703d1&title=&width=600)
#### 代码实现
```javascript
/*
 * Description:  迷宫老鼠
 * 1 是可以走的点，0是被阻挡的点
 * [
 *  [1,0,0,0],
 *  [1,1,1,1],
 *  [0,0,1,0],
 *  [0,1,1,1]
 * ]
 */

const isSafe = (maze: number[][], x: number, y: number) => {
  const n = maze.length
  // 边界 x>0 && y>0 && x<n && y<n
  if (x >= 0 && y >= 0 && x < n && y < n && maze[x][y] !== 0) {
    return true
  }
  return false
}

// 回溯，处理结果
const findWay = (maze: number[][], x: number, y: number, solution: number[][]):boolean => {
  const n = maze.length
  // 到达终点了
  if (x === n - 1 && y === n - 1) {
    solution[x][y] = 1
    return true
  }

  if (isSafe(maze, x, y) === true) {
    solution[x][y] = 1

    // 向右移动
    if (findWay(maze, x + 1, y, solution) === true) {
      return true
    }

    // 向下移动
    if (findWay(maze, x, y + 1, solution) === true) {
      return true
    }
    // 上面如果向右或向下移动成功就不会走到这里
    solution[x][y] = 0
    return false
  }
  return false
}

const ratInAMaze = (maze: number[][]) => {
  // 先初始化解决方案
  const solution: number[][] = []
  for (let i = 0; i < maze.length; i++) {
    solution[i] = []
    for (let j = 0; j < maze.length; j++) {
      solution[i][j] = 0
    }
  }
  if (findWay(maze, 0, 0, solution) === true) {
    return solution
  }

  return 'empty'
}
// result
// [1, 0, 0, 0],
// [1, 1, 1, 0],
// [0, 0, 1, 0],
// [0, 0, 1, 1],

```
实现过程
step1: 初始化解决方案矩阵
step2: 从0,0点出发开始尝试向右和向下移动，将可以移动的点标记为1，不能移动的点标记为0，同时要确定边界，当前点是否在上下左右边界围内
findWay由递归实现，递归终止条件是x,y到达矩阵的右下角
### 数独解题
> 编写一个程序，通过填充空格来解决数独问题。
> 数独的解法需 遵循如下规则：
> 数字 1-9 在每一行只能出现一次。
> 数字 1-9 在每一列只能出现一次。
> 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
> 数独部分空格内已填入了数字，空白格用 '.' 表示。
> 来源：[https://leetcode.cn/problems/sudoku-solver](https://leetcode.cn/problems/sudoku-solver)
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677331650755-8de23299-7fe0-4a4c-9456-b681b0d25ca0.png#averageHue=%23e1e1e0&clientId=u931b9b52-9b22-4&from=paste&height=291&id=ub7b627cd&name=image.png&originHeight=582&originWidth=580&originalType=binary&ratio=2&rotation=0&showTitle=false&size=117930&status=done&style=none&taskId=u8aef7507-4b49-4033-8073-6985efa782a&title=&width=290)

#### 代码实现
```javascript
// 用例
const board = [
      ['5', '3', '.', '.', '7', '.', '.', '.', '.'],
      ['6', '.', '.', '1', '9', '5', '.', '.', '.'],
      ['.', '9', '8', '.', '.', '.', '.', '6', '.'],
      ['8', '.', '.', '.', '6', '.', '.', '.', '3'],
      ['4', '.', '.', '8', '.', '3', '.', '.', '1'],
      ['7', '.', '.', '.', '2', '.', '.', '.', '6'],
      ['.', '6', '.', '.', '.', '.', '2', '8', '.'],
      ['.', '.', '.', '4', '1', '9', '.', '.', '5'],
      ['.', '.', '.', '.', '8', '.', '.', '7', '9'],
]


const UNASSIGNED = '.' // 还没被放的

const isSafe = (matrix: string[][], row: number, col: number, num: string) => {
  for (let row = 0; row < matrix.length; row++) {
    // 列里是否有重复
    if (matrix[row][col] === num) {
      return false
    }
  }
  for (let col = 0; col < matrix.length; col++) {
    // 行里是否有重复
    if (matrix[row][col] === num) {
      return false
    }
  }

  let startRow = row - (row % 3)
  let startCol = col - (col % 3)
  for (let i = 0; i < 3; i++) {
    // 以当前位置为基准，判断9方格里是否有重复
    for (let j = 0; j < 3; j++) {
      if (matrix[i + startRow][j + startCol] === num) {
        return false
      }
    }
  }

  return true
}

const solveSudoku = (board: string[][]) => {
  let row = 0
  let col = 0
  let checkBlackSpace = false
  for (row = 0; row < board.length; row++) {
    for (col = 0; col < board[row].length; col++) {
      // 如果有空白需要跳出
      if (board[row][col] === UNASSIGNED) {
        checkBlackSpace = true
        break
      }
    }
    if (checkBlackSpace === true) {
      break
    }
  }
  // 说明没有空白，已经被解了
  if (checkBlackSpace === false) return board

  for (let num = 1; num <= 9; num++) {
    if (isSafe(board, row, col, String(num))) {
      board[row][col] = String(num)
      if (solveSudoku(board)) {
        return true
      }
      board[row][col] = UNASSIGNED
    }
  }

  return false
}

const sudokuSolver = (board: string[][]) => {
  if (solveSudoku(board)) {
    return board
  }
  return '无解'
}
```

### 括号生成
> 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的 **括号组合。
> 输入：n = 3 输出：["((()))","(()())","(())()","()(())","()()()"]
> 来源：[https://leetcode.cn/problems/generate-parentheses/](https://leetcode.cn/problems/generate-parentheses/)

#### 代码实现
```typescript
function generateParenthesis(n: number): string[] {
  // Think for yourself for 5 minutes...

  // q1. 所有的有效的括号
  // q2. 如果左括号不大于n，我们可以放一个左括号，如果右括号数量小于左括号数量，可以放一个右括号

  if (n == 1) return ['()']

  const res: string[] = []

  const track: string[] = []

  const backTrack = (open: number, close: number) => {
    // console.log('track', track)
    if (track.length == n * 2) {
      res.push([...track].join(''))
    }

    if (open < n) {
      track.push('(')
      backTrack(open + 1, close)
      track.pop()
    }

    if (close < open) {
      track.push(')')
      backTrack(open, close + 1)
      track.pop()
    }
  }

  backTrack(0, 0)

  return res
}
```

### 目标和
> 给你一个整数数组 nums 和一个整数 target 。
> 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：
> 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
> 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
> 输入：nums = [1,1,1,1,1], target = 3  输出：5
> 解释：一共有 5 种方法让最终目标和为 3 。
> -1 + 1 + 1 + 1 + 1 = 3
> +1 - 1 + 1 + 1 + 1 = 3
> +1 + 1 - 1 + 1 + 1 = 3
> +1 + 1 + 1 - 1 + 1 = 3
> +1 + 1 + 1 + 1 - 1 = 3
> 来源：[https://leetcode.cn/problems/target-sum](https://leetcode.cn/problems/target-sum)

#### 代码实现
```javascript
// 此版本超出限制
function findTargetSumWays1(nums: number[], target: number): number {
  // Think for yourself for 5 minutes...

  // q1. 第一项元素的前面可以加符号
  // q2. track的长度==nums.length 的时候表示所有数和能加符号的位置都满足了

  let count = 0

  const track: string[] = []

  const symbol: string[] = ['-', '+']

  const formatSolute = (track: string[]): number => {
    let res: number = 0
    for (let i = 0; i < track.length; i++) {
      res += Number(track[i])
    }
    return res
  }

  const backTrack = (nums: number[], startIndex: number) => {
    // console.log('track', track)

    if (track.length === nums.length) {
      // console.log('track', track)
      const res = formatSolute(track)
      if (res == target) {
        count++
      }
    }

    for (let i = startIndex; i < nums.length; i++) {
      for (let j = 0; j < symbol.length; j++) {
        const cur = `${symbol[j]}${nums[i]}`
        track.push(cur)
        backTrack(nums, i + 1)
        track.pop()
      }
    }
  }

  backTrack(nums, 0)

  return count
}

function findTargetSumWays(nums: number[], target: number): number {
  let count = 0

  const backTrack = (nums: number[], index: number, sum: number) => {
    if (index === nums.length) {
      if (sum === target) {
        count++
      }
    } else {
      backTrack(nums, index + 1, sum + nums[index])
      backTrack(nums, index + 1, sum - nums[index])
    }
  }

  backTrack(nums, 0, 0)

  return count
}

```
## 👉总结归纳
当问题的特征可以领会到“从n个序列中找出k个子序列”或“由n个序列生成m个序列”类似的含义时，考虑采用回溯。
### 梳理
脑子里要生成一棵树，将元素罗列开，顺着单个元素铺开N叉树，确定路径，“下一次”是重新开始，开始要以当前点为基准继续，因此需要考虑使用startIndex的情况。

对于如何剪枝，存在两种情况，即横向剪枝和纵向简直，在同一层剪枝，需要在for循环外层记录used，或者在同一路径剪枝，需要在最外层记录used(比较清晰)。

因为回溯和递归是相辅相成的，因此必须考虑递归的终止条件，满足什么条件即可将路径push到结果。

该类问题通常会多加一个限定条件以加大题目难度，例如组合求和、电话号码字母组合、复原IP，但还是保持回溯的整体框架不变，将附加条件在push结果的时候同时判断限制即可。

在N皇后、迷宫老鼠、数独解题的问题中，都涉及到了二维矩阵，路径即从[0,0]点开始到[n-1,n-1]结束，在此过程中更加复杂的条件是确定路径边界，同时考虑经过位置是否满足题解条件，一般操作是一层for循环，即一行一行的执行探路和回溯，将结果存入solution矩阵，最终根据solution求得符合题解的结果。

### 解题步骤

1. 定义状态：定义问题的状态表示方法。状态表示需要满足可行、可用、唯一的要求。
2. 状态转移：根据问题的定义，分析问题的状态转移规律，即每个状态下一步可以转移到哪些状态，以及转移所需的操作。
3. 确定边界：确定回溯算法应该终止的边界条件，即搜索过程应该终止的条件。这往往依赖于问题的定义。
4. 实现回溯算法：在代码中实现回溯算法，包括设置状态、状态转移、回溯等主要步骤。
5. 剪枝：实际应用时，可以对回溯算法进行剪枝优化，以提高算法的效率。剪枝的方式包括可行性剪枝、可约束性剪枝、最优性剪枝等。

在实际应用回溯算法时，还需要注意以下问题：

1. 在状态转移时，可能会涉及到多个选择，必须按照某种规则依次进行选择，而不能随意变更选择顺序。
2. 回溯算法可能会生成大量的中间状态，必须考虑如何有效的存储和恢复状态，以避免内存占用和时间浪费等问题。
3. 回溯算法的时间复杂度通常非常高，必须考虑如何进行剪枝以提高效率。
## 资料
carl 回溯算法算法题解
labuladong
labuladong 回溯算法题解
