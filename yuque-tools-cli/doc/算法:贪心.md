# 算法:贪心 
## 特征
贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。
## 贪心的本质

1. 贪心选择性质。指原问题的整体最优解可以通过一系列局部最优的选择得到。应用同一规则，将原问题变为一个相似的、但规模更小的子问题，**而后的每一步都是当前最优**的选择。

（例如在涉及部分“最少”/“最多”的问题中，一般在循环遍历中假定当前值就是那个最值，然后不断更新）

2. 最优子结构性质。当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678435639068-0487a56b-f29c-4b00-80e6-3a81c8b450dd.png#averageHue=%23fefefc&clientId=u534ee4df-dd47-4&from=paste&height=199&id=u28357ec0&name=image.png&originHeight=524&originWidth=1580&originalType=binary&ratio=2&rotation=0&showTitle=false&size=253558&status=done&style=none&taskId=u08a17e09-f01f-4422-ae25-aead3aa3664&title=&width=600)

## 例题
### 最少硬币找零
大部分情况下的结果是最优的，不过对有些面额而言，结果不会是最优的。
#### 代码实现
```javascript
/**
 * eg:[1, 2, 5, 10, 20], 36
 * @param coins 硬币数组
 * @param amount 金额
 */
const minCoinChange2 = (coins: number[], amount: number) => {
  const change: number[] = []
  let total = 0
  for (let i = coins.length; i >= 0; i--) {
    const coin = coins[i]
    while (total + coin <= amount) {
      change.push(coin)
      total += coin
    }
  }
  return change  // [20, 10, 5, 1]
}

```
比起动态规划算法而言，贪心算法更简单、更快。然而，如我们所见，它并不总是得到最优答案。
然而，如果用[1, 3, 4]面额执行贪心算法，会得到结果[4, 1, 1]。如果用动态规划的解法，会得到最优的结果[3, 3]。
在找零这类问题中，当币种间隔越大，算法的效率和准确性就越高，反之采用动态规划才是更适合的找寻最优解的方案。
### 跳跃游戏
> 给定一个非负整数数组 nums ，你最初位于数组的 **第一个下标** 。
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
> 判断你是否能够到达最后一个下标。
> 输入：nums = [2,3,1,1,4] 输出：true 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
> 来源：[https://leetcode.cn/problems/jump-game/](https://leetcode.cn/problems/jump-game/)

#### 代码实现
```typescript
function canJump(nums: number[]): boolean {
  // Think for yourself for 5 minutes...

  let furthest: number = 0 // 记录每一步最远的距离

  for (let i = 0; i < nums.length - 1; i++) {
    // 当前索引i+当前可以跳的步数num[i] 就是当前位置可以跳的最远的位置
    furthest = Math.max(furthest, i + nums[i])
    if (furthest <= i) {
      // 跳不动了
      return false
    }
  }
  console.log('furthest', furthest)
  return furthest >= nums.length - 1
}
```
###  跳跃游戏 II
> 给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。
> 每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:
> 0 <= j <= nums[i] 
> i + j < n
> 返回到达 nums[n - 1] 的**最小跳跃次数**。生成的测试用例可以到达 nums[n - 1]。
> 输入: nums = [2,3,1,1,4]  输出: 2
> 解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
> 来源：[https://leetcode.cn/problems/jump-game-ii](https://leetcode.cn/problems/jump-game-ii)

#### 代码实现1
```javascript
/**
 * 反向找到出发位置
 * @param nums
 * @returns
 */
function jump(nums: number[]): number {
  // Think for yourself for 5 minutes...
  let minSteps: number = 0
  let position = nums.length - 1
  while (position > 0) {
    for (let i = 0; i < position; i++) {
      // 说明当前位置直接跳不到,下一步要从当前位置出发
      if (i + nums[i] >= position) {
        minSteps += 1
        position = i
        break
      }
    }
  }

  return minSteps
}
```
#### 代码实现2
```javascript

/**
 * 正向找 可以跳最大一步的位置
 * @param nums
 * @returns
 */
function jump(nums: number[]): number {
  
  let minSteps: number = 0

  let end = 0
  let maxPosition = 0
  for (let i = 0; i < nums.length - 1; i++) {
    maxPosition = Math.max(maxPosition, i + nums[i])
    if (i === end) {
      end = maxPosition
      minSteps++
    }
  }

  return minSteps
}
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678374596747-518f6165-6ddc-437b-962e-fcfad7f9a6b9.png#averageHue=%23faf8f8&clientId=u4ed4ea98-64f7-4&from=paste&height=361&id=ub34ca2f9&name=image.png&originHeight=864&originWidth=1438&originalType=binary&ratio=2&rotation=0&showTitle=false&size=216130&status=done&style=none&taskId=u5106f664-4341-49ed-aa6d-94aa11ac68e&title=&width=600)
### 分发饼干
> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
> 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
> 输入: g = [1,2,3], s = [1,1]  输出: 1
> 解释: 
> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
> 所以你应该输出1。
> 来源：[https://leetcode.cn/problems/assign-cookies](https://leetcode.cn/problems/assign-cookies)

#### 代码实现
```typescript
/**
 * 先满足大胃口的思路，->>> 也可以先满足小胃口
 * @param g
 * @param s
 * @returns
 */
function findContentChildren(g: number[], s: number[]): number {
  let count: number = 0

  g.sort((a, b) => a - b)
  s.sort((a, b) => a - b)

  let maxIndex = s.length - 1

  for (let i = g.length - 1; i >= 0; i--) { // 倒序
    if (maxIndex >= 0 && s[maxIndex] >= g[i]) {
      count++
      maxIndex--
    }
  }

  return count
}
```
### 分发糖果
> n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。
> 你需要按照以下要求，给这些孩子分发糖果：
> 每个孩子至少分配到 1 个糖果。
> 相邻两个孩子评分更高的孩子会获得更多的糖果。
> 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。
> 输入：ratings = [1,0,2]   输出：5   解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。 
> 来源：[https://leetcode.cn/problems/candy](https://leetcode.cn/problems/candy)

#### 代码实现
```typescript
// 当遇到两个维度的条件时，一定是分两步去实现
function candy(ratings: number[]): number {
  const solution: number[] = new Array(ratings.length).fill(1)
  // 从前往后
  for (let i = 1; i < ratings.length; i++) {
    // 当前孩子评分高于前一个孩子，当前孩子就比前一个孩子多一个糖果
    if (ratings[i] > ratings[i - 1]) {
      solution[i] = solution[i - 1] + 1
    }
  }

  // 从后往前
  for (let i = ratings.length - 1; i >= 0; i--) {
    // 当前孩子评分高于后一个孩子，比较当前孩子相比前面的多个孩子和后面一个孩子那种可以获得更多
    if (ratings[i] > ratings[i + 1]) {
      solution[i] = Math.max(solution[i], solution[i + 1] + 1)
    }
  }

  return solution.reduce((prev, curr) => prev + curr)
}
```
#### 另一个版本
```typescript
function candy(ratings: number[]): number {
  const n = ratings.length

  let res: number = 1 // 以最少的开始计数，第一个同学就是1个了，因此下面i从1开始
  let inc: number = 1 // 递增序列长度
  let dec: number = 0 // 递减序列长度
  let pre: number = 1

  for (let i = 1; i < n; i++) {
    // 说明呈递增
    if (ratings[i] >= ratings[i - 1]) {
      dec = 0
      pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1
      res += pre
      inc = pre
    } else {
      dec++ // 递减
      if (dec == inc) {
        dec++
      }
      res += dec
      pre = 1
    }
  }

  return res
}
```
### 摆动序列
> 如果连续数字之间的**差严格地在正数和负数之间交替**，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
> 给你一个整数数组 nums ，返回 nums 中作为 **摆动序列 **的 **最长子序列的长度** 。
> 输入：nums = [1,7,4,9,2,5] 输出：6 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
> 来源：[https://leetcode.cn/problems/wiggle-subsequence](https://leetcode.cn/problems/wiggle-subsequence)

#### 代码实现
```typescript
/**
* 记录上一次差值和当前差值，当前后差值正负不同时就更新上一次差值，然后计数
*/
function wiggleMaxLength(nums: number[]): number {
  // Think for yourself for 5 minutes...
  if (nums.length <= 1) return nums.length

  let count: number = 1

  let curDiff = 0 
  let preDiff = 0
  // curDiff和preDiff会在正负数之间交替变换
  for (let i = 0; i < nums.length; i++) {
    curDiff = nums[i + 1] - nums[i]
    // 出现峰值,拐点
    if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
      count++
      preDiff = curDiff
    }
  }

  return count
}
```

思路分析

1. 情况一：上下坡中有平坡
2. 情况二：数组首尾两端 (只有两个数字的情况)
3. 情况三：单调坡中有平坡
#### 动态规划版
```typescript

/**
 * 动态规划 O(n^2)
 * dp[i][0] 表示以i位置结尾的区间内出现山谷的次数
 * dp[i][1] 表示以i位置结尾的区间内出现山峰的次数
 * @param nums
 */
function wiggleMaxLength(nums: number[]): number {
  const n = nums.length
  const dp: number[][] = new Array(n).fill(0).map(() => new Array(n).fill(0))

  for (let i = 1; i < nums.length; i++) {
    dp[0][0] = 1
    dp[0][1] = 1

    // 山谷
    for (let j = 0; j < i; j++) {
      if (nums[j] > nums[i]) {
        dp[i][1] = Math.max(dp[i][1], dp[j][0] + 1)
      }
    }

    // 山峰
    for (let j = 0; j < i; j++) {
      if (nums[j] < nums[i]) {
        dp[i][0] = Math.max(dp[i][0], dp[j][1] + 1)
      }
    }
  }
  return Math.max(dp[n - 1][0], dp[n - 1][1])
}
```
思路分析
对于i所在位置的数，要么是山峰nums[i]>nums[i-1]，要么是山谷nums[i]<nums[i-1]
设dp[i][0]  // 表示考虑前i个数，第i个数作为山峰的最长子序列长度
设dp[i][1]  // 表示考虑前i个数，第i个数作为山谷的最长子序列长度
因此可得状态转移方程
> dp[i][0] = max(dp[i][0], dp[j][1] + 1)，其中0 < j < i且nums[j] < nums[i] ，表示将nums[i]接到前面某个山谷后面，作为山峰。
> dp[i][1] = max(dp[i][1], dp[j][0] + 1)，其中0 < j < i且nums[j] > nums[i]，表示将nums[i]接到前面某个山峰后面，作为山谷。

### ⭐️最大子数组和
> 给你一个整数数组 nums ，请你找出一个具有**最大和的连续子数组**（子数组最少包含一个元素），返回其**最大和。**
> **子数组 **是数组中的一个连续部分。
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
> 来源：[https://leetcode.cn/problems/maximum-subarray/](https://leetcode.cn/problems/maximum-subarray/)

#### 代码实现
```typescript
function maxSubArray(nums: number[]): number {
  let max = nums[0];
  let pre = 0;

  for (let i = 0; i < nums.length; i++) {
    pre = Math.max(pre + nums[i], nums[i]);  // 当pre足够大时到这里就会被更新，否则说明pre较小,不被算作结果范围内
    max = Math.max(pre, max);
  }

  return max;
}
```
```typescript
// 更好理解的版本
function maxSubArray(nums: number[]): number {
  let count = 0
  let res = Number.MIN_SAFE_INTEGER  // 就算全是负数也会更新 
  for (let i = 0; i < nums.length; i++) {
    count += nums[i]
    if (count > res) {
      res = count //  取区间累计的最大值（相当于不断确定最大子序终止位置)
    }
    if (count <= 0) count = 0 // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
  }
  return res
}
```
#### 动态规划版
```typescript
function maxSubArrayBydp(nums: number[]): number {
  // Think for yourself for 5 minutes...
  // dp[i]的含义是 表示i位置及之前的最大和
  // 比较两种情况
  // a. 前一项dp+当前项 dp[i-1] + nums[i]
  // b. nums[i]
  // 因为要依赖i-1，第 0项不能依赖于for循环 dp[0]=nums[0]
  const n = nums.length
  if (n === 0) return 0
  
  const dp: number[] = Array(n).fill(0)
  dp[0] = nums[0]
  
  let result: number = dp[0]

  for (let i = 1; i < n; i++) {
    dp[i] = Math.max(dp[i - 1] + nums[i], nums[i])
    result = Math.max(dp[i], result)
  }

  return result
}
```
### 划分字母区间
> 给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，**同一字母最多出现在一个片段中**。
> 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。
> 返回一个表示每个字符串片段的长度的列表。
> 输入：s = "ababcbacadefegdehijhklij"   输出：[9,7,8]
> 解释：划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
> 每个字母最多出现在一个片段中。
> 像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。
> 来源：[https://leetcode.cn/problems/partition-labels](https://leetcode.cn/problems/partition-labels)

#### 代码实现
```typescript
// 此题突破点就是“同一字母最多出现在一个片段中”，那么应该想到如果需要满足，
// 就需要找到该字母的最后出现位置，以便把它放在同一个数组里

function partitionLabels(s: string): number[] {
  // Think for yourself for 5 minutes...
  const hash = {} // 记录每个字符最后出现的位置
  for (let i = 0; i < s.length; i++) {
    hash[s[i]] = i  // 计数
  }

  const result: number[] = []
  let nextStartIndex = 0 // 下一次切分的起始点
  let curPoint = 0 // 切分点
  for (let i = 0; i < s.length; i++) {
    curPoint = Math.max(curPoint, hash[s[i]])
    // 当i到了最后出现位置的时候
    if (curPoint === i) {
      result.push(curPoint - nextStartIndex + 1)
      nextStartIndex = i + 1 // 下一次从当前切分点后移一位
    }
  }
  // console.log('result', result)

  return result
}
```
### ⭐️K次取反后的最大数组和
> 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：
> 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
> 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。
> 以这种方式修改数组后，返回数组 可能的最大和 。
> 输入：nums = [4,2,3], k = 1 输出：5 解释：选择下标 1 ，nums 变为 [4,-2,3] 。
> 来源：[https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations)

#### 代码实现
```typescript
function largestSumAfterKNegations(nums: number[], k: number): number {
  // Think for yourself for 5 minutes...

  nums.sort((a, b) => Math.abs(b) - Math.abs(a))
  // 将小于0的全部变为正数,第一次贪心
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] < 0 && k > 0) {
      nums[i] = -nums[i]
      k--
    }
  }
  // 如果k还大于0，不断将最小的数取反，第二次贪心
  while (k > 0) {
    nums[nums.length - 1] = -nums[nums.length - 1]
    k--
  }

  // 求和
  return nums.reduce((prev, curr) => prev + curr)
}
```
思路分析，既然要求最大和，又能取反，那就先把绝对值最大的负数尽量给他整成正数（当k还有剩余），若把负数都整成正数k还有剩余，就把最小的数取反，取到k为0为止，，贪心在这里的精髓就是“能大就尽量往大整”
### 单调递增的数字
> 当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。
> 给定一个整数 n ，返回 **小于或等于 n 的最大数字**，且数字呈 单调递增 。
> 输入: n = 10 输出: 9
> 来源：[https://leetcode.cn/problems/monotone-increasing-digits](https://leetcode.cn/problems/monotone-increasing-digits)

#### 代码实现
```typescript
function monotoneIncreasingDigits(n: number): number {
  // Think for yourself for 5 minutes...
  // q1. 返回小于或等于n的最大数字，那么考虑原数字不是单调递增的话，从最低位开始替换成9
  const numArr: number[] = String(n)
    .split('')
    .map((i) => parseInt(i))


  //flag用来标记赋值9从哪里开始
  let flag = numArr.length
  for (let i = numArr.length - 1; i >= 0; i--) {
    // 从i位置开始不满足单调递增了，记下来
    if (numArr[i] > numArr[i + 1]) {
      numArr[i] -= 1
      flag = i + 1
    }
  }
  for (let i = flag; i < numArr.length; i++) {
    numArr[i] = 9
  }


  return parseInt(numArr.join(''))
}

// expect(monotoneIncreasingDigits(10)).toEqual(9)
// expect(monotoneIncreasingDigits(1234)).toEqual(1234)
// expect(monotoneIncreasingDigits(332)).toEqual(299)
```
思路分析，注意题干“**返回小于或等于 n 的最大数字**”，那么就考虑将原数字违反单调递增条件的最后一个数字的位置找出来几下(为什么是最后一个，因为要最大的数字啊啊啊啊)，再将从这个位置开始的数字全都替换成9，最后计算出来可能会存在[0,9,9]，不过不要紧，parseInt就是干这个事情的。
### 一手顺子
> Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 groupSize ，并且由 groupSize 张连续的牌组成。
> 给你一个整数数组 hand 其中 hand[i] 是写在第 i 张牌，和一个整数 groupSize 。如果她可能重新排列这些牌，返回 true ；否则，返回 false 。
> 输入：hand = [1,2,3,6,2,3,4,7,8], groupSize = 3 输出：true
> 解释：Alice 手中的牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。
> 来源：[https://leetcode.cn/problems/hand-of-straights](https://leetcode.cn/problems/hand-of-straights)

#### 代码实现
```typescript
function isNStraightHand(hand: number[], groupSize: number): boolean {
  // Think for yourself for 5 minutes...
  // q1. 用hash表记录每张牌出现的次数，用一次就减1
  // q2. 能构成一手顺子的条件一定是 n%groupSize==0 ,否则就false

  const n: number = hand.length

  if (n % groupSize != 0) return false

  const hash = new Map()

  for (let i = 0; i < hand.length; i++) {
    let a = hash.get(hand[i]) || 0
    hash.set(hand[i], a + 1)
  }

  hand.sort((a, b) => a - b)

  for (let i = 0; i < hand.length; i++) {
    if (hash.get(hand[i]) == 0) continue // 如果没有这张牌了就跳过
    let p: number = hand[i]

    let next: number = 1 // 比当前大一位的

    // 执行到这里说明当前位用了一次
    hash.set(p, hash.get(p) - 1)

    while (next < groupSize) {
      // 取数
      let a = hash.get(p + next)
      if (a) {
        // 取到了相邻的下一位
        hash.set(p + next, a - 1)
        next++
      } else {
        // 说明都不连续了，直接返回false
        console.log('没取到')
        return false
      }
    }
  }

  // console.dir(hash)

  return true
}
```
### 可被三整除的最大和
> 给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。
> 输入：nums = [3,6,5,1,8] 输出：18 解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。
> 来源：[https://leetcode.cn/problems/greatest-sum-divisible-by-three/](https://leetcode.cn/problems/greatest-sum-divisible-by-three/)

#### 代码实现 
```typescript
function maxSumDivThree(nums: number[]): number {
  // 取余为1的数
  const arr1 = nums.filter((item) => item % 3 === 1).sort((a, b) => a - b)

  // 取余为2的数
  const arr2 = nums.filter((item) => item % 3 === 2).sort((a, b) => a - b)

  let sum = nums.reduce((prev, curr) => prev + curr)

  if (sum % 3 == 0) {
    return sum
  } else if (sum % 3 === 1) {
    // 为1: 找到sum减去余数为1的最小值或者两个余数为2的最小值（比较）
    sum = Math.max(sum - arr1[0] || 0, sum - arr2[0] - arr2[1] || 0)
  } else {
    // 为2: 找到sum减去余数为2的最小值或者两个余数为1的最小值（比较）
    sum = Math.max(sum - arr2[0] || 0, sum - arr1[0] - arr1[1] || 0)
  }

  return sum
}
```
思路分析，为什么%3===1的取值是Math.max(sum - arr1[0], (sum - arr2[0] - arr2[1]) | 0)     (**所有整数%3,余数就只有0 1 2三种情况，余数为1的数+余数为2的数就能组成余数为0的数**) 
sum - arr1[0]可取的原因：
假如数组中存在[1,4,4,8,7,11] 这样的数据 [4,4,7] 取余为1  [1,8,11] 取余为2，减去一个arr1[0],剩余的取余为1的数和取余为2的所有数相加肯定能满足%3==0,
sum - arr2[0] - arr2[1]可取的原因：
同样，去掉两个取余为2的数据，剩余的数和所有取余为1的数据想加也能满足%3==0
那就比较是去掉一个余数为1的划算还是去掉两个余数为2的划算咯。
### 交换字符使得字符串相同
> 有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 "x" 和 "y"，你需要通过「交换字符」的方式使这两个字符串相同。
> 每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。
> 交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。
> 最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。
> 输入：s1 = "xx", s2 = "yy" 输出：1 解释： 交换 s1[0] 和 s2[1]，得到 s1 = "yx"，s2 = "yx"。
> 来源：[https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal](https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal)

#### 代码实现
```typescript
function minimumSwap(s1: string, s2: string): number {
  // Think for yourself for 5 minutes...
  if (s1.length != s2.length) return -1
  // 两种情况
  // s1[i] = x, s2[i] = y  记做xy
  // s1[i] = y, s2[i] = x  记做yx
  const n: number = s1.length

  let xy: number = 0
  let yx: number = 0

  for (let i = 0; i < n; i++) {
    const a = s1[i]
    const b = s2[i]
    if (a === 'x' && b === 'y') {
      xy++
    }
    if (a === 'y' && b === 'x') {
      yx++
    }
  }

  // 如果为奇数，肯定无法完成交换
  if ((xy + yx) % 2 === 1) {
    return -1
  }
  // xy / 2 和 yx / 2 表示内部配对，每两个配成一对交换一次
  // 如果两个都是偶数对，xy % 2 + yx % 2 = 0 + 0 = 0
  // 如果两个都是奇数对，xy % 2 + yx % 2 = 1 + 1 = 2，刚好表示各剩一个需要交换两次
  return Math.floor(xy / 2) + Math.floor(yx / 2) + (xy % 2) + (yx % 2)
}
```
### 玩筹码
> 有 n 个筹码。第 i 个筹码的位置是 position[i] 。
> 我们需要把所有筹码移到同一个位置。在一步中，我们可以将第 i 个筹码的位置从 position[i] 改变为:
> position[i] + 2 或 position[i] - 2 ，此时 cost = 0
> position[i] + 1 或 position[i] - 1 ，此时 cost = 1
> 返回将所有筹码移动到同一位置上所需要的 最小代价 。
> 输入：position = [1,2,3]   输出：1
> 解释：第一步:将位置3的筹码移动到位置1，成本为0。
> 第二步:将位置2的筹码移动到位置1，成本= 1。 总成本是1。
> 来源：[https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position](https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position)

#### 代码实现
```typescript
function minCostToMoveChips(position: number[]): number {
  // Think for yourself for 5 minutes...
  // q1. 挪两位不要钱，挪一位消耗1
  // q2. 那么考虑以奇数位为基准挪的话，偶数位就要消耗，
  // 反之奇数位就要消耗，针对两种情况的最小值计数，结果就是两者的最小值

  let odd: number = 0 // 奇数
  let even: number = 0 //偶数
  for (let i = 0; i < position.length; i++) {
    if (position[i] % 2 == 0) {
      odd++
    } else {
      even++
    }
  }

  return Math.min(odd, even)
}
```
### 最长回文传
> 给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的** 最长的回文串 。**
> 在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。
> 输入:s = "abccccdd" 输出:7 解释: 我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
> 来源：[https://leetcode.cn/problems/longest-palindrome](https://leetcode.cn/problems/longest-palindrome)

#### 代码实现
```typescript
function longestPalindrome(s: string): number {
  // Think for yourself for 5 minutes...
  if (s.length == 0) return 0

  const hash = new Map()

  // 记录每个字符出现的次数
  for (let i = 0; i < s.length; i++) {
    let a = hash.get(s[i]) || 0
    hash.set(s[i], a + 1)
  }

  let count = 0

  let mark = 0 // 用来标记某个字母出现了奇数次情况
  for (let item of hash) {
    if (item[1] % 2 == 0) {
      count += item[1]
    } else {
      // 如果出现了奇数次，那也只能用n-1次
      count += item[1] > 1 ? item[1] - 1 : 0
      mark++
    }
  }
  // 如果出现了多个只出现奇数次的字符，要满足回文最多只能用1个
  return mark ? count + 1 : count
}
```
思路分析，构成回文最佳的字符串肯定是对于出现偶数次的字符全部采用，剩余奇数个存在两种情况，a:大于1的奇数，使用n-1次，b:等于1的奇数，最后用不用还不一定，因为可能如果存在大于1的字符的话，可能都轮不到它哈哈，因此对于所有出现奇数次的字符，只在结果中对他加上n-1次，最终结果考虑如果有存在奇数次的字符，就给整体加1。
###  验证回文串 II
> 给你一个字符串 s，**最多** 可以从中删除一个字符。
> 请你判断 s 是否能成为回文字符串：如果能，返回 true ；否则，返回 false 。
输入：s = "aba" 输出：true 
输入：s = "abc" 输出：false
> 来源：[https://leetcode.cn/problems/valid-palindrome-ii/](https://leetcode.cn/problems/valid-palindrome-ii/)

#### 代码实现
```typescript
function isPalindrome(s: string, left: number, right: number) {
  for (let i = left, j = right; i <= j; i++, j--) {
    if (s[i] !== s[j]) {
      return false
    }
  }
  return true
}

function validPalindrome(s: string): boolean {
  for (let i = 0, j = s.length - 1; i < j; i++, j--) {
    if (s[i] !== s[j]) {
      //  左边往右挪一步或右边往左挪一步的区间是否满足回文条件
      return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1)
    }
  }
  return true
}
```
### 买卖股票的最佳时机 II
> 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
> 返回 你能获得的**最大利润 。**
> 输入：prices = [7,1,5,3,6,4]    输出：7
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
> 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
> 总利润为 4 + 3 = 7 。
> 来源：[https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii)

PS：
#### 代码实现
```typescript
function maxProfit(prices: number[]): number {
  // Think for yourself for 5 minutes...

  let max: number = 0

  // q1. 只允许一支股票
  // q2. 想要获利至少两天一个利润单元
  // q3. 每天的利润序列 (p[i+1]-p[i-1])...(p[1]-p[0])
  // q4. 只取利润为正数的
  // q5. 第一天没利润

  for (let i = 1; i < prices.length; i++) {
    max += Math.max(prices[i] - prices[i - 1], 0) // 只取正数
    // 也可以换成
    // if (prices[i] - prices[i - 1] > 0) {
    //   max += prices[i] - prices[i - 1]
    // }
  }

  return max
}
```
#### 动态规划版本
```typescript
const maxProfit = (prices: number[]) => {
  let dp = Array.from(Array(prices.length), () => Array(2).fill(0))
  // dp[i][0] 表示第i天持有股票所得现金。
  // dp[i][1] 表示第i天不持有股票所得最多现金
  dp[0][0] = 0 - prices[0]
  dp[0][1] = 0
  for (let i = 1; i < prices.length; i++) {
    // 如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来
    // 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]
    // 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i])


    // 在来看看如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来
    // 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]
    // 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0]
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i])
  }


  return dp[prices.length - 1][1]
}
```
### 加油站
> 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
> 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
> 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。
> 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2] 输出: 3
> 解释:
> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
> 因此，3 可为起始索引。
> 来源：[https://leetcode.cn/problems/gas-station](https://leetcode.cn/problems/gas-station)

#### 代码实现
```typescript
/**
 *
 * @param gas 加油站汽油量
 * @param cost 需要消耗的量
 * @returns
 */
function canCompleteCircuit(gas: number[], cost: number[]): number {
  // Think for yourself for 5 minutes...

  let curSum: number = 0 // 不断在每一站迭代的

  let min: number = Number.MAX_SAFE_INTEGER // 油箱里的剩余值

  // 每走完一站消耗完剩余的加上这一站可以加的 curSum = curSum + cost[i] - gas[i]
  // q1. 返回加油站的编号
  // q2. 如果加油站油量小于需要的总和 返回-1
  // q3. 如果从0开始，从0开始，最后剩余>=0 那么0点就是起点
  // q4. 如果0点不是起点，从加油站后往前找，第一个可以把剩余填满的就是起点

  for (let i = 0; i < gas.length; i++) {
    let a = gas[i] - cost[i]
    curSum += a
    if (curSum < min) {
      min = curSum
    }
  }

  if (curSum < 0) return -1 // 走不完
  if (min >= 0) return 0 // 剩余大于0 可以从0点走

  for (let i = gas.length - 1; i >= 0; i--) {
    let a = gas[i] - cost[i] // 走完第i站消耗完的剩余的
    min += a
    if (min >= 0) {
      return i
    }
  }

  return -1
}
```
#### 代码实现2
```typescript
function canCompleteCircuit(gas: number[], cost: number[]): number {
  let startIndex: number = 0

  let curSum: number = 0

  let totalSum: number = 0

  // 从0开始如果[0,i]区间出现负值，说明i不能作为起点，起点不断往后移动
  for (let i = 0; i < gas.length; i++) {
    curSum = gas[i] - cost[i]
    totalSum += gas[i] - cost[i]
	  // 如果i点走完油都不够了
    if (curSum < 0) {
      startIndex = i + 1
      curSum = 0
    }
  }

  if (totalSum < 0) return -1
  return startIndex
}
```
#### 暴力方法
```typescript
/**
 * 暴力解法
 * @param gas
 * @param cost
 */
function canCompleteCircuit(gas: number[], cost: number[]): number {
  for (let i = 0; i < gas.length; i++) {
    let a = gas[i] - cost[i] // 剩余
    let index = (i + 1) % cost.length
    // 模拟以i为起点行驶一圈
    while (a > 0 && index != i) {
      a += gas[index] - cost[index]
      index = (index + 1) % cost.length
    }
    // 如果以i为起点跑一圈，剩余油量大于0，说明i点符合起点
    if (a >= 0 && index === i) return i
  }
  return -1
}
```
### 根据身高重建队列
> 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
> 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。
> 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
> 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
> 来源：[https://leetcode.cn/problems/queue-reconstruction-by-height](https://leetcode.cn/problems/queue-reconstruction-by-height)

#### 代码实现
```typescript
// 当遇到两个维度的条件时，一定是分两步去实现
function reconstructQueue(people: number[][]): number[][] {
  // Think for yourself for 5 minutes...


  // step1 优先先按身高先排个序
  people.sort((a, b) => {
    // 如果身高相同，就按后面的排序
    if (a[0] === b[0]) return a[1] - b[1]
    return b[0] - a[0]
  })


  console.log('people', people)
  let queue: number[][] = []

	// step2 根据ki排序
  for (let i = 0; i < people.length; i++) {
    queue.splice(people[i][1], 0, people[i])
  }


  // console.log('queue', queue)

  return queue
}
```
## ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678525519065-99605e0b-1cd9-4ee7-8255-b971e42ce657.png#averageHue=%23fefefe&clientId=u101e7a90-95ab-4&from=paste&height=274&id=u9176b122&name=image.png&originHeight=548&originWidth=1114&originalType=binary&ratio=2&rotation=0&showTitle=false&size=70464&status=done&style=none&taskId=u77b8f46d-da07-422f-ae2f-7351ae2f06d&title=&width=557)
### 无重叠区间
> 给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，**使剩余区间互不重叠 。**
> 输入: intervals = [[1,2],[2,3],[3,4],[1,3]] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。
> 链接：[https://leetcode.cn/problems/non-overlapping-intervals](https://leetcode.cn/problems/non-overlapping-intervals)


#### 代码实现
```typescript

function eraseOverlapIntervals(intervals: number[][]): number {
  // Think for yourself for 5 minutes...

  if (intervals.length == 0) return 0

  // 先按照end给原区间数组排个序
  intervals.sort((a, b) => {
    return a[1] - b[1]
  })

  // count 记录可以正常续上的区间段[1,2],[2,3]可以续上,[1,2],[1,3] 由于后面的start大于前面的end，所以续不上
  // 记录可以续上的，不能连续的就是 n-count了
  
	let lastSectionEnd = intervals[0][1] // 上一个区间的end
  let count = 1
  for (let i = 0; i < intervals.length; i++) {
    let start = intervals[i][0]
    // 如果下一个区间的start>=上一个区间的end，那么两个区间不重叠
    if (start >= lastSectionEnd) {
      lastSectionEnd = intervals[i][1]
      count++
    }
  }

  return intervals.length - count
}
```
思路分析，题干中提及“移除”，但是求解不能被这个词误导了，会加大求解难度，我们最终的目的是使剩余区间互不重叠 ，那么就先将原区间集合按照end值排序，能够满足区间不重叠的条件一定是上一个区间的end<=下一区间的start，如果满足关系，就迭代计数，最后反推出需要“移除”的数量即可。启发👉 很多题都要避免掉入如此的陷阱。
### 合并区间
> 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。
> 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
> 输出：[[1,6],[8,10],[15,18]]
> 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> 来源：[https://leetcode.cn/problems/merge-intervals](https://leetcode.cn/problems/merge-intervals)

#### 实现代码
```typescript
function merge(intervals: number[][]): number[][] {
  // Think for yourself for 5 minutes...

  if (intervals.length < 2) return intervals

  // 以每个区间的start位置排序
  intervals.sort((a, b) => a[0] - b[0]) 

  const resArr: number[][] = []
  
  resArr[0] = [...intervals[0]] // 避免修改原intervals


  for (let i = 1, length = intervals.length; i < length; i++) {
    let interval: number[] = intervals[i]
    // 上一个区间应该从已合并的区间内找
    let last: number[] = resArr[resArr.length - 1]
    // 如果下一个区间的start<=上一个区间的end
    if (interval[0] <= last[1]) {
      last[1] = Math.max(interval[1], last[1])
    } else {
      resArr.push([...intervals[i]])
    }
  }
  return resArr
}
```
### 整数替换
> 给定一个正整数 n ，你可以做如下操作：
> 如果 n 是偶数，则用 n / 2替换 n 。
> 如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。
> 返回 n 变为 1 所需的 最小替换次数 。
> 输入：n = 8 输出：3 解释：8 -> 4 -> 2 -> 1
> 来源：[https://leetcode.cn/problems/integer-replacement](https://leetcode.cn/problems/integer-replacement)

#### 代码实现
```typescript
function integerReplacement(n: number): number {
  let count = 0
  while (n != 1) {
    if (n & 1) {
      if (n === 3) {
        n = n - 1
      } else {
        if (n & 2) {
          n = n + 1
        } else {
          n = n - 1
        }
      }
    } else {
      n = n >>> 1
    }
    count++
  }

  return count
}
```
#### 记忆法
```typescript
const map = {}
function integerReplacement(n: number): number {
  // Think for yourself for 5 minutes...
  if (n == 1) return 0

  const value = map[n]
  if (value) {
    return value
  }

  let result = 0

  if (n % 2 === 0) {
    result = 1 + integerReplacement(n / 2)
  } else {
    result = 1 + Math.min(integerReplacement(n + 1), integerReplacement(n - 1))
  }
  
  map[n] = result

  return result
}
```
### 移除K位数字
> 给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k_ _位数字，**使得剩下的数字最小**。请你以字符串形式返回这个最小的数字。
> 输入：num = "1432219", k = 3 输出："1219" 解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
> 来源：[https://leetcode.cn/problems/remove-k-digits/](https://leetcode.cn/problems/remove-k-digits/)

#### 代码实现
```typescript
function removeKdigits(num: string, k: number): string {
  // Think for yourself for 5 minutes...
  // q1. 剩余为空返回“0”
  // q2. 使得剩下的数字最小
  const stk: string[] = []
  const n: number = num.length

  for (const digit of num) {
    // q1. 如果栈顶堆元素大于新来的元素就不断去除栈顶堆元素，
    while (stk.length > 0 && stk[stk.length - 1] > digit && k) {
      stk.pop()
      k -= 1
    }
    stk.push(digit)
  }

  // q2.如果删除了m个数字，且m<k,这种情况需要从序列尾部删除k-m个数字
  // removeKdigits('12345264', 5) 会走到这里
  for (; k > 0; --k) {
    stk.pop()
  }

  let ans: string = ''

  let isLeadingZero: boolean = true

  for (const val of stk) {
    // 遇到0就跳过
    if (isLeadingZero && val === '0') {
      continue
    }
    isLeadingZero = false
    ans += val
  }
  // 开头有0也可以这样处理
  // return parseInt(stk.join('')) == 0 || stk.length == 0 ? '0' : String(parseInt(stk.join('')))

  return ans === '' ? '0' : ans
}
```
## 👉总结归纳
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1679204955374-1ac47768-2df2-4b1d-9d1b-09d657bb37f2.png#averageHue=%23f6f6f6&clientId=uad899468-19e7-4&from=paste&height=3423&id=ue4af222e&name=image.png&originHeight=6845&originWidth=5000&originalType=binary&ratio=2&rotation=0&showTitle=false&size=3411166&status=done&style=none&taskId=ud088195b-2113-4210-9897-37a8153e214&title=&width=2500)

## 资料
针对摆动序列的情况分析
