# 算法:双指针 
## 常用思想
1. 普通双指针：一般两个for循环，外层i和内层j可认为是两个普通指针
2. 左右指针(二分查找)：一个指向开头，另一个指向结尾，直到两个指针相遇或满足条件
3. 快慢指针：开始都指向开头，一个走得慢，另一个走得快，直到快指针走到结尾或满足条件
4. 滑动窗口
## 例题
### 删除有序数组中的重复项
> 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
> 输入：nums = [1,2,3]
> 输出：2
> 来源：[https://leetcode.cn/problems/remove-duplicates-from-sorted-array/](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

#### 分解题目

- 升序数组
- 原地修改，不允许新增数组
- 返回去重后的长度
#### 代码实现
```javascript
const uniq = (nums) => {
  if (nums.length === 0) {
    return 0
  }

  let fast = 1
  let slow = 1
  const length = nums.length
  while (fast < length) {
    if (nums[fast] !== nums[fast - 1]) {
      nums[slow] = nums[fast]
      slow++
    }
    ++fast // 返回自增之后的值
  }
  return slow
}

const res = uniq([1, 2, 2, 3])

console.log('res', res)
```
### 题目2(左右指针)
> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
> 

#### 常规二分查找
```javascript
const find = (nums:number[], target:number) => {
  let left = 0
  let right = nums.length - 1
  while (left <= right) {
    let mid = left + Math.floor((right - left) / 2)
    if (nums[mid] < target) {
      left = mid + 1 // 向右移动，缩小边界
    } else if (nums[mid] > target) {
      right = mid - 1 // 向左移动，缩小边界
    } else {
      return mid // 此时nums[mid] = target 了，直接返回
    }
  }
  return -1
}


// 更加清晰的写法
const find = (nums: number[], target: number) => {
  let left = 0
  let right = nums.length - 1
  while (left <= right) {
    let mid = left + Math.floor((right - left) / 2)
    if (nums[mid] === target) {  // 当条件成立直接返回
      return mid
    } else if (nums[mid] < target) {  // 当mid点小于目标点，把left往右移动
      left = mid + 1
    } else if (nums[mid] > target) {  // 当mid点大于目标点，把right往左移动
      right = mid - 1
    }
  }
  return -1
}



const res = find([1, 2, 3, 4, 11, 6, 8, 9], 4)
const res1 = find([1, 2, 4, 11, 6, 8, 9], 4)

console.log('res', res)

console.log('res1', res1)
```
解析
**为什么 while 循环的条件中是 <=，而不是 <**？
因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。
**为什么 left = mid + 1，right = mid - 1？**
当发现索引 mid 不是要找的 target 时，是去搜索 [left, mid-1] 或者 [mid+1, right] ，**因为 mid 已经搜索过，应该从搜索区间中去除**。

> 因为我们初始化 right = nums.length - 1
> 所以决定了我们的「搜索区间」是 [left, right]
> 所以决定了 while (left <= right)
> 同时也决定了 left = mid+1 和 right = mid-1
> 因为我们只需找到一个 target 的索引即可
> 所以当 nums[mid] == target 时可以立即返回


#### 寻找左侧边界
```javascript
const left_bound_find = (nums: number[], target: number) => {
  let left = 0
  let right = nums.length - 1
  // 搜索区间为 [left, right]
  while (left <= right) {
    let mid = Math.floor(left + (right - left) / 2)
    if (nums[mid] < target) {
      // 搜索区间变为 [mid+1, right]
      left = mid + 1
    } else if (nums[mid] > target) {
      // 搜索区间变为 [left, mid-1]
      right = mid - 1
    } else if (nums[mid] == target) {
      // 收缩右侧边界
      right = mid - 1
    }
  }
  // 检查出界情况
  if (left >= nums.length || nums[left] != target) return -1
  return left
}
```
由于 while 的退出条件是 left == right + 1，所以当 target 比 nums 中所有元素都大时，会存在以下情况使得索引越界：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676903381377-4b8983f4-4218-4979-aa8d-ee4ed6fc62ea.png#averageHue=%23fdfcfc&clientId=u0deca431-c3f3-4&from=paste&height=186&id=ub69b813d&name=image.png&originHeight=446&originWidth=1438&originalType=binary&ratio=2&rotation=0&showTitle=false&size=65805&status=done&style=none&taskId=u9f39db14-ccb5-46d5-ac91-e98c834e1b7&title=&width=600)
> 因为我们初始化 right = nums.length
> 所以决定了我们的「搜索区间」是 [left, right)
> 所以决定了 while (left < right)
> 同时也决定了 left = mid + 1 和 right = mid
> 因为我们需找到 target 的**最左侧**索引
> 所以当 nums[mid] == target 时不要立即返回
> 而要**收紧右侧边界**以锁定左侧边界

#### 寻找右侧边界
```javascript
const right_bound_find = (nums: number[], target: number) => {
  let left = 0,
    right = nums.length - 1
  while (left <= right) {
    let mid = Math.floor(left + (right - left) / 2)
    if (nums[mid] < target) {
      left = mid + 1
    } else if (nums[mid] > target) {
      right = mid - 1
    } else if (nums[mid] == target) {
      // 这里改成收缩左侧边界即可
      left = mid + 1
    }
  }
  // 这里改为检查 right 越界的情况
  if (right < 0 || nums[right] != target) return -1
  return right
}
```
> 因为我们初始化 right = nums.length
> 所以决定了我们的「搜索区间」是 [left, right)
> 所以决定了 while (left < right)
> 同时也决定了 left = mid + 1 和 right = mid
> 因为我们需找到 target 的最右侧索引
> 所以当 nums[mid] == target 时不要立即返回
> 而要收紧左侧边界以锁定右侧边界
> 又因为收紧左侧边界时必须 left = mid + 1

#### 盛最多水的容器
> 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
> 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
> 返回容器可以储存的最大水量。
> 说明：你不能倾斜容器。
> ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678285886064-a7224462-1b45-4dbe-b48c-26e0e593e858.png#averageHue=%23626462&clientId=uf45caff1-034b-4&from=paste&height=380&id=uf1f8a0cf&name=image.png&originHeight=1014&originWidth=1602&originalType=binary&ratio=2&rotation=0&showTitle=false&size=114756&status=done&style=none&taskId=u760d5993-9bd3-446a-9c85-35cf0f94f2b&title=&width=600)
> 来源：[https://leetcode.cn/problems/container-with-most-water](https://leetcode.cn/problems/container-with-most-water)

##### 代码实现
```typescript
function maxArea(height: number[]): number {
  // Think for yourself for 5 minutes...

  let max: number = 0
  let left = 0
  let right = height.length - 1

  while (left < right) {
    // 取比较低的那个
    let area = Math.min(height[left], height[right]) * (right - left)
    max = Math.max(area, max)

    if (height[left] <= height[right]) {
      left++
    } else {
      right--
    }
  }

  return max
}
```

#### 应用要点

1. 分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。
2. 注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。
3. 如需定义左闭右开的「搜索区间」搜索左右边界，只要在 nums[mid] == target 时做修改即可，搜索右侧时需要减一。
4. 如果将「搜索区间」全都统一成两端都闭，只要稍改 nums[mid] == target 条件处的代码和返回的逻辑即可。
### 两数之和
> 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
> 你可以按任意顺序返回答案。
> 输入：nums = [2,7,11,15], target = 9
> 输出：[0,1]
> 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
> 来源：[https://leetcode.cn/problems/two-sum/](https://leetcode.cn/problems/two-sum/)

#### 代码实现
```javascript
const twoSum = (nums: number[], target: number) => {
  const { length } = nums
  for (let i = 0; i < length; i++) {
    // 以[0]为基准，依次往后找
    // 再以[1]为基准，依次往后找
    // 以此类推
    for (let j = 0; j < i; j++) {
      if (nums[i] + nums[j] == target) {
        return [i, j]
      }
    }
  }

  return [-1, -1]
}
```
#### 优化版(非指针)
```javascript
const twoSumBetter = (nums: number[], target: number) => {
  const { length } = nums

  const map = new Map()

  for (let i = 0; i < length; i++) {
    if (map.get(target - nums[i])) {
      return [target - nums[i], i]
    }
    map.set(i, nums[i])
  }

  return [-1, 1]
}
```
### 按奇偶排序数组 II
> 给定一个非负整数数组 nums，  nums 中一半整数是 奇数 ，一半整数是 偶数 。
> 对数组进行排序，以便当 nums[i] 为奇数时，i 也是 奇数 ；当 nums[i] 为偶数时， i 也是 偶数 。
> 你可以返回 任何满足上述条件的数组作为答案 。
> 输入：nums = [4,2,5,7] 输出：[4,5,2,7]   解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 
> 来源：[https://leetcode.cn/problems/sort-array-by-parity-ii](https://leetcode.cn/problems/sort-array-by-parity-ii)

#### 代码实现1
```typescript
function sortArrayByParityII(nums: number[]): number[] {
  // Think for yourself for 5 minutes...
  //q1. 按照奇偶排序  先偶后奇

  const ans: number[] = Array(nums.length)

  let i = 0
  // 0 2 4 6
  for (const val of nums) {
    if (val % 2 === 0) {
      ans[i] = val
      i += 2
    }
  }

  i = 1
  // 1 3 5 7
  for (const val of nums) {
    if (val % 2 !== 0) {
      ans[i] = val
      i += 2
    }
  }

  return ans
}

```
#### 代码实现2
```typescript
const swap = (nums, i, j) => {
  const temp = nums[i]
  nums[i] = nums[j]
  nums[j] = temp
}

function sortArrayByParityII(nums: number[]): number[] {
  const n: number = nums.length
  let j = 1 // 控制奇数位
  for (let i = 0; i < n; i += 2) {
    if (nums[i] % 2 == 1) {
      while (nums[j] % 2 === 1) {
        j += 2
      }

      swap(nums, i, j)
    }
  }

  return nums
}
```
#### 代码实现3
```typescript

function sortArrayByParityII(nums: number[]): number[] {
  const ans: number[] = []
  let evenIndex = 0
  let oddIndex = 1

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] % 2 == 0) {
      ans[evenIndex] = nums[i]
      evenIndex += 2
    } else {
      ans[oddIndex] = nums[i]
      oddIndex += 2
    }
  }

  return ans
}

```
### 题目4(快慢指针)
> 给你一个链表的头节点 head ，判断链表中是否有环。
> 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。
> 如果链表中存在环 ，则返回 true 。 否则，返回 false 。
> 

#### 代码实现
```javascript
const hasCycle = (head) => {
  let slow = head
  let fast = head
  while (fast != null && fast.next != null) {
    slow = fast.next
    fast = fast.next.next
    if (slow == fast) {
      return true
    }
  }
  return false
}
```
### 移动0
> 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。
> 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0]
> 来源：[https://leetcode.cn/problems/move-zeroes/](https://leetcode.cn/problems/move-zeroes/)

#### 代码实现
```javascript
function moveZeroes(nums: number[]): void {
  // Think for yourself for 5 minutes...

  let fast = 0
  let slow = 0

  while (fast < nums.length) {
    if (nums[fast]) {
      let t = nums[slow]
      nums[slow] = nums[fast]
      nums[fast] = t
      slow++
    }
    fast++
  }

  console.log('nums', nums)
}
```
### 题目5(快慢指针-删除元素)
> 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

#### 代码实现
```javascript
const removeElement = (nums: number[], target: number) => {
  let slow = 0
  for (let fast = 0; fast < nums.length; fast++) {
    if (nums[fast] != target) {
      nums[slow++] = nums[fast]
    }
  }
  return slow
}

const removeElement2 = (nums: number[], target: number) => {
  let slow = 0
  let fast = 0
  while (fast < nums.length) {
    if (nums[fast] != target) {
      nums[slow] = nums[fast]
      slow++
    }
    ++fast
  }
  return slow
}
```
#### 双向指针法
```javascript
const removeElement3 = (nums: number[], target: number) => {
  let leftIndex = 0
  let rightIndex = nums.length - 1
  while (leftIndex <= rightIndex) {
    // 找左边不等于val的元素
    while (leftIndex <= rightIndex && nums[leftIndex] != target) {
      ++leftIndex
    }
    // 找右边不等于val的元素
    while (leftIndex <= rightIndex && nums[rightIndex] == target) {
      --rightIndex
    }
    // 将右边不等于val的元素覆盖左边等于val的元素
    if (leftIndex < rightIndex) {
      nums[leftIndex++] = nums[rightIndex--]
    }
  }
  return leftIndex // leftIndex一定指向了最终数组末尾的下一个元素
}
```
### 三数之和
> 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请
> 你返回所有和为 0 且不重复的三元组。
> 注意：答案中不可以包含重复的三元组。
> 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]]
> 来源：[https://leetcode.cn/problems/3sum](https://leetcode.cn/problems/3sum)

#### 代码实现
```typescript
function threeSum(nums: number[]): number[][] {
  nums.sort((a, b) => a - b)
  let length = nums.length
  let left: number = 0
  let right: number = length - 1
  let resArr: number[][] = []
  for (let i = 0; i < length; i++) {
    if (nums[i] > 0) {
      return resArr //nums经过排序后，只要nums[i]>0, 此后的nums[i] + nums[left] + nums[right]均大于0,可以提前终止循环。
    }
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue
    }
    left = i + 1
    right = length - 1
    while (left < right) {
      let total: number = nums[i] + nums[left] + nums[right]
      if (total === 0) {
        resArr.push([nums[i], nums[left], nums[right]])
        left++
        right--
        while (nums[right] === nums[right + 1]) {
          right--
        }
        while (nums[left] === nums[left - 1]) {
          left++
        }
      } else if (total < 0) {
        left++
      } else {
        right--
      }
    }
  }
  return resArr
}
```
### 最接近的三数之和
> 给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。
> 返回这三个数的和。
> 假定每组输入只存在恰好一个解。
> 输入：nums = [-1,2,1,-4], target = 1 输出：2 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
> 来源：[https://leetcode.cn/problems/3sum-closest](https://leetcode.cn/problems/3sum-closest)

#### 代码实现
```typescript
function threeSumClosest(nums: number[], target: number): number {
  // Think for yourself for 5 minutes...
  nums.sort((a, b) => a - b)

  const n = nums.length

  let ans: number = nums[0] + nums[1] + nums[2]

  for (let i = 0; i < n; i++) {
    let left = i + 1
    let right = n - 1
    while (left < right) {
      const a = nums[left] + nums[right] + nums[i]
      if (Math.abs(target - a) < Math.abs(target - ans)) {
        ans = a
      }
      if (a > target) right--
      else if (a < target) left++
      else return ans
    }
  }
  return ans
}
```
### 四数之和
> 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
> 0 <= a, b, c, d < n    a、b、c 和 d 互不相同
> nums[a] + nums[b] + nums[c] + nums[d] == target
> 你可以按 任意顺序 返回答案 。
> 输入：nums = [1,0,-1,0,-2,2], target = 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
> 来源：力扣（LeetCode）
> 来源：[https://leetcode.cn/problems/4sum](https://leetcode.cn/problems/4sum)

#### 代码实现
```typescript

function fourSum(nums: number[], target: number): number[][] {
  // Think for yourself for 5 minutes...

  // q1. 0 <= a, b, c, d < n
  // q2. a、b、c 和 d 互不相同
  // q nums[a] + nums[b] + nums[c] + nums[d] == target

  const resArr: number[][] = []

  nums.sort((a, b) => a - b)

  const n: number = nums.length
  for (let k = 0; k < n; k++) {
    if (nums[k] > target && nums[k] >= 0) {
      break
    }
    if (k > 0 && nums[k] == nums[k - 1]) {
      continue
    }

    for (let i = k + 1; i < n; i++) {
      if (nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) {
        break
      }

      if (i > k + 1 && nums[i] == nums[i - 1]) {
        continue
      }

      let left = i + 1
      let right = n - 1

      while (right > left) {
        let total: number = nums[k] + nums[i] + nums[left] + nums[right]
        if (total > target) {
          right--
        } else if (total < target) {
          left++
        } else {
          resArr.push([nums[k], nums[i], nums[left], nums[right]])

          while (right > left && nums[right] === nums[right - 1]) right--
          while (right > left && nums[left] === nums[left + 1]) left++

          right--
          left++
        }
      }
    }
  }
```
### ⭐️最短无序连续子数组
> 给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
> 请你找出符合题意的 最短 子数组，并输出它的长度。
> 输入：nums = [2,6,4,8,10,9,15]  输出：5
> 解释：你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
> 来源：[https://leetcode.cn/problems/shortest-unsorted-continuous-subarray](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray)

#### 代码实现
```typescript
// 两次遍历
function findUnsortedSubarray(nums: number[]): number {
  let left = 0
  let right = 0
  let min = nums[nums.length - 1] // 最右边的数
  let max = nums[0] // 最左边的数

  // 从右往左 找左边界
  for (let i = nums.length - 1; i >= 0; i--) {
    min = Math.min(min, nums[i])
    if (nums[i - 1] > min) left = i - 1
  }

  // 从左往右 找右边界
  for (let i = 0; i < nums.length; i++) {
    max = Math.max(max, nums[i + 1])
    if (nums[i + 1] < max) right = i + 1
  }

  return right == left ? 0 : right - left + 1
}

// 一次遍历
function findUnsortedSubarray(nums: number[]): number {
  const n: number = nums.length
  let max = -Number.MAX_VALUE
  let min = Number.MAX_VALUE

  let left = -1
  let right = -1
  //
  for (let i = 0; i < n; i++) {
    //从左到右维持最大值，寻找右边界
    if (max > nums[i]) {
      right = i
    } else {
      max = nums[i]
    }

    //从右到左维持最小值，寻找左边界begin
    if (min < nums[n - i - 1]) {
      left = n - i - 1
    } else {
      min = nums[n - i - 1]
    }
  }

  // 如果right走到头了还是初始值，说明本来就是升序数组
  return right === -1 ? 0 : right - left + 1
}
```
### ⭐️在 D 天内送达包裹的能力
> 传送带上的包裹**必须在 days 天内**从一个港口运送到另一个港口。
> 传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。
> 返回能在 days 天内将传送带上的所有包裹送达的船的**最低运载能力。**
> 输入：weights = [3,2,2,4,1,4], days = 3  输出：6
> 解释：
> 船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：
> 第 1 天：3, 2
> 第 2 天：2, 4
> 第 3 天：1, 4
> 来源：[https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days)

#### 代码实现
```typescript
/**
 * 判断当前荷载是否能够在D天内送达
 * @param weights
 * @param D 需要的天数
 * @param H
 * @returns
 */
function verification(weights: number[], D: number, H: number) {
  let countDay = 1
  let singleWeight = 0
  for (let i = 0; i < weights.length; i++) {
    singleWeight += weights[i]
    //如果累计包裹总量singleWeight > H，天数+1
    if (singleWeight > H) {
      countDay++
      singleWeight = weights[i] // 做为后一天的第一个包裹
    }
    //如果当前累计的天数count > D，说明当前H不满足条件，返回false
    if (countDay > D) {
      return false
    }
  }

  // 上面没有false说明以H运载能力的船能在D天内运完
  return true
}

function shipWithinDays(weights: number[], days: number): number {
  let left = Math.max(...weights)
  let right = weights.reduce((prev, curr) => prev + curr)

  while (left < right) {
    const mid = Math.floor((left + right) / 2)
    // 如果mid满足verification，则逼近右指针
    if (verification(weights, days, mid)) {
      right = mid
    } else {
      left = mid + 1
    }
  }

  return left
}
```
思路分析

1. 必须按顺序装
2. 天数满足days
3. 需要输出最低运载能力
4. 运载能力一定是要大于所有包裹重量的最大值的，也肯定是小于所有包裹重量之和的

因此可以确定左右区间
> let left = Math.max(...weights)
> let right = weights.reduce((prev, curr) => prev + curr)

设x为left和right之间的值，尝试以x荷载去装所有的包裹，如果包裹能装完且需要的天数小于days，说明x荷载是可以在days天内将包裹运送完，但需要求最低运载能力，因此当x满足条件时，需要尝试将荷载缩小(对应代码right = mid)，直到求出最低运载能力为止
#### 类似题

- 
- 
### 制作 m 束花所需的最少天数
> 给你一个整数数组 bloomDay，以及两个整数 m 和 k 。
> 现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。
> 花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。
> 请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。
> 输入：bloomDay = [1,10,3,10,2], m = 3, k = 1输出：3
> 解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。
> 现在需要制作 3 束花，每束只需要 1 朵。
> 1 天后：[x, _, _, _, _]   // 只能制作 1 束花
> 2 天后：[x, _, _, _, x]   // 只能制作 2 束花
> 3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3
> 来源：[https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets](https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets)

#### 代码实现
```typescript
/**
 * days天数是否能制作m*k所需要的花朵数
 * @param bloomDay
 * @param days 尝试的天数
 * @param m 需要制作的花束数量
 * @param k 需要相邻的数量
 * @returns
 */
function verification(bloomDay: number[], days: number, m: number, k: number) {
  let flowers = 0
  let count = 0 // 可以制作的花束数量
  for (let i = 0; i < bloomDay.length && count < m; i++) {
    if (bloomDay[i] <= days) {
      flowers++
      // 满足制作一束花的条件了
      if (flowers == k) {
        count++
        flowers = 0 // 制作完一束，重新开始计算
      }
    } else {
      // 当i位置不满足天数时即花朵不连续了，需要置为0
      flowers = 0
    }
  }

  return count >= m
}

/**
 * 最少天数
 * @param bloomDay  bloomDay[i] 第i朵花开的时间
 * @param m 花束
 * @param k 相邻的k朵
 * @returns
 */
function minDays(bloomDay: number[], m: number, k: number): number {
  // Think for yourself for 5 minutes...
  // 设n=bloomDay.length
  // q1. n必须>=m*k 才足够制作需要的花束
  // q2. 天数最小应该是min(bloomDay) 最多应该是max(bloomDay)
  if (m > bloomDay.length / k) {
    return -1
  }
  let left = Math.min(...bloomDay)
  let right = Math.max(...bloomDay)
  while (left < right) {
    const mid = Math.floor((left + right) / 2)
    if (verification(bloomDay, mid, m, k)) {
      right = mid
    } else {
      left = mid + 1
    }
  }

  return left
}
```
### ⭐️优势洗牌
> 给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] > nums2[i] 的索引 i 的数目来描述。
> 返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。
> 输入：nums1 = [2,7,11,15], nums2 = [1,10,4,11] 输出：[2,11,7,15]
> 来源：[https://leetcode.cn/problems/advantage-shuffle](https://leetcode.cn/problems/advantage-shuffle)

#### 代码实现
```typescript
function advantageCount(nums1: number[], nums2: number[]): number[] {
  // Think for yourself for 5 minutes...
  // q1. 优势最大化 尽量让nums1[i]的每一位都大于nums2[j]的每一位
  // q2. 将nums1 升序排序，确保在和nums2的每一项对比的过程中尽量选比nums2[i]大但不是最大的数
  nums1.sort((a, b) => a - b)

  const ans: number[] = []

  /**
   * 从nums中找比target大的数
   * @param nums
   * @param target
   */
  const getMax = (nums: number[], target: number) => {
    for (let i = 0; i < nums.length; i++) {
      if (nums[i] > target) {
        return i
      }
    }
    // 找不到就取第一个
    return 0
  }

  for (let i = 0; i < nums2.length; i++) {
    const idx = getMax(nums1, nums2[i])
    ans.push(nums1[idx])
    // 取一个就删掉一个
    nums1.splice(idx, 1)
  }

  return ans
}
```







## 拓展
### N数相加返回数值的解法
```typescript
/**
 *  nsum通用解法，支持2sum，3sum，4sum...等等
 *  时间复杂度分析：
 *  1. n = 2时，时间复杂度O(NlogN)，排序所消耗的时间。、
 *  2. n > 2时，时间复杂度为O(N^n-1)，即N的n-1次方，至少是2次方，此时可省略排序所消耗的时间。举例：3sum为O(n^2)，4sum为O(n^3)
 * @param {number[]} nums
 * @return {number[][]}
 */
const threeSum = function (nums: number[]) {
  // nsum通用解法核心方法
  function nSumTarget(nums: number[], n: number, start: number, target: number) {
    // 前提：nums要先排序好
    let res: number[][] = []
    if (n === 2) {
      res = towSumTarget(nums, start, target)
    } else {
      for (let i = start; i < nums.length; i++) {
        // 递归求(n - 1)sum
        let subRes = nSumTarget(nums, n - 1, i + 1, target - nums[i])
        for (let j = 0; j < subRes.length; j++) {
          res.push([nums[i], ...subRes[j]])
        }
        // 跳过相同元素
        while (nums[i] === nums[i + 1]) i++
      }
    }
    return res
  }

  function towSumTarget(nums: number[], start: number, target: number) {
    // 前提：nums要先排序好
    let res: number[][] = []
    let len = nums.length
    let left = start
    let right = len - 1
    while (left < right) {
      let sum = nums[left] + nums[right]
      if (sum < target) {
        while (nums[left] === nums[left + 1]) left++
        left++
      } else if (sum > target) {
        while (nums[right] === nums[right - 1]) right--
        right--
      } else {
        // 相等
        res.push([nums[left], nums[right]])
        // 跳过相同元素
        while (nums[left] === nums[left + 1]) left++
        while (nums[right] === nums[right - 1]) right--
        left++
        right--
      }
    }
    return res
  }
  nums.sort((a, b) => a - b)
  // n = 3，此时求3sum之和
  return nSumTarget(nums, 3, 0, 0)
}
```






## 资料

二分查找细节详解

