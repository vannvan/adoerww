# 数据结构:二叉堆 
概念：

1. 是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且**最后一层的叶节点尽可能都是左侧子节点**，这叫作结构特性。
2. 二叉堆不是最小堆(又叫小顶堆)就是最大堆(又叫大顶堆)。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。这叫作堆特性。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676703422472-79a898b9-8404-4c1d-8c86-30592462052a.png#averageHue=%23f6f6f6&clientId=uf5722c73-f15e-4&from=paste&height=255&id=ua77a5c4d&name=image.png&originHeight=632&originWidth=1486&originalType=binary&ratio=2&rotation=0&showTitle=false&size=279189&status=done&style=none&taskId=u6210468a-39fe-42c5-b7ae-dcc6e418130&title=&width=600)
**最小堆形态上是从根节点到叶子节点逐渐变大的；最大堆反之！**
## 自我调整
### 插入节点
插入节点的思路：在完全二叉树的最后一个位置插入一个节点，然后让这个节点向上比较（上浮过程），如果比父节点小，则与父节点交换位置，依次向上比较，直至根节点；或者出现比父节点大的情况就停止
### 删除节点
删除节点的思路：只要不是删除最后一个叶子节点，就将最后一个叶子节点替换到被删除节点的位置，然后让这个节点向下比较，如果比它的左右孩子节点都大，就把左右节点中较小值节点和这个节点的位置进行交换（下沉过程），直到没有孩子节点为止。
### 构建二叉堆
构建二叉堆，就是把一个无序的二叉树调整为二叉堆，本质就是让所有非叶子节点依次下沉。
它从最后一个非叶子节点开始，进行下沉操作，也就是如果它比它的左右子节点都大，则它与最小子节点交换位置。然后找到倒数第二个非叶子节点，重复此操作，直至根节点下沉完，结束。
## 存储方式
在数组方式存储中，树的节点间关系是这样的:

- 父节点的位置下标parent, 左孩子节点位置就是：2parent+1, 右孩子节点位置就是：2parent+2，即如果父节点下标为0，则其左节点为1，右节点为2
- 如果根据子节点来计算父节点的位置，如果子节点下标是奇数child（也就是左孩子节点），那么父节点为 (child - 1) / 2; 如果子节点是偶数（也就是右孩子节点），那么父节点为 (child - 2) / 2
## 代码实现
```javascript
/*
 * Description: 二叉堆
 * Created: 2023-02-18 14:59:06
 * Author: van
 * Email : adoerww@gamil.com
 * -----
 * Last Modified: 2023-02-18 18:08:58
 * Modified By: van
 * -----
 * Copyright (c) 2023 https://github.com/vannvan
 */

// 小顶堆
class MinHeap {
  constructor() {
    this.heap = []
  }

  insert(value) {
    if (value != null) {
      this.heap.push(value)
      // 上移，直到父节点小于这个值
      this.siftUp(this.heap.length - 1)
      return true
    }
    return false
  }

  siftUp(index) {
    let parent = this.getParentIndex(index)
    while (index > 0 && this.compare(this.heap[parent], this.heap[index])) {
      this.swap(this.heap, index, parent)
      index = parent
      parent = this.getParentIndex(index)
    }
  }

  swap(arr, a, b) {
    ;[arr[a], arr[b]] = [arr[b], arr[a]]
    return arr
  }

  /**
   * 最小堆 是 a>b  最大堆改为 a<b 即可
   * @param {*} a
   * @param {*} b
   * @returns
   */
  compare(a, b) {
    return a >= b
  }

  /**
   * 移除最小值或最大值
   * @param {*} value
   */
  extract() {
    if (this.isEmpty()) {
      return undefined
    }
    if (this.size() === 1) {
      return this.heap.shift()
    }

    const removedValue = this.heap[0]
    this.heap[0] = this.heap.pop() // 将数组末尾的值赋值给头部,并删除末尾的值
    this.siftDown(0)  // 从根节点往下开始比较
    return removedValue
  }

  /**
   * 获取堆顶元素并移除
   */
  pop() {
    let out = this.heap[0]

    // 将最后一个元素放到堆顶
    this.heap[0] = this.heap.pop()

    // 开始调整
    let index = 0
    this.siftDown(index)
    return out
  }

  /**
   * siftDown 做的事情就是 将 父节点 与 左 右子节点比较 
   * 下方注释均是以最小堆为例，当是最大堆时，比较关系就是相反的
   * @param {*} index
   */
  siftDown(index) {
    //向下冒泡
    let left = this.getLeftIndex(index)
    let right = this.getRightIndex(index)
    // 比较当前节点与左右子节点的关系，如果当前节点比左右子节点都大的话，分两种情况
    if (
      this.compare(this.heap[index], this.heap[left]) &&
      this.compare(this.heap[index], this.heap[right])
    ) {
      if (!this.compare(this.heap[right], this.heap[left])) {  // 情况1 左边大于右，当前节点跟右边调换位置
        this.swap(this.heap, right, index)
        this.siftDown(right)
      } else {  // 情况2 右大于左 当前节点和左边调换关系
        this.swap(this.heap, left, index)
        this.siftDown(left)
      }
    } else if (this.compare(this.heap[index], this.heap[left])) { // 如果当前节点仅大于左边，跟左边调换
      this.swap(this.heap, left, index)
      this.siftDown(left)
    } else if (this.compare(this.heap[index], this.heap[right])) {  // 如果当前节点仅大于右边，跟右边调换
      this.swap(this.heap, right, index)
      this.siftDown(right)
    }
  }

  isEmpty() {
    return this.size() === 0
  }

  size() {
    return this.heap.length
  }

  findMinimum() {
    return this.isEmpty() ? undefined : this.heap[0]
  }

  getLeftIndex(index) {
    return 2 * index + 1
  }

  getRightIndex(index) {
    return 2 * index + 2
  }

  getParentIndex(index) {
    if (index == 0) {
      return undefined
    }
    return Math.floor((index - 1) / 2)
  }
}

// const mh = new MinHeap()

// mh.insert(1)
// mh.insert(13)
// mh.insert(7)

// mh.insert(8)
// mh.insert(6)
// // mh.insert(5)
// mh.insert(2)

// const arr = Array.from({ length: 10 }, (v, k) => k + 1)

// arr.forEach((value) => {
//   mh.insert(value)
// })

// mh.extract()

// console.log(mh)

// 大顶堆
class MaxHeap extends MinHeap {
  constructor() {
    super()
  }
  compare(a, b) {
    return a < b
  }
}


const maxHeap = new MaxHeap()

maxHeap.insert(2)
maxHeap.insert(1)
maxHeap.insert(5)
maxHeap.insert(4)
maxHeap.insert(6)
maxHeap.insert(3)
maxHeap.insert(0)
maxHeap.insert(2)

console.log(maxHeap)

```
### siftUp过程图示
不断比较当前节点和父节点，如果父节点大于当前节点，就把当前节点和父节点的位置调换。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676718164056-20806717-2215-4103-b078-a7c169b93237.png#averageHue=%23f6f6f6&clientId=u8352fa5b-e350-4&from=paste&height=146&id=u4beb6e3c&name=image.png&originHeight=376&originWidth=1550&originalType=binary&ratio=2&rotation=0&showTitle=false&size=165805&status=done&style=none&taskId=u17b6c8ba-47c3-495a-a3ed-11b2174ab53&title=&width=600)
### siftDown过程图示
当删除1时，将最后一项元素移到1的位置(就是extract完成的操作)，此时显然是不平衡的，再从根节点开始比较节点与左右子节点的关系，完成位置调换，不断重复这个过程，直到满足平衡条件。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676707358153-1a1ac19e-fff1-4e47-b2c2-1a0a82784fe5.png#averageHue=%23f7f7f7&clientId=u0bf7c76a-f53c-4&from=paste&height=271&id=u9b32639d&name=image.png&originHeight=664&originWidth=1470&originalType=binary&ratio=2&rotation=0&showTitle=false&size=311967&status=done&style=none&taskId=u5636b416-7647-4785-b209-0a957b8ffeb&title=&width=600)
### 关键点
对于给定位置 index 的节点：

1. 它的左侧子节点的位置是 2 * index + 1（如果位置可用）；
2. 它的右侧子节点的位置是 2 * index + 2（如果位置可用）；
3. 它的父节点位置是 index / 2（如果位置可用）计算时需要取整

### 二叉堆排序
```javascript
function firstHeapSort(arr, options) {
  let res = []
  //创建一个堆
  let Heap = new MinHeap()
  if (options === -1) {
    Heap = new MaxHeap()
  }
  //将数组插到堆里
  arr.forEach((el) => Heap.insert(el))

  //每次取出最值 push进去即可
  for (let i = 0, j = Heap.size(); i < j; i++) {
    res.push(Heap.extract())
  }
  return res
}

console.log('堆排序', firstHeapSort([3, 5, 1, 6, 4, 7, 2], 1))   // 
console.log('堆排序', firstHeapSort([3, 5, 1, 6, 4, 7, 2], -1))
```
## 应用
[215：数组中的第K个最大元素](https://www.yuque.com/vannvan/tools/rdgirsg7z6083f3x#YriO1)
## 资料
