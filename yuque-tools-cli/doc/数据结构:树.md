# 数据结构:树 
概念：
> [https://www.yuque.com/vannvan/tools/vh7v1ihxmexcft9o#AKDgl](https://www.yuque.com/vannvan/tools/vh7v1ihxmexcft9o#AKDgl)


形态及叫法示例
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676556315908-7d15fe96-adf4-4098-865d-190cbb850451.png#averageHue=%23f2f2f2&clientId=u1c3f2590-d264-4&from=paste&height=329&id=uc76de9ad&name=image.png&originHeight=772&originWidth=1408&originalType=binary&ratio=2&rotation=0&showTitle=false&size=334028&status=done&style=none&taskId=u7e50bcca-c9a6-48e0-82ee-d769c1e1f09&title=&width=600)

## 二叉树和二叉搜索树
**二叉树**中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。
**二叉搜索树**（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。

## 二叉搜索树
### 常用方法

1. intert(key)  插入新的键
2. preOrder()  先序遍历  
3. inOrder()  中序遍历
4. postOrder()  后序遍历
5. min()
6. max()
7. find()  是否存在

**ps:// 所谓 先 中 后 序遍历，就是根节点的遍历顺序不同**
#### 三种顺序的区别
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678185763041-e6d05ee6-b3be-40f2-aff7-dbcbd9f8a383.png#averageHue=%23f2f2f2&clientId=u7f9172f5-83ac-4&from=paste&height=265&id=u41773df5&name=image.png&originHeight=530&originWidth=788&originalType=binary&ratio=2&rotation=0&showTitle=false&size=159078&status=done&style=none&taskId=u0f5bc0d0-6a11-4a79-a701-be177d19be3&title=&width=394)
先序遍历
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678185783587-dee50e3c-3497-47e4-aeb2-cf9c39d16514.png#averageHue=%23efefef&clientId=u7f9172f5-83ac-4&from=paste&height=265&id=u628a2e70&name=image.png&originHeight=478&originWidth=766&originalType=binary&ratio=2&rotation=0&showTitle=false&size=172720&status=done&style=none&taskId=uea2a9d32-622a-450d-a8a9-c763893d078&title=&width=425)
中序遍历
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1678185808154-f446828d-f9ab-4d90-bfee-c9206684dda6.png#averageHue=%23f0f0f0&clientId=u7f9172f5-83ac-4&from=paste&height=241&id=u865cd0c1&name=image.png&originHeight=482&originWidth=758&originalType=binary&ratio=2&rotation=0&showTitle=false&size=169205&status=done&style=none&taskId=u5b8c8441-d8e0-45ea-aa44-30495ba096a&title=&width=379)
后序遍历
### 代码实现
```javascript
/*
 * Description: 二叉搜索树
 * Created: 2023-02-14 22:12:26
 * Author: van
 * Email : adoerww@gamil.com
 * -----
 * Last Modified: 2023-02-16 22:35:24
 * Modified By: van
 * -----
 * Copyright (c) 2023 https://github.com/vannvan
 */

// 节点对象

class Node {
  constructor(data) {
    this.root = this
    this.data = data
    this.left = null
    this.right = null
  }
}

class BST {
  constructor() {
    this.root = null
  }

  /**
   * 插入节点
   * @param {any} data
   */
  insert(data) {
    let newNode = new Node(data)
    let insertData = (node, newNode) => {
      // 当前值与上一级对比小的话
      if (newNode.data < node.data) {
        // 如果当前的下一级左边没有就给左边
        if (node.left === null) {
          node.left = newNode
        } else {
          // 给当前左边的更下一级的左边
          insertData(node.left, newNode)
        }
      } else {
        if (node.right === null) {
          node.right = newNode
        } else {
          insertData(node.right, newNode)
        }
      }
    }

    // 如果没有根节点就把当前节点作为根节点
    if (!this.root) {
      this.root = newNode
    } else {
      insertData(this.root, newNode)
    }
  }

  /**
   * 先序遍历
   * @returns []
   */
  preOrder() {
    let results = []
    const order = (node) => {
      if (node != null) {
        results.push(node.data)
        order(node.left)
        order(node.right)
      }
    }
    order(this.root)
    return results
  }

  /**
   * 中序遍历
   * @returns []
   */
  inOrder() {
    let results = []
    const order = (node) => {
      if (node != null) {
        order(node.left)
        results.push(node.data)
        order(node.right)
      }
    }
    order(this.root)
    return results
  }

  /**
   * 后序遍历
   * @returns []
   */
  postOrder() {
    let results = []
    const order = (node) => {
      if (node != null) {
        order(node.left)
        order(node.right)
        results.push(node.data)
      }
    }
    order(this.root)
    return results
  }

  min() {
    return this.minNode(this.root)
  }

  minNode(node) {
    let current = node
    while (current != null && current.left != null) {
      current = current.left
    }
    return current.data
  }

  max() {
    return this.maxNode(this.root)
  }

  maxNode(node) {
    let current = node
    while (current != null && current.right != null) {
      current = current.right
    }
    return current.data
  }

  /**
   * 查找值
   * @param {any} data
   * @returns boolean
   */
  find(data) {
    let findNode = (node, data) => {
      if (node === null) return false
      if (node.data === data) return true
      return findNode(data < node.data ? node.left : node.right, data)
    }
    return findNode(this.root, data)
  }

  remove(data) {
    let removeNode = (node, data) => {
      if (node === null) return null
      if (node.data === data) {
        // 没有左右子节点，指向null移除它
        if (node.left === null && node.right === null) return null
        // 它没有左节点，需要把它的引用改为右节点
        if (node.left === null) return node.right
        // 他没有右节点，需要把它的引用改为左节点
        if (node.right === null) return node.left
        // 有左右节点，当找到了要移除的节点后,需要找到它右边子树最小的节点,即它的继承者
        if (node.left !== null && node.right !== null) {
          let _node = this.minNode(node.right)
          node.data = _node.data // 用右侧子树最小的节点的键去更新node的键
          node.right = removeNode(node.right, data) // 更新完node的键后，树中存在了两个相同的键，因此需要移除多余的键
          return node
        }
      } else if (data < node.data) {
        // 目标key小于当前节点的值则沿着树的左边找
        node.left = removeNode(node.left, data)
        return node
      } else {
        // 目标key大于当前节点的值则沿着树的右边找
        node.right = removeNode(node.right, data)
        return node
      }
    }
    // 返回已处理完的树
    return removeNode(this.root, data)
  }
}

const datas = [11, 7, 5, 3, 6, 9, 8, 10, 20, 14, 12, 25, 18]

const bst = new BST()

datas.forEach((value) => {
  bst.insert(value)
})
// console.dir(bst)

// let s = bst.inOrder()
// let d = bst.preOrder()
// let k = bst.postOrder()
// console.log(s)
// console.log(d)
// console.log(k)

console.log('min', bst.min())

console.log('max', bst.max())

console.log('find 8', bst.find(8))

console.log('find 21', bst.find(21))

const s = bst.remove(7)

console.dir(s)

```
#### 非递归三种遍历
```typescript
// 前序遍历:

// 入栈 右 -> 左
// 出栈 中 -> 左 -> 右
const preorderTraversal = function(root, res = []) {
    if(!root) return res;
    const stack = [root];
    let cur = null;
    while(stack.length) {
        cur = stack.pop();
        res.push(cur.val);
        cur.right && stack.push(cur.right);
        cur.left && stack.push(cur.left);
    }
    return res;
};

// 后序遍历:

// 入栈 左 -> 右
// 出栈 中 -> 右 -> 左 结果翻转

const postorderTraversal = function(root, res = []) {
    if (!root) return res;
    const stack = [root];
    let cur = null;
    while(stack.length) {
      cur = stack.pop();
      res.push(cur.val);
      cur.left && stack.push(cur.left);
      cur.right && stack.push(cur.right);
    }
    // 注意这里
    return res.reverse();
};

// 中序遍历:

// 入栈 左 -> 右
// 出栈 左 -> 中 -> 右

const inorderTraversal = function(root, res = []) {
    const stack = [];
    let cur = root;
    while(stack.length || cur) {
        if(cur) {
            stack.push(cur);
            // 左
            cur = cur.left;
        } else {
            // --> 弹出 中
            cur = stack.pop();
            res.push(cur.val); 
            // 右
            cur = cur.right;
        }
    };
    return res;
};


```
#### BFS
```javascript
 bfs() {
    if (!this.root) return
    const queue = [this.root]
    while (queue.length) {
      const node = queue.shift()
      console.log('data', node.data)
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
  }
```
#### DFS
```javascript
 dfs() {
    const deep = (root) => {
      if (!root) return
      console.log('data',root.data)
      root.left && deep(root.left)
      root.right && deep(root.right)
    }
    deep(this.root)
}
```
## 平衡二叉树
### 概念
AVL树是一种自平衡树。添加或移除节点时，AVL树会尝试保持自平衡。任意一个节点（不论深度）的左子树和右子树高度**最多相差1**。添加或移除节点时，AVL树会尽可能尝试转换为完全树。
### 特点
**查找效率高<logn,但插入和删除效率低，每次都需要找平衡**
### 关键概念
**平衡因子**：左子树高度 - 右子树高度的值  简称**BF**
**最小不平衡树**：距离插入节点最近的，并且 BF 的绝对值大于 1 的节点为根节点的子树。「旋转」纠正只需要纠正「最小不平衡子树」即可
### 四种旋转纠错类型

1. LL 型：插入左孩子的左子树，右旋  
2. RR 型：插入右孩子的右子树，左旋
3. LR 型：插入左孩子的右子树，先左旋，再右旋
4. RL 型：插入右孩子的左子树，先右旋，再左旋


![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676632221180-f92a7f7a-3f2c-4ba6-b5fe-47919ad56e93.png#averageHue=%23fbf4ee&clientId=u24be3e6f-432c-4&from=paste&height=233&id=u89d75933&name=image.png&originHeight=473&originWidth=1217&originalType=binary&ratio=2&rotation=0&showTitle=false&size=78786&status=done&style=none&taskId=ub4504533-6e53-4803-a175-50119f75ed6&title=&width=600)

### 代码实现
```javascript
/*
 * Description: 平衡二叉树 不是很完善 理解思路即可
 * Created: 2023-02-16 23:02:56
 * Author: van
 * Email : adoerww@gamil.com
 * -----
 * Last Modified: 2023-02-17 22:25:13
 * Modified By: van
 * -----
 * Copyright (c) 2023 https://github.com/vannvan
 */

// import BinarySearchTree from './binarySearchTree'

const BalanceFactor = {
  UNBALANCED_RIGHT: 1,
  SLIGHTLY_UNBALANCED_RIGHT: 2,
  BALANCED: 3,
  SLIGHTLY_UNBALANCED_LEFT: 4,
  UNBALANCED_LEFT: 5,
}

class Node {
  constructor(data) {
    this.root = this
    this.data = data
    this.left = undefined
    this.right = undefined
  }
}
class AVLTree {
  constructor() {
    this.root = null
  }

  insert(data) {
    this.root = this.insertNode(this.root, data)
  }

  insertNode(node, data) {
    if (node == null) {
      return new Node(data)
    } else if (data < node.data) {
      // console.log('小于')
      // 往左添加
      node.left = this.insertNode(node.left, data)
    } else if (data > node.data) {
      // console.log('大于')
      // 往右添加
      node.right = this.insertNode(node.right, data)
    } else {
      return node
    }
    // 判断是否需要平衡，只需要处理已经打破平衡的情况
    const balanceFactor = this.getBalance(node)
    // 左边高度差过大 5
    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {
      // 如果插入值小于左边的值
      console.log('左边高度差过大')
      if (data < node.left.data) {
        node = this.rotationLL(node)
      } else {
        return this.rotationLR(node)
      }
    }

    // 右边高度过大 1
    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {
      console.log('右边高度过大')
      if (data > node.right.data) {
        node = this.rotationRR(node)
      } else {
        return this.rotationRL(node)
      }
    }
    return node
  }

  removeNode(node, data) {
    node = this.remove(node, data)
    // console.dir(node)
    if (node == null) {
      return node
    }

    const balanceFactor = this.getBalance(node)

    console.log('删除完的平衡因子', balanceFactor)

    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) {
      if (
        this.getBalance(node.left) === BalanceFactor.BALANCED ||
        this.getBalance(node.left) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT
      ) {
        return this.rotationLL(node)
      }
      if (
        this.getBalance(node.left) === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT
      ) {
        return this.rotationLR(node)
      }
    }

    if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) {
      if (
        this.getBalance(node.right) === BalanceFactor.BALANCED ||
        this.getBalance(node.right) === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT
      ) {
        return this.rotationRR(node)
      }

      if (
        this.getBalance(node.right) === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT
      ) {
        return this.rotationRL(node)
      }
    }
    return node
  }

  /**
   * 移除节点
   * @param {*} data
   * @returns
   */
  remove(data) {
    const removeNode = (node, data) => {
      if (!node) return null
      console.log('node', node)
      if (node.data === data) {
        // 没有左右子节点，指向null移除它
        if (node.left === null && node.right === null) return null
        // 它没有左节点，需要把它的引用改为右节点
        if (node.left === null) return node.right
        // 他没有右节点，需要把它的引用改为左节点
        if (node.right === null) return node.left
        // 有左右节点，当找到了要移除的节点后,需要找到它右边子树最小的节点,即它的继承者
        if (node.left !== null && node.right !== null) {
          let _node = this.minNode(node.right)
          node.data = _node.data // 用右侧子树最小的节点的键去更新node的键
          node.right = removeNode(node.right, data) // 更新完node的键后，树中存在了两个相同的键，因此需要移除多余的键
          return node
        }
      } else if (data < node.data) {
        // 目标key小于当前节点的值则沿着树的左边找
        node.left = removeNode(node.left, data)
        return node
      } else {
        // 目标key大于当前节点的值则沿着树的右边找
        node.right = removeNode(node.right, data)
        return node
      }
    }
    // 返回已处理完的树
    return removeNode(this.root, data)
  }
  minNode(node) {
    let current = node
    while (current != null && current.left != null) {
      current = current.left
    }
    return current.data
  }

  /**
   * 获取节点高度
   * @param {*} node
   * @returns
   */
  getNodeHeight(node) {
    if (!node) {
      return -1
    }
    return (
      Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right)) +
      1
    )
  }

  getBalance(node) {
    const heightDifference =
      this.getNodeHeight(node.left) - this.getNodeHeight(node.right)
    console.log(`${node.data}的平衡因子为:`, heightDifference)
    switch (heightDifference) {
      case -2:
        return BalanceFactor.UNBALANCED_RIGHT
      case -1:
        return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT
      case 1:
        return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT
      case 2:
        return BalanceFactor.UNBALANCED_LEFT
      default:
        return BalanceFactor.BALANCED
    }
  }

  /**
   * 左旋
   * 这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的
   * @param {*} node
   */
  rotationLL(node) {
    const tmp = node.left
    node.left = tmp.right
    tmp.right = node
    return tmp
  }
  /**
   * 右旋
   * 它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的
   * @param {*} node
   */
  rotationRR(node) {
    const tmp = node.right
    node.right = tmp.left
    tmp.left = node
    return tmp
  }

  /**
   * 先右再左
   * 出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重
   * @param {*} node
   */
  rotationRL(node) {
    node.left = this.rotationLL(node)
    return this.rotationRR(node)
  }

  /**
   * 先左再右
   * 出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重
   */
  rotationLR(node) {
    node.right = this.rotationRR(node)
    return this.rotationLL(node)
  }
}

const avl = new AVLTree()

// const datas = [3, 5, 7, 15, 24, 56, 11, 33, 42, 2, 4, 6, 12]  // 这个会报错

// const datas = [1, 2, 3, 4, 5, 6, 7, 14, 15, 13, 12, 11]  //这个会报错

const datas = [30, 27, 60, 12, 10]

datas.forEach((item) => {
  avl.insert(item)
})

avl.removeNode(30)

console.dir(avl)

```

## 红黑树
### 概念

1. 根节点是黑色，叶节点是不存储数据的黑色空节点。
2. 任何相邻的两个节点都不能同时为红色(指**上下相邻**)，因此可知**每个红色节点的两个子节点都是黑色。**
3. 任意节点到其可到达的**叶节点**间包含相同数量的**黑色节点。**
### 特点
**查找效率低，但插入和删除效率高，性能更稳定**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676645228652-0b8fa126-f34e-4c30-818a-a05d68f191e8.png#averageHue=%23efeeed&clientId=u19e28915-c0cd-4&from=paste&height=248&id=uvPKg&name=image.png&originHeight=846&originWidth=904&originalType=binary&ratio=2&rotation=0&showTitle=false&size=189187&status=done&style=none&taskId=uf5e11371-214e-4999-bbf1-daf95dc3a77&title=&width=265)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676645063504-6d558ae6-7e7c-4a3c-83dc-f11f93553a74.png#averageHue=%23fcfbfb&clientId=u19e28915-c0cd-4&from=paste&height=243&id=bOdbl&name=image.png&originHeight=714&originWidth=1764&originalType=binary&ratio=2&rotation=0&showTitle=false&size=246080&status=done&style=none&taskId=u8d3bc72f-8160-4f5e-928f-6289262ae91&title=&width=600)
**红黑树通过变色、左旋、右旋来保持二叉搜索树的平衡性**（这里的平衡性指的是黑色平衡，所谓的黑色平衡就是每个节点到叶子节点所经过的黑色节点是一致的），性能要优于AVL树，所以现在平衡树的应用都是红黑树。

### 前置知识
#### 2-3树
##### 特征

1. 2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点)，简单讲就是有两个孩子的叫2节点，有三个孩子的叫3节点。
2. 一个2节点包含一个元素(自身)和两个孩子(或没有孩子)，且当有孩子时，左孩子比自身小，右孩子比自身大。
3. 一个3节点包含一大一小(左小右大)两个元素和三个孩子(或没有孩子)，且其左子树包含小于较小元素的元素，右子树包含较大于较大元素的元素。

**插入或删除操作都需要保证以上三个性质特征，打破平衡就需要拆分整合。**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676685579982-dcf60cb3-291c-4934-9f8a-e4d3a5087485.png#averageHue=%23f6f6f6&clientId=ucd5ca581-0322-4&from=paste&height=236&id=u24c76198&name=image.png&originHeight=622&originWidth=1584&originalType=binary&ratio=2&rotation=0&showTitle=false&size=138704&status=done&style=none&taskId=uf60f29b0-7297-4a52-b921-a8c2d34e8c6&title=&width=600)
#### 2-3-4树
##### 概念
它是2-3树的扩展，包含了4节点的使用，一个4结点包含小中大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的元素；右子树包含大于最大元素的元素。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676686864575-95966dc2-8765-473b-ab1d-c7d5b54d4612.png#averageHue=%23d9e6fb&clientId=ucd5ca581-0322-4&from=paste&height=237&id=ubf2eb3b4&name=image.png&originHeight=474&originWidth=1502&originalType=binary&ratio=2&rotation=0&showTitle=false&size=412707&status=done&style=none&taskId=u50c6e4d2-531d-43a6-81fe-ef2b8430e99&title=&width=751)
**2-3-4树把数据存储在元素中，元素组成节点，节点只能是下列之一：**

- 2-节点：包含一个元素和2个子节点；
- 3-节点：包含两个元素和3个子节点；
- 4-节点：包含三个元素和4个子节点

以添加7、1、2、5、6、9、8、4、3构建2-3-4树为例
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676686453215-cf1946ad-bd23-4f68-8efb-549ca6204180.png#averageHue=%23fafafa&clientId=ucd5ca581-0322-4&from=paste&height=212&id=u1a98869e&name=image.png&originHeight=576&originWidth=1634&originalType=binary&ratio=2&rotation=0&showTitle=false&size=126912&status=done&style=none&taskId=ubd040eff-ee33-480f-b147-d0da3ac59df&title=&width=600)
删除顺序1、6、3、4、5、2、9
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676686500698-1646fc0d-0724-498a-9aa6-99c1b74a1b5f.png#averageHue=%23fafafa&clientId=ucd5ca581-0322-4&from=paste&height=210&id=u84696ffd&name=image.png&originHeight=564&originWidth=1608&originalType=binary&ratio=2&rotation=0&showTitle=false&size=131224&status=done&style=none&taskId=ueed126f7-11cb-4fd6-8136-cdae5a922f2&title=&width=600)

#### 红黑树与2-3-4树的关系
2-3-4树的任意一个节点，都至少对应红黑树的一种结构，也就是说2-3-4树至少对应一棵红黑树，一棵红黑树对应一颗2-3-4树。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676687246878-bca8b4b3-7845-46aa-9bdb-6aad30e531cf.png#averageHue=%23f0eeee&clientId=ucd5ca581-0322-4&from=paste&height=529&id=u1a3c719f&name=image.png&originHeight=1230&originWidth=1394&originalType=binary&ratio=2&rotation=0&showTitle=false&size=501846&status=done&style=none&taskId=u0e521d0e-3c14-4b57-9e13-af3996dd958&title=&width=600)
2-3-4树转换为红黑树
出现红色节点的情况主要有两种情况：

- 2-3-4树的3节点会出现一个红色节点；
- 2-3-4树的4节点会出现两个红色节点；

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676687466913-0a9b4be7-9e38-4aae-a081-5d41a967330b.png#averageHue=%23d5e7d3&clientId=ucd5ca581-0322-4&from=paste&height=355&id=ua9b5501d&name=image.png&originHeight=918&originWidth=1550&originalType=binary&ratio=2&rotation=0&showTitle=false&size=289236&status=done&style=none&taskId=u1abe7da4-a175-47e6-9fe5-a6c18817900&title=&width=600)

#### 实现要点
为了保持红黑树的黑色平衡，插入节点时需要进行相应的变色和旋转操作，以插入时为例，情况主要分为以下几种：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676782944715-d0e3c08d-be66-4032-b91d-9ac899c0fde0.png#averageHue=%23fcfbfb&clientId=u57316834-472a-4&from=paste&height=719&id=u1ebf46f4&name=image.png&originHeight=1437&originWidth=2269&originalType=binary&ratio=2&rotation=0&showTitle=false&size=278269&status=done&style=none&taskId=u3af76059-609c-44b9-b1ce-c88ffa8e107&title=&width=1134.5)


代码实现见资料4

## 资料


动画解析比较清晰

这篇写法是比较健壮的版本

讲的很明白
有图例过程

在线可视化体验红黑树增删过程

一个很好的红黑树插入理解思路
[点击查看【bilibili】](https://player.bilibili.com/player.html?bvid=BV1xG4y1b7Zu)
