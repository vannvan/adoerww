# 算法:排序 
## 冒泡排序
描述：从序列右边开始比较相邻两个数字的大小，再根据结果交换两个数字的位置。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676387779483-bd80cb56-2791-48c3-9170-131feeefbfbd.png#averageHue=%23fcf5ed&clientId=u6ceff566-5185-4&from=paste&height=202&id=ufa11500e&name=image.png&originHeight=502&originWidth=1492&originalType=binary&ratio=2&rotation=0&showTitle=false&size=123836&status=done&style=none&taskId=ub064a25c-5f3e-4913-a683-17c487c1938&title=&width=600)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676387793738-f63a0209-9241-4c3d-902d-173650f81bd2.png#averageHue=%23fdf8f2&clientId=u6ceff566-5185-4&from=paste&height=208&id=ube0f921b&name=image.png&originHeight=562&originWidth=1618&originalType=binary&ratio=2&rotation=0&showTitle=false&size=125747&status=done&style=none&taskId=u3794b4a5-66cb-4283-8731-ba39096869c&title=&width=600)


第1轮需要比较n-1次，第2轮需要比较n-2次……第n-1轮需要比较1次。因此，总的比较次数为（n-1）+（n-2）+…+1≈n2/2。时间复杂度为O（n^2）。
理解：通过一趟又一趟的元素交换排序，达成最终的排序，也就是说一趟排序可以排好一个元素到最后，每一趟下来，需要排序的元素都会少一个。
### 代码实现
```javascript
// 简单理解版
const bubbleSort = (arr) => {
  const len = arr.length
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - 1 - i; j++) {  // 每排一次后面就少排一个数
      // 如果当前项大于下一项值
      if (arr[j] > arr[j + 1]) {
        let tmp = arr[j + 1] // 下一项值缓存一个
        arr[j + 1] = arr[j] // 下一项值改为当前值
        arr[j] = tmp // 当前值改为下一项值
      }
    }
  }
  return arr
}

// 优化版
function bubbleSort(arr) {
  var len = arr.length;
  for (var i = 0; i < len; i++) {
    var exchange=false; // 交换标志 
    for (var j = 0; j < len - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) { // 相邻元素两两对比
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] // 元素交换
        exchange=true; //
      }
    }
    if(!exchange){ // 若本趟排序未发生交换，提前终止算法
        break;
    }
  }
  return arr;
}

const nums = [5, 7, 0, 1, 2, 3, 9, 8, 6]

const res = bubbleSort(nums)
```

### 实现要点

1. 两层循环不能少，外层控制趟数，内层控制排序次数
2. 外层循环len-1次，内层循环len-1-i次，-i是因为每一轮排完剩余需要排的都是len-1-i次


## 选择排序
描述：从待排序的数据中**寻找最小值**，将其与序列最左边的数字进行交换
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676387912410-7519b58a-62dc-4ed5-90e3-8ff9c786ff46.png#averageHue=%23fcf3e9&clientId=u6ceff566-5185-4&from=paste&height=142&id=uca5303b4&name=image.png&originHeight=380&originWidth=1602&originalType=binary&ratio=2&rotation=0&showTitle=false&size=129853&status=done&style=none&taskId=ue8fa3184-fc77-402f-8c86-19c58789757&title=&width=600)

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676387925022-3d80003f-5711-4f25-83fa-9c43c9815981.png#averageHue=%23fcf6ef&clientId=u6ceff566-5185-4&from=paste&height=218&id=u55ccbf28&name=image.png&originHeight=558&originWidth=1536&originalType=binary&ratio=2&rotation=0&showTitle=false&size=136634&status=done&style=none&taskId=u3ce3e216-378f-4a88-9a80-b80f797f46a&title=&width=600)


第1轮中需要比较n-1个数字，第2轮需要比较n-2个数字……到第n-1轮的时候就只需比较1个数字了。因此，总的比较次数与冒泡排序的相同，都是（n-1）+（n-2）+…+1≈n2/2次。时间复杂度为O（n^2）。

### 代码实现
```javascript

const selectorSort = (arr) => {
  const len = arr.length
  let minIndex = null // 最小值的索引
  for (let i = 0; i < len - 1; i++) {
    // 先认为当前项是最小值
    minIndex = i
    // 从当前项的下一项开始比，所以从j初始值为 i+1
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j  // 将最小的索引保存
      }
    }

    let tmp = arr[i]
    arr[i] = arr[minIndex]
    arr[minIndex] = tmp
  }
  return arr
}
const nums = [5, 7, 0, 1, 2, 3, 9, 8, 6]

const res = selectorSort(nums)
```

### 实现要点

1. 两次循环，外层控制趟数，内层控制排序次数
2. 一开始假定待排序的数据中第一项为最小值(**选择即选择了这个最小值**)，内层判断当前项和“最小值”的关系，当前值小于“最小值”时，更新“最小值”，每轮结束后将当前值和“最小值”交换。
3. 内层循环，因为一开始认为第一项i=0是最小值，内层从i+1开始，它需要找的次数是len-1次，因此限定条件为 j<len = len-1 - (i+1)


## 插入排序
描述：插入排序的思路就是从右侧的未排序区域内取出一个数据，然后将它插入到已排序区域内合适的位置上。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676388099179-aa91a063-e6c3-437a-935c-9233e0a10795.png#averageHue=%23eba957&clientId=u6ceff566-5185-4&from=paste&height=218&id=udd50fcd0&name=image.png&originHeight=586&originWidth=1610&originalType=binary&ratio=2&rotation=0&showTitle=false&size=144100&status=done&style=none&taskId=u16e6363b-55be-492b-9eaf-f8cc69ee4ad&title=&width=600)
此时，假设最左边的数字5已经完成排序，所以此时只有5是已归位的数字。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676388139828-03503d06-ebe6-48bf-941e-4f8b346c9a7d.png#averageHue=%23fdf7f0&clientId=u6ceff566-5185-4&from=paste&height=233&id=uba9f3df2&name=image.png&originHeight=586&originWidth=1506&originalType=binary&ratio=2&rotation=0&showTitle=false&size=103436&status=done&style=none&taskId=uf0810b7c-28fd-4f58-8c4a-3d269f0ee60&title=&width=600)
接下来，从待排数字（未排序区域）中取出最左边的数字3，将它与左边已归位的数字进行比较。若左边的数字更大，就交换这两个数字。重复该操作，直到左边已归位的数字比取出的数字更小，或者取出的数字已经被移到整个序列的最左边为止。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676388174284-30ab101a-1e25-4072-abd7-6d99790e3bf2.png#averageHue=%23eba754&clientId=u6ceff566-5185-4&from=paste&height=239&id=ucc0d1c2a&name=image.png&originHeight=630&originWidth=1582&originalType=binary&ratio=2&rotation=0&showTitle=false&size=158792&status=done&style=none&taskId=u3e2ed4f7-6402-414d-9860-37529a527c3&title=&width=600)
就是第k轮需要比较k-1次。因此，在最糟糕的情况下，第2轮需要操作1次，第3轮操作2次……第n轮操作n-1次，所以时间复杂度和冒泡排序的一样，都为O（n2）。

### 代码实现
```javascript
function insertSort(arr) {
  // 从1位置开始遍历arr中每元素，同时声明空变量temp
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] < arr[i - 1]) { // 如果当前元素<前一个元素
      let temp = arr[i] // 将当前元素值临时保存在temp中
      let p = i - 1 // 定义变量 p = i- 1  在第一层 p是递增的，因此越往后while执行次数越多
      // 循环 条件：
      // 1. p>=0且temp小于p位置的元素
      while (p >= 0 && temp < arr[p]) {
        // 循环体： 将P位置的值赋值给p的后一个元素
        arr[p + 1] = arr[p] 
        p-- // p向前移动一个
      }
      // 直到while循环不满足条件才会执行
      arr[p + 1] = temp // 将temp的值赋值给p+1位置的元素
    }
  }
}
```

### 实现要点

1. 两层循环，外层控制趟数，内层控制排序次数，内层while次数逐渐递增，因为越往后需要比较的次数越多
2. 思路是从0，1开始比大小，1->0，2->1->0  指下标
## 堆排序
描述：从降序排列的堆中取出数据时会从最大的数据开始取，所以将取出的数据反序输出，排序就完成了。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676388598871-52e1431b-1ebe-46a9-a37c-302f04a60884.png#averageHue=%23fdfbf6&clientId=u6ceff566-5185-4&from=paste&height=331&id=uef994a2f&name=image.png&originHeight=794&originWidth=1440&originalType=binary&ratio=2&rotation=0&showTitle=false&size=161101&status=done&style=none&taskId=u99e3c96e-aa9f-4793-a3aa-ca0a1e4bed2&title=&width=600)

堆排序一开始需要将n个数据存进堆里，所需时间为O（nlogn）。排序过程中，堆从空堆的状态开始，逐渐被数据填满。由于堆的高度小于log2n，所以插入1个数据所需要的时间为O（logn）。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676388665102-d7932ffb-2d3f-4064-a389-c90958ee4351.png#averageHue=%23f3ebe3&clientId=u6ceff566-5185-4&from=paste&height=343&id=uaf3b87d2&name=image.png&originHeight=898&originWidth=1572&originalType=binary&ratio=2&rotation=0&showTitle=false&size=314879&status=done&style=none&taskId=u1d2ff52f-aa0c-4691-beed-bc1e2c8e880&title=&width=600)

### 代码实现
[数据结构:二叉堆](https://www.yuque.com/vannvan/tools/vmsg2vy8qyv3w266?inner=U4H0o&view=doc_embed)
## 归并排序
描述：归并排序算法会把序列分成长度相同的两个子序列(分治)，当无法继续往下分时（也就是每个子序列中只有一个数据时），就对子序列进行归并
归并指的是把两个排好序的子序列合并成一个有序序列。该操作会一直重复执行，直到所有子序列都归并为一个整体为止。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676943808233-cf0ce40e-7bf8-4361-ae57-9db61c84d4e1.png#averageHue=%23e1e1e1&clientId=u15f4e1c2-4935-4&from=paste&height=528&id=uf0845877&name=image.png&originHeight=1056&originWidth=870&originalType=binary&ratio=2&rotation=0&showTitle=false&size=339738&status=done&style=none&taskId=ue717d6d7-81e0-4f16-8b5b-f0d1ab72ad6&title=&width=435)
### 代码实现
```javascript
// O(nlog(n))
const merge = (left: number[], right: number[]) => {
  let result: any[] = []

  while (left.length && right.length) {
    if (left[0] < right[0]) {
      result.push(left.shift())
    } else {
      result.push(right.shift())
    }
  }

  // 奇数个数字，左边或右边还剩一项元素的情况
  while (left.length) {
    result.push(left.shift())
  }
  while (right.length) {
    result.push(right.shift())
  }
  return result  
}

const mergeSort = (nums: number[]) => {
  let { length } = nums

  if (length < 2) return nums
  let mid = Math.floor(length / 2)
  // 把数组拆成两半
  let left = nums.slice(0, mid)
  let right = nums.slice(mid)
  return merge(mergeSort(left), mergeSort(right))
}
```
### 实现要点

1. 需要两个函数，一个用来依次根据左右两侧数据大小将值合并为一个新数组，另一个通过递归不断拆分左右两侧
## 快速排序
描述：快速排序算法首先会在序列中随机选择一个基准值（pivot），然后将除了基准值以外的数分为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。
**[比基准值小的数] 基准值 [比基准值大的数]**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676388948382-b413cd7d-d954-4e5d-bc74-ac5917d9014e.png#averageHue=%23fdf7f0&clientId=u6ceff566-5185-4&from=paste&height=541&id=ubc61ceef&name=image.png&originHeight=1510&originWidth=1674&originalType=binary&ratio=2&rotation=0&showTitle=false&size=400348&status=done&style=none&taskId=u1a88f067-a083-4cd6-a589-79d03979045&title=&width=600)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676388965891-11529e3d-8527-4582-9921-571bdd2d7a5f.png#averageHue=%23fdf9f4&clientId=u6ceff566-5185-4&from=paste&height=389&id=ua5e8f115&name=image.png&originHeight=996&originWidth=1536&originalType=binary&ratio=2&rotation=0&showTitle=false&size=220483&status=done&style=none&taskId=u492f709b-dae7-41a4-9db9-5969625b9a7&title=&width=600)
快速排序是一种“分治法”。它将原本的问题分成两个子问题（比基准值小的数和比基准值大的数），然后再分别解决这两个问题。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676459695832-86e3dc63-e7f3-4234-a1da-b1d16d6333e5.png#averageHue=%232a1d0f&clientId=uc731cf3c-aa9d-4&from=paste&height=378&id=u526ae90f&name=image.png&originHeight=755&originWidth=959&originalType=binary&ratio=2&rotation=0&showTitle=false&size=153398&status=done&style=none&taskId=uab04436b-1a12-4da8-a48e-fad9ab2441b&title=&width=479.5)
### 代码实现
```javascript
/**
 *
 * @param {number[]} arr
 */
const quickSort = (arr) => {
  const len = arr.length
  if (len < 2) return arr

  const pointIndex = Math.floor(len / 2)

  let left = []
  let right = []

  for (let i = 0; i < len; i++) {
    if (i != pointIndex) {
      if (arr[i] <= arr[pointIndex]) {
        left.push(arr[i])
      } else {
        right.push(arr[i])
      }
    }
  }

  // console.log('left', left, 'right', right)
  return quickSort(left).concat(arr[pointIndex], quickSort(right))
}

const nums = [5, 7, 0, 1, 2, 3, 9, 8, 6]

const res = quickSort(nums)

console.log('res', res)

```
### 实现要点

1. 递归边界是arr.length<=1或arr.length<2，就不需要排了
2. 递归的逻辑在于每次都要“分别”将左边和右边的元素进行移位，直到达到边界就算排完了

记忆三步：
（1）在数据集之中，选择一个元素作为"基准"（pivot）。
（2）所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。
（3）对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。

思路记忆

1. 从结果出发，既然我们实现的过程是找一个基准点，同时判断这个基准点左侧和右侧的大小，然后把它们分成两堆(同时包含基准值自己)，因此从结果出发，有下面这一行
```javascript
return quickSort(left).concat(arr[pointIndex], quickSort(right))
```

2. 拿到基准点，我们需要“创造”left和right两个新数组，用于存放基准值左右两侧的数据，因此，有下面这一堆
```javascript

  const pointIndex = Math.floor(len / 2)

  let left = []
  let right = []

  for (let i = 0; i < len; i++) {
    if (i != pointIndex) {
      if (arr[i] <= arr[pointIndex]) {
        left.push(arr[i])
      } else {
        right.push(arr[i])
      }
    }
  }
```

3. 因为我们的思路是通过递归无限把源数组进行拆分，分成 左-基-右这样的序列，因此当拆到数组小于两个元素的时候，就没有必要拆了，就刚好是递归的边界
```javascript
if (len < 2) return arr
```
## 计数排序
所谓“计数”，就是通过额外的一个存储来记录元素出现的次数，在所有元素都计算完出现的次数后，通过本就天然排好次序的数组迭代构建源数组的指定位置的元素，实现排序，**意味着这个过程将不会出现“比较”过程。**
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676973600087-2a6abccd-d3a3-4496-a017-97fc387b0150.png#averageHue=%23dbe5c7&clientId=ucf15b268-db65-4&from=paste&height=203&id=GSpeM&name=image.png&originHeight=552&originWidth=1628&originalType=binary&ratio=2&rotation=0&showTitle=false&size=105973&status=done&style=none&taskId=u215ad72a-5729-4ca2-ae90-491e9b05115&title=&width=600)
### 代码实现
```javascript
const findMaxValue = (nums: number[]) => {
  let max = nums[0]
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] > max) {
      max = nums[i]
    }
  }
  return max
}

const countingSort = (nums: number[]) => {
  if (nums.length < 2) return nums
  const maxValue = findMaxValue(nums) 
  const counts = new Array(maxValue + 1)
  nums.forEach((num) => {
    if (!counts[num]) {
      counts[num] = 0
    }
    counts[num]++
  })

  let sortIndex = 0 // 从第一项开始
  counts.forEach((count, i) => {
    // 这个数可能出现了多次
    while (count > 0) {
      nums[sortIndex++] = i // i值就是sortIndex这个位置的原始值
      count-- // 上面每赋值一次就少一次
    }
  })
  return nums
}
```
### 实现要点
假如要排序[1,3,7]这组数据，先要造一组[0,1,2,3,4,5,6,7,8]的数，用生成8项初始化数据为0的数组**计数数组**(用来记录原始数组中0-8的数字出现的次数)，然后遍历这个计数数组，这个**计数数组**的**索引值**就包含了原始数组中所有的元素对不对，从头开始根据计数数组中原始数据出现的次数依次将原始数组中的值进行替换，替换的结果就是排序之后的结果。
### 特别说明
虽然计数排序看上去很强大，但是它存在两大局限性：
1.当数列最大最小值差距过大时，并不适用于计数排序
比如给定 20 个随机整数，范围在 0 到 1 亿之间，此时如果使用计数排序的话，就需要创建长度为 1 亿的数组，不但严重浪费了空间，而且时间复杂度也随之升高。
2.当数列元素不是整数时，并不适用于计数排序
如果数列中的元素都是小数，比如 3.1415，或是 0.00000001 这样子，则无法创建对应的统计数组，这样显然无法进行计数排序。

## 桶排序
桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行排序。然后，它将所有的桶合并为结果数组。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676983860898-2dc8e172-e490-40a5-a238-dde689fbf2b8.png#averageHue=%23efeeed&clientId=u925b7fa4-fca1-4&from=paste&height=324&id=f2Kmv&name=image.png&originHeight=922&originWidth=1706&originalType=binary&ratio=2&rotation=0&showTitle=false&size=368993&status=done&style=none&taskId=udb936eb9-eb2f-42f3-a705-ae1ce9cf07d&title=&width=600)
### 代码实现
```javascript

const bucketSort = (nums: number[], bucketSize = 5) => {
  if (nums.length < 2) return nums
  let buckets = createBucket(nums, bucketSize)
  return sortBucket(buckets)
}

const createBucket = (nums: number[], bucketSize: number) => {
  const maxValue = Math.max(...nums)
  const minVallue = Math.min(...nums)

  const bucketCount = Math.ceil((maxValue - minVallue) / bucketSize) // 每个桶中的数量
  let buckets: number[][] = []
  for (let i = 0; i < bucketCount; i++) {
    buckets[i] = [] // 将每个桶初始化
  }

  for (let i = 0; i < nums.length; i++) {
    const bucketIndex = Math.floor((nums[i] - minVallue) / bucketSize) // 看需要把元素放在哪个桶中
    buckets[bucketIndex] = buckets[bucketIndex]
      ? buckets[bucketIndex].concat(nums[i])
      : [].concat(nums[i])
  }

  return buckets
}

const sortBucket = (buckets: number[][]) => {
  let res = []
  for (let i = 0; i < buckets.length; i++) {
    res = res.concat(mergeSort(buckets[i]))  // 注意这里用其他排序算法
  }
  return res
}
```
### 实现要点

1. 通过最大最小值计算出差值，从而知道每个桶里放多少个元素，根据(元素-最小值)/桶数量将所有元素“均匀”分布在各个桶里，再使用其他排序算法将每个桶排序，最后将桶合并

## 基数排序
基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排序）将整数分布到桶中。
比如，对于十进制数，使用的基数是10。因此，算法将会使用10个桶用来分布元素并且首先基于个位数字进行排序，然后基于十位数字，然后基于百位数字，以此类推。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676989256904-74d315ad-8817-4aa8-9a6e-773485292e67.png#averageHue=%23e5e5e5&clientId=uc7b510de-bf1f-4&from=paste&height=395&id=U2t8L&name=image.png&originHeight=790&originWidth=908&originalType=binary&ratio=2&rotation=0&showTitle=false&size=228661&status=done&style=none&taskId=u217b260e-9c51-43a4-b1b7-8d7612151dc&title=&width=454)
### 代码实现
```javascript

/**
 * eg [1,71,231,681,658,892]
 * @param nums
 * @returns
 */
const radixSort = (nums: number[]) => {
  // 定义一个二维数组，表示10个桶，每个桶就是一个一维数组
  let buckets = new Array(10)
  for (let i = 0; i < buckets.length; i++) {
    buckets[i] = new Array(nums.length)
  }
  // 为了记录每个桶中，实际存了多少个数据，我们定义一个维数组来记录每个桶的每次放入的数据个数
  const buckeElementCounts = new Array(10).fill(0) // 0-9

  // 得到数组中最大的数
  let max = nums[0]
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] > max) {
      max = nums[i]
    }
  }
  // 以最大数的基数为限
  const maxLen = (max + '').length

  // 因为基于基数排序的，每一轮增加一个基数，所以基数在最外层
  for (let i = 0, n = 1; i < maxLen; i++, n = n * 10) {
    // 第一轮，对每个元素的个位数进行排序,依次以十位、百位、千位...进行排序
    for (let j = 0; j < nums.length; j++) {
      // 取出个位数的值
      let digitOfElement = Math.floor(nums[j] / n) % 10 // 0-9
      buckets[digitOfElement][buckeElementCounts[digitOfElement]] = nums[j]
      buckeElementCounts[digitOfElement]++ //记录每个数字出现的次数， 这里处理完是可能有空桶的
    }

    // 第一轮  [1, 101, 672, 302, 782, 444, 989]
    // 第二轮  [1, 101, 302, 444, 672, 782, 989]
    // 第三轮  [1, 101, 302, 444, 672, 782, 989]

    // console.log('buckeElementCounts', buckeElementCounts)

    // 按照这个桶的顺序，依次对每个桶进行处理,10个桶，一个一个往后找
    let index = 0
    for (let k = 0; k < buckeElementCounts.length; k++) {
      //如果桶中有数据，我们才放入原数组
      if (buckeElementCounts[k] !== 0) {
        //循环该桶即第k个桶，即第k个一维数组，放入，l就是0-9嘛
        for (let l = 0; l < buckeElementCounts[k]; l++) {
          //取出元素放入arr
          nums[index] = buckets[k][l]
          //arr下标后移
          index++
        }
        //每轮处理后，下标要清0
        buckeElementCounts[k] = 0
      }
    }
    // console.log('nums', nums)
  }
  return nums
}

```
### 实现要点

1. 找出所有数据中最大的数，基数以个位为基准，最外层每轮循环基数*10
2. 生成10个长度为源数组长度的空桶(二维数组)
3. 每一轮以基数为基准的排序中，记录当前基数数字(0-9)出现的次数
4. 遍历每个桶，一个桶一个桶的处理，用当前基数存在有数字的替换源数组对应位置的数字

## 希尔排序
希尔排序(Shell's Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676990301269-65c88c5e-6dd7-4e3b-88b7-2b4b97a95267.png#averageHue=%23e7e9e1&clientId=uc7b510de-bf1f-4&from=paste&height=607&id=ub598692c&name=image.png&originHeight=1412&originWidth=1396&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1020056&status=done&style=none&taskId=ud12636d7-6117-498a-8ed9-34adf6e23f9&title=&width=600)
### 代码实现
```javascript
const shellSort = (nums: number[]) => {
  const { length } = nums
  let gap = Math.floor(nums.length / 2)
  while (gap >= 1) {
     // 结合上图for循环的 第一轮比较8，3 ；9，5；1，4 ...
    for (let i = 0; i < length; i++) {
      for (let j = i; j >= gap; j = j - gap) {
        // 若待插入值较小，则换位
        if (nums[j] < nums[j - gap]) {
          ;[nums[j], nums[j - gap]] = [nums[j - gap], nums[j]]
        }
      }
    }
    gap = Math.floor(gap / 2)
  }

  return nums
}
```
### 实现要点
步长初始化为数组长度的一半(取整)，结束排序的条件是步长小于0，外层控制趟数，内层一定是趟数越多比较次数越多，每结束一整轮换位下一次步长减半。
## 资料
有动图

## 常见排序方法复杂度
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676460695449-20259604-632d-44df-87b7-b1a936896100.png#averageHue=%23e5dfd8&clientId=uc731cf3c-aa9d-4&from=paste&height=294&id=u04f9f85b&name=image.png&originHeight=588&originWidth=966&originalType=binary&ratio=2&rotation=0&showTitle=false&size=105656&status=done&style=none&taskId=ue11d7df0-2a18-47d0-a086-ff09f9fdf84&title=&width=483)
## 交换数据
```javascript
// 比较保守的方法
function swap(a,b,arr){
    let temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}

// es6的方法，性能不如上面好
function swap(a,b,arr) {
  [arr[a], arr[b]] = [arr[b], arr[a]]
}
```

## 小知识
Mozilla Firefox使用归并排序作为Array.prototype.sort的实现，而Chrome（V8引擎）使用了一个快速排序的变体。
