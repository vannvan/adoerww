# 数据结构:图 
概念：
图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。

由一条边连接在一起的顶点称为**相邻顶点**，如AB、AD是相邻的。**路径**是顶点V1，V2，Vk的一个连续序列，其中Vi和Vi+1是相邻的。上图其中包含路径ABEI和ACDG。↓↓
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676722107499-bb7bac4c-78db-44dd-9ccb-d498d4fd670d.png#averageHue=%23f7f7f7&clientId=ub54c826f-c7a8-4&from=paste&height=212&id=u0b1e5de7&name=image.png&originHeight=424&originWidth=726&originalType=binary&ratio=2&rotation=0&showTitle=false&size=71204&status=done&style=none&taskId=ude1fcc9e-a6bd-47ff-83f1-7d4a81cb869&title=&width=363)
如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C和D是强连通的，而A和B不是强连通的。↓↓![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676722357505-4b27d0c6-4d23-4e3d-9199-08fd7ea4157e.png#averageHue=%23f2f2f2&clientId=ub54c826f-c7a8-4&from=paste&height=193&id=uf863f3a2&name=image.png&originHeight=386&originWidth=610&originalType=binary&ratio=2&rotation=0&showTitle=false&size=75420&status=done&style=none&taskId=u38a0e974-07d8-4ca9-8f43-1ba866eb228&title=&width=305)
图还可以是未加权的，或是加权的。↓↓
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676722400806-2bab5feb-e524-40c5-9e0f-4dedc7ffc17e.png#averageHue=%23f3f3f3&clientId=ub54c826f-c7a8-4&from=paste&height=210&id=uc2f5e264&name=image.png&originHeight=420&originWidth=632&originalType=binary&ratio=2&rotation=0&showTitle=false&size=82684&status=done&style=none&taskId=uc46177f5-1347-487e-8618-7f02d5a48b9&title=&width=316)
## 图的表示
### 邻接矩阵
图最常见的实现是邻接矩阵。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676722498364-9a1b4f4b-3d14-453c-9226-f1ce202cb107.png#averageHue=%23f1f1f1&clientId=ub54c826f-c7a8-4&from=paste&height=218&id=ud76d9a07&name=image.png&originHeight=436&originWidth=986&originalType=binary&ratio=2&rotation=0&showTitle=false&size=146634&status=done&style=none&taskId=u3b32773f-8a61-4e16-90b4-ee955dd3307&title=&width=493)
不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。
### 邻接表
邻接表由图中每个顶点的相邻顶点列表所组成。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676722591916-689315df-fcc9-4f0f-aee2-63ca1690ac44.png#averageHue=%23f0f0f0&clientId=ub54c826f-c7a8-4&from=paste&height=238&id=u482cf377&name=image.png&originHeight=476&originWidth=914&originalType=binary&ratio=2&rotation=0&showTitle=false&size=133853&status=done&style=none&taskId=ua03c17b1-6edd-4cd7-8462-c4f9e7c16b0&title=&width=457)
### 关联矩阵
在关联矩阵中，矩阵的行表示顶点，列表示边。如下图所示，使用二维数组来表示两者之间的连通性，如果顶点v是边e的入射点，则array[v][e] === 1；否则，array[v][e]=== 0。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676722643505-43fb3446-e5ea-4827-88e0-d945a5d45d9b.png#averageHue=%23f1f1f1&clientId=ub54c826f-c7a8-4&from=paste&height=215&id=ub76e66df&name=image.png&originHeight=430&originWidth=926&originalType=binary&ratio=2&rotation=0&showTitle=false&size=142765&status=done&style=none&taskId=u70856a11-ff4a-4b14-b960-e38765ebfd0&title=&width=463)
关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存。
## 代码实现
```javascript
class Graph {
  constructor(isDirected = false) {
    this.isDirected = isDirected
    this.vertices = []  // 顶点
    this.adjList = new Dictionary()  // 表示顶点关系的
  }

  /**
   * 添加顶点
   * @param {*} v 顶点
   */
  addVertex(v) {
    if (!this.vertices.includes(v)) {
      this.vertices.push(v)
      this.adjList.set(v, [])
    }
  }
  /**
   * 添加边
   * @param {*} v 顶点
   * @param {*} w 指向点
   */
  addEdge(v, w) {
    if (!this.adjList.get(v)) {
      this.addVertex(v)
    }
    if (!this.adjList.get(w)) {
      this.addVertex(w)
    }

    this.adjList.get(v).push(w) // 
    if (!this.isDirected) {
      // 如果是无向图
      this.adjList.get(w).push(v)
    }
  }

  getVertices() {
    return this.vertices
  }

  getAdjList() {
    return this.adjList
  }

  /**
	* 用于输出图指向关系
	*/
  toString() {
    let s = ''
    for (let i = 0; i < this.getVertices().length; i++) {
      s += `${this.vertices[i]}->`
      const neighbors = this.adjList.get(this.vertices[i])
      for (let j = 0; j < neighbors.length; j++) {
        s += `${neighbors[j]} `
      }
      s += `\n`
    }
    return s
  }
}

const gh = new Graph()  

function Random(min, max) {
  return Math.round(Math.random() * (max - min)) + min
}

const strArray = Array.from({ length: 10 }, (v, k) =>
  String.fromCharCode(97 + k).toUpperCase()
)

strArray.forEach((str) => {
  gh.addVertex(str)
})

Array.from({ length: 10 }, (v, k) => {
  let a = strArray[Random(0, 9)]
  let b = strArray[Random(0, 9)]
  if (a != b) {
    gh.addEdge(a, b)
  }
})

// console.dir(gh)
console.log(gh.toString())

```

## 图的遍历
| 算法 | 数据结构 | 描述 |
| --- | --- | --- |
| 深度优先DFS | 栈 | 将顶点存入栈，顶点是沿着路径被探索的，存在新的顶点就去访问 |
| 广度优先BFS | 队列 | 将顶点存入队列，最先被存入队列的最先被访问 |

### BFS
用三种颜色标记它是否被访问或被探索过，同时在遍历前生成一个初始化标记
```javascript

const Colors = {
  WHITE: 0, // 未访问
  GRAY: 1, // 访问但未探索
  BLACK: 2, // 已访问且已探索
}

// 给图初始化标记颜色
const initColor = (vertices) => {
  const color = {}
  for (let i = 0; i < vertices.length; i++) {
    color[vertices[i]] = Colors.WHITE
  }
  return color
}

```
#### 搜索算法-遍历
```javascript
const BreadthFirstSearch = (graph, startVertex, callback) => {
  const vertices = graph.getVertices()
  const adjList = graph.getAdjList()
  const color = initColor(vertices)
  const queue = new Queue()

  queue.enQueue(startVertex)
  while (!queue.isEmpty()) {
    const u = queue.deQueue() // 要开始访问了，先出队
    const neighbors = adjList.get(u)
    // console.log('neighbors', neighbors)
    color[u] = Colors.GRAY // 标记被访问了一次
    // 依次去把它的邻居访问一下
    for (let i = 0; i < neighbors.length; i++) {
      const w = neighbors[i]
      if (color[w] === Colors.WHITE) {
        color[w] = Colors.GRAY
        queue.enQueue(w) // 入队
      }
    }
    color[u] = Colors.BLACK //  标记已被探索
    if (callback) {
      callback(u)
    }
  }
}

BreadthFirstSearch(graph, 'A', (v) => {
  console.log('已访问:', v)
})
```
#### 搜索算法-最短路径
```javascript
/**
 * 最短路径
 * @param {*} graph
 * @param {*} startVertex
 */
const BFS = (graph, startVertex) => {
  const vertices = graph.getVertices()
  const adjList = graph.getAdjList()
  const color = initColor(vertices)
  const predecessors = {} // 前溯节点
  const distances = {} // 距离
  const queue = new Queue()
  queue.enQueue(startVertex)

  // 初始化每个元素的距离和前溯姐弟安
  for (let i = 0; i < vertices.length; i++) {
    distances[vertices[i]] = 0
    predecessors[vertices[i]] = null
  }
  // u 是起始节点，w是遍历其邻居的下一个，下下一个...
  while (!queue.isEmpty()) {
    const u = queue.deQueue() // 要开始访问了，先出队
    const neighbors = adjList.get(u)
    color[u] = Colors.GRAY // 标记被访问了一次
    // 依次去把它的邻居访问一下
    for (let i = 0; i < neighbors.length; i++) {
      const w = neighbors[i]
      if (color[w] === Colors.WHITE) {
        color[w] = Colors.GRAY
        distances[w] = distances[u] + 1 // 后一项是前一项+1
        predecessors[w] = u // 前溯节点
        queue.enQueue(w) // 入队
      }
    }
    color[u] = Colors.BLACK //  标记已被探索
  }
  return {
    distances,  
    predecessors,
  }
}

const { distances, predecessors } = BFS(graph, 'A')  // 从A开始

const fromVertex = 'A' // 起始点
const vertices = graph.getVertices()

for (let i = 1; i < vertices.length; i++) {
  // 要到达的节点
  const toVertex = vertices[i]
  const path = new Stack()
  for (let v = toVertex; v !== fromVertex; v = predecessors[v]) {
    path.push(v)
    // 说明中断了，不可到达
    if (!v) {
      path.clear()
      break
    }
  }
  // 存在有效路径
  if (path.size() > 0) {
    path.push(fromVertex)
    let s = !path.isEmpty() ? path.pop() : ''
    while (!path.isEmpty()) {
      s += ' - ' + path.pop()
    }
    console.log(s)
  }
}
// A - B
// A - C
// A - D
// A - B - E
// A - B - F
// A - C - G
// A - D - H
// A - B - E - I

```
### DFS
深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点，如下图所示。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676732179444-964b7b8a-c354-4feb-bb23-ed2124a96693.png#averageHue=%23f5f5f5&clientId=uc87170c7-97b2-4&from=paste&height=206&id=uf18b7b4c&name=image.png&originHeight=412&originWidth=730&originalType=binary&ratio=2&rotation=0&showTitle=false&size=82082&status=done&style=none&taskId=uf0fd25ce-de25-4c23-a5f9-92d52e7b17f&title=&width=365)
深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点v未访问，则访问该顶点v。
要访问顶点v，需要三个步骤

1. 标注v为被发现的(灰色)
2. 对于v的所有未访问(白色)的邻点w，访问w
3. 标注v已被探索(黑色)
#### 搜索算法-遍历
```javascript
const depthFirstSearch = (graph, callback) => {
  const vertices = graph.getVertices()
  const adjList = graph.getAdjList()
  const color = initColor(vertices)

  const depthFirstSearchVisit = (u, color, adjList, callback) => {
    if (!u) return
    // 既然将要开始访问了，标记为已探索
    color[u] = Colors.GRAY
    if (callback) {
      callback(u)
    }

    const neighbors = adjList.get(u) 
    for (let i = 0; i < neighbors.length; i++) {
      const w = neighbors[i]
      if (color[w] === Colors.WHITE) {
        // 对没访问的继续探索
        depthFirstSearchVisit(w, color, adjList, callback)
      }
    }
    // 已访问，打标记
    color[u] = Colors.BLACK
  }

  for (let i = 0; i < vertices.length; i++) {
    if (color[vertices[i]] === Colors.WHITE) {
      depthFirstSearchVisit(vertices[i], color, adjList, callback)
    }
  }
}

depthFirstSearch(graph, (v) => {
  console.log('visited', v)
})
```

#### 拓扑排序  // TODO

### Dijkstra算法(贪心算法)
Dijkstra(迪杰斯特拉)算法是一种计算从**单个源到所有其他源**的最短路径的贪心算法。每次在剩余节点中找到离起点最近的节点放到队列中，并用来更新剩下的节点的距离，再将它标记上表示已经找到到它的最短路径，以后不用更新它了。
#### 代码实现
![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676790924551-e6afc53d-6b0e-40b6-82b6-9cd5435da690.png#averageHue=%23f7f7f7&clientId=u7054bbe9-28f6-4&from=paste&height=147&id=ued9e676f&name=image.png&originHeight=294&originWidth=796&originalType=binary&ratio=2&rotation=0&showTitle=false&size=54497&status=done&style=none&taskId=u47cbc834-0145-49eb-aa4a-2bbad393292&title=&width=398)
```javascript
const graph = [
  [0, 2, 4, 0, 0, 0],
  [0, 0, 1, 4, 2, 0],
  [0, 0, 0, 0, 3, 0],
  [0, 0, 0, 0, 0, 2],
  [0, 0, 0, 3, 0, 2],
  [0, 0, 0, 0, 0, 0],
]

const INF = Number.MAX_SAFE_INTEGER

const minDistance = (dist, visited) => {
  let min = INF
  let minIndex = -1
  for (let v = 0; v < dist.length; v++) {
    if (visited[v] === false && dist[v] < min) {
      min = dist[v]
      minIndex = v
    }
  }
  return minIndex
}

const dijkstra = (graph, src) => {
  const dist = []
  const visited = []
  const graphLen = graph.length
  for (let i = 0; i < graphLen; i++) {
    dist[i] = INF  // 把所有距离初始化为最大
    visited[i] = false
  }
  // 源点到自己的距离初始化为0
  dist[src] = 0
  // 从0,0点挨个去搜索
  for (let i = 0; i < graphLen - 1; i++) {
    const u = minDistance(dist, visited)
    // 更新访问标记
    visited[u] = true
    // console.log('u', u)
    for (let v = 0; v < graphLen; v++) {
      // 如果没有访问 且 存在更小的距离
      if (
        !visited[v] && //   未访问过
        dist[u] != INF && // 不是上限
        graph[u][v] != 0 && // 0没意义
        dist[u] + graph[u][v] < dist[v] // 有更小的
      ) {
        dist[v] = dist[u] + graph[u][v]
      }
    }
  }

  return dist
}

const s = dijkstra(graph, 0)
console.log('最短路径', s)

```

### Floyd-Warshall算法(动态规划)
Floyd-Warshall算法是一种计算图中**所有最短路径的动态规划算法**
```javascript
// 核心代码思想
for(k=1;k<=n;k++)
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++)
            if(e[i][j]>e[i][k]+e[k][j])
                 e[i][j]=e[i][k]+e[k][j];
```
这段代码的核心思想是：最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。一旦发现比之前矩阵内存储的距离短，就用它覆盖原来保存的距离。
**用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程。**
> 另外需要注意的是：Floyd-Warshall算法不能解决带有“负权回路”（或者叫“负权环”）的图，因为带有“负权回路”的图没有最短路。例如下面这个图就不存在1号顶点到3号顶点的最短路径。因为1->2->3->1->2->3->…->1->2->3这样路径中，每绕一次1->-2>3这样的环，最短路就会减少1，永远找不到最短路。其实如果一个图中带有“负权回路”那么这个图则没有最短路。

#### 代码实现
```javascript
const floydWarshall = (graph) => {
  const dist = []
  const { length } = graph
  // 初始化邻接矩阵
  for (let i = 0; i < length; i++) {
    dist[i] = []
    for (let j = 0; j < length; j++) {
      if (i === j) {
        dist[i][j] = 0
      } else if (graph[i][j] == 0) {
        dist[i][j] = Infinity
      } else {
        dist[i][j] = graph[i][j]
      }
    }
  }

  // i 是起点 j是终点 k是中转点，因为思路是一行一行往下走，因此k需要根据行数游走变更
  // 因为一开始初始化的dist[i][j]就认为其是最短路径
  // 因此if条件比较的是 从起点到这个假设的中转点+假设的中转点到终点 和 已存储的最短路径的大小
  // 下标对应 (i->k)+(k->j) 和 (i->j),如果前者更小那就更新
  for (let k = 0; k < length; k++) {
    for (let i = 0; i < length; i++) {
      for (let j = 0; j < length; j++) {
        if (dist[i][k] + dist[k][j] < dist[i][j]) {
          console.log(
            'update->',
            '下标i->k',
            `${i}-${k}-路径距离${dist[i][k]}`,
            'k->j',
            `${k}-${j}-路径距离${dist[k][j]}`,
            'i->j',
            `${i}-${j}-路径距离${dist[i][j]}`
          )
          dist[i][j] = dist[i][k] + dist[k][j]
        }
      }
    }
  }
  return dist
}

const s = floydWarshall(graph)
console.log('result', s)

```
### 最小生成树MST
所谓生成树，指的是具备以下条件的连通图：

- 包含图中所有的顶点；
- 任意顶点之间有且仅有一条通路。

以下加粗路径就是最小生成树的解决方案
#### ![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1676809434454-f68273a0-190a-4e9e-9b7d-ca2d7d67296d.png#averageHue=%23f1f1f1&clientId=udd5e5ff0-ff87-4&from=paste&height=205&id=uc061bcfd&name=image.png&originHeight=410&originWidth=1174&originalType=binary&ratio=2&rotation=0&showTitle=false&size=115505&status=done&style=none&taskId=u7ea14adc-0b81-4718-be3e-c10d1313e12&title=&width=587)
#### 
Prim算法(普雷姆)
Prim算法是一种求解加权无向连通图的MST问题的**贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。**
```javascript
const INF = Number.MAX_SAFE_INTEGER

const graph = [
  [0, 2, 4, 0, 0, 0],
  [2, 0, 2, 4, 2, 0],
  [4, 2, 0, 0, 3, 0],
  [0, 4, 0, 0, 3, 2],
  [0, 2, 3, 3, 0, 2],
  [0, 0, 0, 2, 2, 0],
]

const minDistance = (graph, key, visited) => {
  let min = INF
  let minIndex = 0
  for (let v = 0; v < graph.length; v++) {
    if (visited[v] === false && key[v] < min) {
      min = key[v]
      minIndex = v
    }
  }
  return minIndex
}

const prim = (graph) => {
  const parent = []
  const key = []
  const visited = []
  const { length } = graph
  for (let i = 0; i < length; i++) {
    key[i] = INF
    visited[i] = false
  }
  key[0] = 0
  parent[0] = -1 // 因为第一个顶点总是MST的根节点，所以parent[0] = -1。
  // 对于  n个顶点的图，最需选择 n-1 条路径，即可构成最小生成树
  for (let i = 0; i < length - 1; i++) {
    const u = minDistance(graph, key, visited) //从未处理的顶点集合中选出key值最小的顶点
    visited[u] = true
    for (let v = 0; v < length; v++) {
      // graph[u][v] 表示图的一条路径
      if (graph[u][v] && !visited[v] && graph[u][v] < key[v]) {
        // 更新 parent 数组记录的各个顶点父节点的信息
        parent[v] = u
        // 更新 key 数组
        key[v] = graph[u][v]
      }
    }
  }

  return parent
}

const parent = prim(graph)
console.log('parent', parent)

// parent 数组下标值表示各个顶点，各个下标对应的值为该顶点的父节点,因此从1开始
console.log('Edge   Weight')
for (let i = 1; i < graph.length; i++) {
  console.log(parent[i] + ' - ' + i + '   ' + graph[i][parent[i]])
}

```
#### Kruskal算法 // TODO






## 资料


floyed算法讲解
[点击查看【bilibili】](https://player.bilibili.com/player.html?bvid=BV1q4411M7r9)

附带算法专题值得一看
floyed算法详解
prim 算法详解
kruskal算法详解
