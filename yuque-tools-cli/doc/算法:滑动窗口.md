# 算法:滑动窗口 
## 特征
满足XXX条件(计算结果、出现次数、同时包含等)
**最长/最短**
**字串/子数组/子序列**
例如：长度最小的子数组
滑动窗使用思路（寻找最长）
核心：**左右双指针（L，R）都在起点，R向右逐位滑动循环，L在内层不断找寻满足的条件**
每次滑动过程中：
如果：窗口内元素满足条件，R向右扩大窗口，并**更新**最优结果；
如果：窗口元素不满足条件，L向右缩小窗口
R到达结尾，算法结束
## 需要考虑的问题
1、什么时候应该扩大窗口？
2、什么时候应该缩小窗口？
3、什么时候应该更新答案？
## 例题
### 最小覆盖字符串
> 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 ""
> 输入：s = "ADOBECODEBANC", t = "ABC"
> 输出："BANC"
> 解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
> 来源：[https://leetcode.cn/problems/minimum-window-substring/](https://leetcode.cn/problems/minimum-window-substring/)

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1553840/1677419455985-b45c140d-8cc0-4172-aa3b-be9d44742f3c.png#averageHue=%23f8f8f8&clientId=ufd3fc8da-3824-4&from=paste&height=533&id=ue3dec182&name=image.png&originHeight=1446&originWidth=1628&originalType=binary&ratio=2&rotation=0&showTitle=false&size=303762&status=done&style=none&taskId=u7ee873b7-1dcc-433d-ab03-0321b257766&title=&width=600)
#### 代码实现
```javascript

const minWindow = (s: string, t: string): string => {
  let left = 0
  const need = new Map()
  for (let c of t) {
    need.set(c, need.has(c) ? need.get(c) + 1 : 1) // 初始化need为t中字符的个数
  }

  // 关键在于need和needCount之间的配合,
  let needCount = need.size
  let res = ''
  for (let right = 0; right < s.length; right++) {
    const current = s[right]
    // 如果need中有当前右指针的字符，need中当前右指针字符对应的计数 - 1
    if (need.has(current)) {  
      need.set(current, need.get(current) - 1)
      //  如果当前右指针字符对应的value === 0 needCount -= 1
      if (need.get(current) === 0) needCount -= 1
    }
    // 当needCount === 0时候说明已经找到符合要求的子串开始处理左指针,可能后面还有，继续往右移动
    while (needCount === 0) {  // 
      const newRes = s.substring(left, right + 1)
      if (!res || newRes.length < res.length) res = newRes

      const c2 = s[left]
      if (need.has(c2)) {
        need.set(c2, need.get(c2) + 1)
        if (need.get(c2) === 1) needCount += 1
      }
      left++
    }
  }

  console.log('need', Object.fromEntries(need.entries()), 'needCount', needCount)
  return res
}
```
### 存在重复元素
> 给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。如果存在，返回 true ；否则，返回 false 。
> 输入：nums = [1,2,3,1], k = 3 输出：true
> 来源：[https://leetcode.cn/problems/contains-duplicate-ii](https://leetcode.cn/problems/contains-duplicate-ii)

题解：

1. set维护i自增，set.has(i) 说明存在题中的 nums[j] === nums[i]
2. 如果 i>k(即i-k > 1) 了，开始删掉i-k的前一项，即i-k-1
#### 代码实现
```javascript
function containsNearbyDuplicate(nums: number[], k: number): boolean {
  let set = new Set()

  for (let i = 0; i < nums.length; i++) {
    if (i > k) {
      set.delete(nums[i - k - 1])
    }
    if (set.has(nums[i])) {
      return true
    }
    set.add(nums[i])
  }
  return false
}
```
### 字符串的排列
> 给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。
> 换句话说，s1 的排列之一是 s2 的 子串 。
> 输入：s1 = "ab" s2 = "eidbaooo" 输出：true 解释：s2 包含 s1 的排列之一 ("ba").
> 来源：[https://leetcode.cn/problems/permutation-in-string](https://leetcode.cn/problems/permutation-in-string)

#### 代码实现
```typescript
function checkInclusion(s1: string, s2: string): boolean {
  // Think for yourself for 5 minutes...

  const need: Map<string, number> = new Map()

  const window: Map<string, number> = new Map()

  for (const t of s1) {
    const a = need.get(t) || 0
    need.set(t, a + 1)
  }

  let left = 0
  let right = 0
  let count: number = 0
  while (right < s2.length) {
    const c = s2[right]
    right++
    // 说明s2中找到了s1的字符
    if (need.has(c)) {
      window.set(c, (window.get(c) || 0) + 1)
      if (window.get(c) === need.get(c)) {
        count++
      }
    }

    // 判断左侧窗口是否需要收缩,right - left 在剩余窗口足够的情况下
    while (right - left >= s1.length) {
      // 说明找到了完整的s1字符串
      if (count === need.size) {
        return true
      }

      const c2 = s2[left]
      // 当上面没成立，左侧窗口就需要收缩了
      left++
      if (need.has(c2)) {
        if (window.get(c2) === need.get(c2)) {
          count--
        }
        window.set(c2, (window.get(c2) || 0) - 1)
      }
    }
  }
  return false
}
```
### 找到字符串中所有字母异位词
> 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
> 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。
> 输入: s = "cbaebabacd", p = "abc"   输出: [0,6]
> 解释:
> 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
> 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
> 来源：[https://leetcode.cn/problems/find-all-anagrams-in-a-string](https://leetcode.cn/problems/find-all-anagrams-in-a-string)

#### 代码实现
```typescript
function findAnagrams(s: string, p: string): number[] {
  // Think for yourself for 5 minutes...

  const need: Map<string, number> = new Map()

  const window: Map<string, number> = new Map()

  for (const t of p) {
    const a = need.get(t) || 0
    need.set(t, a + 1)
  }

  const res: number[] = []

  let left = 0
  let right = 0

  let count: number = 0

  while (right < s.length) {
    const c = s[right]
    right++
    if (need.has(c)) {
      if (window.has(c)) {
        window.set(c, (window.get(c) || 0) + 1)
      } else {
        window.set(c, 1)
      }

      if (need.get(c) === window.get(c)) {
        count++
      }
    }

    while (right - left >= p.length) {
      if (count === need.size) {
        res.push(left)
      }

      const c2 = s[left]
      left++
      if (need.has(c2)) {
        if (window.get(c2) === need.get(c2)) {
          count--
        }

        window.set(c2, (window.get(c2) || 0) - 1)
      }
    }
  }

  return res
}
```
### 
### 
### 例题引用
[算法:数组](https://www.yuque.com/vannvan/tools/gn1g4k6g0oiyohp7?view=doc_embed&inner=MGl2z)
## 
## 算法框架
```typescript
/**
 * 滑动窗口算法框架
 * @param {string} s
 * @return {void}
 */
var slidingWindow = function(s) {
    const window = new Map();
    
    let left = 0, right = 0;
    while (right < s.length) {
        // c 是将移入窗口的字符
        const c = s[right];
        // 增大窗口
        right++;
        // 进行窗口内数据的一系列更新
        // TODO 更新逻辑

        /*** debug 输出的位置 ***/
        // 注意在最终的解法代码中不要 console.log
        // 因为 IO 操作很耗时，可能导致超时
        console.log(`window: [${left}, ${right})`);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            const d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            // TODO 更新逻辑
        }
    }
};
```

TIPS:by(labuladong)
> 理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 left = right = 0 时区间 [0, 0) 中没有元素，但只要让 right 向右移动（扩大）一位，区间 [0, 1) 就包含一个元素 0 了。如果你设置为两端都开的区间，那么让 right 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。



## 资料

- 
- 

